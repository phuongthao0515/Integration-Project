{
  "version": 3,
  "sources": ["../../mdast-util-phrasing/node_modules/unist-util-is/lib/index.js", "../../mdast-util-phrasing/lib/index.js"],
  "sourcesContent": ["/**\r\n * @typedef {import('unist').Node} Node\r\n * @typedef {import('unist').Parent} Parent\r\n */\r\n\r\n/**\r\n * @typedef {Record<string, unknown>} Props\r\n * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test\r\n *   Check for an arbitrary node, unaware of TypeScript inferral.\r\n *\r\n * @callback TestFunctionAnything\r\n *   Check if a node passes a test, unaware of TypeScript inferral.\r\n * @param {unknown} this\r\n *   The given context.\r\n * @param {Node} node\r\n *   A node.\r\n * @param {number | null | undefined} [index]\r\n *   The node’s position in its parent.\r\n * @param {Parent | null | undefined} [parent]\r\n *   The node’s parent.\r\n * @returns {boolean | void}\r\n *   Whether this node passes the test.\r\n */\r\n\r\n/**\r\n * @template {Node} Kind\r\n *   Node type.\r\n * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest\r\n *   Check for a node that can be inferred by TypeScript.\r\n */\r\n\r\n/**\r\n * Check if a node passes a certain test.\r\n *\r\n * @template {Node} Kind\r\n *   Node type.\r\n * @callback TestFunctionPredicate\r\n *   Complex test function for a node that can be inferred by TypeScript.\r\n * @param {Node} node\r\n *   A node.\r\n * @param {number | null | undefined} [index]\r\n *   The node’s position in its parent.\r\n * @param {Parent | null | undefined} [parent]\r\n *   The node’s parent.\r\n * @returns {node is Kind}\r\n *   Whether this node passes the test.\r\n */\r\n\r\n/**\r\n * @callback AssertAnything\r\n *   Check that an arbitrary value is a node, unaware of TypeScript inferral.\r\n * @param {unknown} [node]\r\n *   Anything (typically a node).\r\n * @param {number | null | undefined} [index]\r\n *   The node’s position in its parent.\r\n * @param {Parent | null | undefined} [parent]\r\n *   The node’s parent.\r\n * @returns {boolean}\r\n *   Whether this is a node and passes a test.\r\n */\r\n\r\n/**\r\n * Check if a node is a node and passes a certain node test.\r\n *\r\n * @template {Node} Kind\r\n *   Node type.\r\n * @callback AssertPredicate\r\n *   Check that an arbitrary value is a specific node, aware of TypeScript.\r\n * @param {unknown} [node]\r\n *   Anything (typically a node).\r\n * @param {number | null | undefined} [index]\r\n *   The node’s position in its parent.\r\n * @param {Parent | null | undefined} [parent]\r\n *   The node’s parent.\r\n * @returns {node is Kind}\r\n *   Whether this is a node and passes a test.\r\n */\r\n\r\n/**\r\n * Check if `node` is a `Node` and whether it passes the given test.\r\n *\r\n * @param node\r\n *   Thing to check, typically `Node`.\r\n * @param test\r\n *   A check for a specific node.\r\n * @param index\r\n *   The node’s position in its parent.\r\n * @param parent\r\n *   The node’s parent.\r\n * @returns\r\n *   Whether `node` is a node and passes a test.\r\n */\r\nexport const is =\r\n  /**\r\n   * @type {(\r\n   *   (() => false) &\r\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &\r\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &\r\n   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &\r\n   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)\r\n   * )}\r\n   */\r\n  (\r\n    /**\r\n     * @param {unknown} [node]\r\n     * @param {Test} [test]\r\n     * @param {number | null | undefined} [index]\r\n     * @param {Parent | null | undefined} [parent]\r\n     * @param {unknown} [context]\r\n     * @returns {boolean}\r\n     */\r\n    // eslint-disable-next-line max-params\r\n    function is(node, test, index, parent, context) {\r\n      const check = convert(test)\r\n\r\n      if (\r\n        index !== undefined &&\r\n        index !== null &&\r\n        (typeof index !== 'number' ||\r\n          index < 0 ||\r\n          index === Number.POSITIVE_INFINITY)\r\n      ) {\r\n        throw new Error('Expected positive finite index')\r\n      }\r\n\r\n      if (\r\n        parent !== undefined &&\r\n        parent !== null &&\r\n        (!is(parent) || !parent.children)\r\n      ) {\r\n        throw new Error('Expected parent node')\r\n      }\r\n\r\n      if (\r\n        (parent === undefined || parent === null) !==\r\n        (index === undefined || index === null)\r\n      ) {\r\n        throw new Error('Expected both parent and index')\r\n      }\r\n\r\n      // @ts-expect-error Looks like a node.\r\n      return node && node.type && typeof node.type === 'string'\r\n        ? Boolean(check.call(context, node, index, parent))\r\n        : false\r\n    }\r\n  )\r\n\r\n/**\r\n * Generate an assertion from a test.\r\n *\r\n * Useful if you’re going to test many nodes, for example when creating a\r\n * utility where something else passes a compatible test.\r\n *\r\n * The created function is a bit faster because it expects valid input only:\r\n * a `node`, `index`, and `parent`.\r\n *\r\n * @param test\r\n *   *   when nullish, checks if `node` is a `Node`.\r\n *   *   when `string`, works like passing `(node) => node.type === test`.\r\n *   *   when `function` checks if function passed the node is true.\r\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\r\n *   *   when `array`, checks if any one of the subtests pass.\r\n * @returns\r\n *   An assertion.\r\n */\r\nexport const convert =\r\n  /**\r\n   * @type {(\r\n   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\r\n   *   ((test?: Test) => AssertAnything)\r\n   * )}\r\n   */\r\n  (\r\n    /**\r\n     * @param {Test} [test]\r\n     * @returns {AssertAnything}\r\n     */\r\n    function (test) {\r\n      if (test === undefined || test === null) {\r\n        return ok\r\n      }\r\n\r\n      if (typeof test === 'string') {\r\n        return typeFactory(test)\r\n      }\r\n\r\n      if (typeof test === 'object') {\r\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\r\n      }\r\n\r\n      if (typeof test === 'function') {\r\n        return castFactory(test)\r\n      }\r\n\r\n      throw new Error('Expected function, string, or object as test')\r\n    }\r\n  )\r\n\r\n/**\r\n * @param {Array<string | Props | TestFunctionAnything>} tests\r\n * @returns {AssertAnything}\r\n */\r\nfunction anyFactory(tests) {\r\n  /** @type {Array<AssertAnything>} */\r\n  const checks = []\r\n  let index = -1\r\n\r\n  while (++index < tests.length) {\r\n    checks[index] = convert(tests[index])\r\n  }\r\n\r\n  return castFactory(any)\r\n\r\n  /**\r\n   * @this {unknown}\r\n   * @param {Array<unknown>} parameters\r\n   * @returns {boolean}\r\n   */\r\n  function any(...parameters) {\r\n    let index = -1\r\n\r\n    while (++index < checks.length) {\r\n      if (checks[index].call(this, ...parameters)) return true\r\n    }\r\n\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * Turn an object into a test for a node with a certain fields.\r\n *\r\n * @param {Props} check\r\n * @returns {AssertAnything}\r\n */\r\nfunction propsFactory(check) {\r\n  return castFactory(all)\r\n\r\n  /**\r\n   * @param {Node} node\r\n   * @returns {boolean}\r\n   */\r\n  function all(node) {\r\n    /** @type {string} */\r\n    let key\r\n\r\n    for (key in check) {\r\n      // @ts-expect-error: hush, it sure works as an index.\r\n      if (node[key] !== check[key]) return false\r\n    }\r\n\r\n    return true\r\n  }\r\n}\r\n\r\n/**\r\n * Turn a string into a test for a node with a certain type.\r\n *\r\n * @param {string} check\r\n * @returns {AssertAnything}\r\n */\r\nfunction typeFactory(check) {\r\n  return castFactory(type)\r\n\r\n  /**\r\n   * @param {Node} node\r\n   */\r\n  function type(node) {\r\n    return node && node.type === check\r\n  }\r\n}\r\n\r\n/**\r\n * Turn a custom test into a test for a node that passes that test.\r\n *\r\n * @param {TestFunctionAnything} check\r\n * @returns {AssertAnything}\r\n */\r\nfunction castFactory(check) {\r\n  return assertion\r\n\r\n  /**\r\n   * @this {unknown}\r\n   * @param {unknown} node\r\n   * @param {Array<unknown>} parameters\r\n   * @returns {boolean}\r\n   */\r\n  function assertion(node, ...parameters) {\r\n    return Boolean(\r\n      node &&\r\n        typeof node === 'object' &&\r\n        'type' in node &&\r\n        // @ts-expect-error: fine.\r\n        Boolean(check.call(this, node, ...parameters))\r\n    )\r\n  }\r\n}\r\n\r\nfunction ok() {\r\n  return true\r\n}\r\n", "/**\r\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\r\n * @typedef {import('unist-util-is').AssertPredicate<PhrasingContent>} AssertPredicatePhrasing\r\n */\r\n\r\nimport {convert} from 'unist-util-is'\r\n\r\n/**\r\n * Check if the given value is *phrasing content*.\r\n *\r\n * @param\r\n *   Thing to check, typically `Node`.\r\n * @returns\r\n *   Whether `value` is phrasing content.\r\n */\r\nexport const phrasing = /** @type {AssertPredicatePhrasing} */ (\r\n  convert([\r\n    'break',\r\n    'delete',\r\n    'emphasis',\r\n    'footnote',\r\n    'footnoteReference',\r\n    'image',\r\n    'imageReference',\r\n    'inlineCode',\r\n    'link',\r\n    'linkReference',\r\n    'strong',\r\n    'text'\r\n  ])\r\n)\r\n"],
  "mappings": ";AAqKO,IAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYT,SAAU,MAAM;AACd,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,aAAO;AAAA,IACT;AAEA,QAAI,OAAO,SAAS,UAAU;AAC5B,aAAO,YAAY,IAAI;AAAA,IACzB;AAEA,QAAI,OAAO,SAAS,UAAU;AAC5B,aAAO,MAAM,QAAQ,IAAI,IAAI,WAAW,IAAI,IAAI,aAAa,IAAI;AAAA,IACnE;AAEA,QAAI,OAAO,SAAS,YAAY;AAC9B,aAAO,YAAY,IAAI;AAAA,IACzB;AAEA,UAAM,IAAI,MAAM,8CAA8C;AAAA,EAChE;AAAA;AAOJ,SAAS,WAAW,OAAO;AAEzB,QAAM,SAAS,CAAC;AAChB,MAAI,QAAQ;AAEZ,SAAO,EAAE,QAAQ,MAAM,QAAQ;AAC7B,WAAO,KAAK,IAAI,QAAQ,MAAM,KAAK,CAAC;AAAA,EACtC;AAEA,SAAO,YAAY,GAAG;AAOtB,WAAS,OAAO,YAAY;AAC1B,QAAIA,SAAQ;AAEZ,WAAO,EAAEA,SAAQ,OAAO,QAAQ;AAC9B,UAAI,OAAOA,MAAK,EAAE,KAAK,MAAM,GAAG,UAAU,EAAG,QAAO;AAAA,IACtD;AAEA,WAAO;AAAA,EACT;AACF;AAQA,SAAS,aAAa,OAAO;AAC3B,SAAO,YAAY,GAAG;AAMtB,WAAS,IAAI,MAAM;AAEjB,QAAI;AAEJ,SAAK,OAAO,OAAO;AAEjB,UAAI,KAAK,GAAG,MAAM,MAAM,GAAG,EAAG,QAAO;AAAA,IACvC;AAEA,WAAO;AAAA,EACT;AACF;AAQA,SAAS,YAAY,OAAO;AAC1B,SAAO,YAAY,IAAI;AAKvB,WAAS,KAAK,MAAM;AAClB,WAAO,QAAQ,KAAK,SAAS;AAAA,EAC/B;AACF;AAQA,SAAS,YAAY,OAAO;AAC1B,SAAO;AAQP,WAAS,UAAU,SAAS,YAAY;AACtC,WAAO;AAAA,MACL,QACE,OAAO,SAAS,YAChB,UAAU;AAAA,MAEV,QAAQ,MAAM,KAAK,MAAM,MAAM,GAAG,UAAU,CAAC;AAAA,IACjD;AAAA,EACF;AACF;AAEA,SAAS,KAAK;AACZ,SAAO;AACT;;;AC7RO,IAAM;AAAA;AAAA,EACX,QAAQ;AAAA,IACN;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AAAA;",
  "names": ["index"]
}
