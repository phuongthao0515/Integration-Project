{
  "version": 3,
  "sources": ["../../prosemirror-tables/dist/index.js", "../../@tiptap/extension-table/src/utilities/colStyle.ts", "../../@tiptap/extension-table/src/TableView.ts", "../../@tiptap/extension-table/src/utilities/createColGroup.ts", "../../@tiptap/extension-table/src/utilities/createCell.ts", "../../@tiptap/extension-table/src/utilities/getTableNodeTypes.ts", "../../@tiptap/extension-table/src/utilities/createTable.ts", "../../@tiptap/extension-table/src/utilities/isCellSelection.ts", "../../@tiptap/extension-table/src/utilities/deleteTableWhenAllCellsSelected.ts", "../../@tiptap/extension-table/src/table.ts"],
  "sourcesContent": ["// src/index.ts\r\nimport { Plugin as Plugin2 } from \"prosemirror-state\";\r\n\r\n// src/cellselection.ts\r\nimport { Fragment, Slice } from \"prosemirror-model\";\r\nimport {\r\n  NodeSelection as NodeSelection2,\r\n  Selection,\r\n  SelectionRange,\r\n  TextSelection\r\n} from \"prosemirror-state\";\r\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\r\n\r\n// src/tablemap.ts\r\nvar readFromCache;\r\nvar addToCache;\r\nif (typeof WeakMap != \"undefined\") {\r\n  let cache = /* @__PURE__ */ new WeakMap();\r\n  readFromCache = (key) => cache.get(key);\r\n  addToCache = (key, value) => {\r\n    cache.set(key, value);\r\n    return value;\r\n  };\r\n} else {\r\n  const cache = [];\r\n  const cacheSize = 10;\r\n  let cachePos = 0;\r\n  readFromCache = (key) => {\r\n    for (let i = 0; i < cache.length; i += 2)\r\n      if (cache[i] == key)\r\n        return cache[i + 1];\r\n  };\r\n  addToCache = (key, value) => {\r\n    if (cachePos == cacheSize)\r\n      cachePos = 0;\r\n    cache[cachePos++] = key;\r\n    return cache[cachePos++] = value;\r\n  };\r\n}\r\nvar TableMap = class {\r\n  constructor(width, height, map, problems) {\r\n    this.width = width;\r\n    this.height = height;\r\n    this.map = map;\r\n    this.problems = problems;\r\n  }\r\n  // Find the dimensions of the cell at the given position.\r\n  findCell(pos) {\r\n    for (let i = 0; i < this.map.length; i++) {\r\n      const curPos = this.map[i];\r\n      if (curPos != pos)\r\n        continue;\r\n      const left = i % this.width;\r\n      const top = i / this.width | 0;\r\n      let right = left + 1;\r\n      let bottom = top + 1;\r\n      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++) {\r\n        right++;\r\n      }\r\n      for (let j = 1; bottom < this.height && this.map[i + this.width * j] == curPos; j++) {\r\n        bottom++;\r\n      }\r\n      return { left, top, right, bottom };\r\n    }\r\n    throw new RangeError(`No cell with offset ${pos} found`);\r\n  }\r\n  // Find the left side of the cell at the given position.\r\n  colCount(pos) {\r\n    for (let i = 0; i < this.map.length; i++) {\r\n      if (this.map[i] == pos) {\r\n        return i % this.width;\r\n      }\r\n    }\r\n    throw new RangeError(`No cell with offset ${pos} found`);\r\n  }\r\n  // Find the next cell in the given direction, starting from the cell\r\n  // at `pos`, if any.\r\n  nextCell(pos, axis, dir) {\r\n    const { left, right, top, bottom } = this.findCell(pos);\r\n    if (axis == \"horiz\") {\r\n      if (dir < 0 ? left == 0 : right == this.width)\r\n        return null;\r\n      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];\r\n    } else {\r\n      if (dir < 0 ? top == 0 : bottom == this.height)\r\n        return null;\r\n      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\r\n    }\r\n  }\r\n  // Get the rectangle spanning the two given cells.\r\n  rectBetween(a, b) {\r\n    const {\r\n      left: leftA,\r\n      right: rightA,\r\n      top: topA,\r\n      bottom: bottomA\r\n    } = this.findCell(a);\r\n    const {\r\n      left: leftB,\r\n      right: rightB,\r\n      top: topB,\r\n      bottom: bottomB\r\n    } = this.findCell(b);\r\n    return {\r\n      left: Math.min(leftA, leftB),\r\n      top: Math.min(topA, topB),\r\n      right: Math.max(rightA, rightB),\r\n      bottom: Math.max(bottomA, bottomB)\r\n    };\r\n  }\r\n  // Return the position of all cells that have the top left corner in\r\n  // the given rectangle.\r\n  cellsInRect(rect) {\r\n    const result = [];\r\n    const seen = {};\r\n    for (let row = rect.top; row < rect.bottom; row++) {\r\n      for (let col = rect.left; col < rect.right; col++) {\r\n        const index = row * this.width + col;\r\n        const pos = this.map[index];\r\n        if (seen[pos])\r\n          continue;\r\n        seen[pos] = true;\r\n        if (col == rect.left && col && this.map[index - 1] == pos || row == rect.top && row && this.map[index - this.width] == pos) {\r\n          continue;\r\n        }\r\n        result.push(pos);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  // Return the position at which the cell at the given row and column\r\n  // starts, or would start, if a cell started there.\r\n  positionAt(row, col, table) {\r\n    for (let i = 0, rowStart = 0; ; i++) {\r\n      const rowEnd = rowStart + table.child(i).nodeSize;\r\n      if (i == row) {\r\n        let index = col + row * this.width;\r\n        const rowEndIndex = (row + 1) * this.width;\r\n        while (index < rowEndIndex && this.map[index] < rowStart)\r\n          index++;\r\n        return index == rowEndIndex ? rowEnd - 1 : this.map[index];\r\n      }\r\n      rowStart = rowEnd;\r\n    }\r\n  }\r\n  // Find the table map for the given table node.\r\n  static get(table) {\r\n    return readFromCache(table) || addToCache(table, computeMap(table));\r\n  }\r\n};\r\nfunction computeMap(table) {\r\n  if (table.type.spec.tableRole != \"table\")\r\n    throw new RangeError(\"Not a table node: \" + table.type.name);\r\n  const width = findWidth(table), height = table.childCount;\r\n  const map = [];\r\n  let mapPos = 0;\r\n  let problems = null;\r\n  const colWidths = [];\r\n  for (let i = 0, e = width * height; i < e; i++)\r\n    map[i] = 0;\r\n  for (let row = 0, pos = 0; row < height; row++) {\r\n    const rowNode = table.child(row);\r\n    pos++;\r\n    for (let i = 0; ; i++) {\r\n      while (mapPos < map.length && map[mapPos] != 0)\r\n        mapPos++;\r\n      if (i == rowNode.childCount)\r\n        break;\r\n      const cellNode = rowNode.child(i);\r\n      const { colspan, rowspan, colwidth } = cellNode.attrs;\r\n      for (let h = 0; h < rowspan; h++) {\r\n        if (h + row >= height) {\r\n          (problems || (problems = [])).push({\r\n            type: \"overlong_rowspan\",\r\n            pos,\r\n            n: rowspan - h\r\n          });\r\n          break;\r\n        }\r\n        const start = mapPos + h * width;\r\n        for (let w = 0; w < colspan; w++) {\r\n          if (map[start + w] == 0)\r\n            map[start + w] = pos;\r\n          else\r\n            (problems || (problems = [])).push({\r\n              type: \"collision\",\r\n              row,\r\n              pos,\r\n              n: colspan - w\r\n            });\r\n          const colW = colwidth && colwidth[w];\r\n          if (colW) {\r\n            const widthIndex = (start + w) % width * 2, prev = colWidths[widthIndex];\r\n            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {\r\n              colWidths[widthIndex] = colW;\r\n              colWidths[widthIndex + 1] = 1;\r\n            } else if (prev == colW) {\r\n              colWidths[widthIndex + 1]++;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      mapPos += colspan;\r\n      pos += cellNode.nodeSize;\r\n    }\r\n    const expectedPos = (row + 1) * width;\r\n    let missing = 0;\r\n    while (mapPos < expectedPos)\r\n      if (map[mapPos++] == 0)\r\n        missing++;\r\n    if (missing)\r\n      (problems || (problems = [])).push({ type: \"missing\", row, n: missing });\r\n    pos++;\r\n  }\r\n  const tableMap = new TableMap(width, height, map, problems);\r\n  let badWidths = false;\r\n  for (let i = 0; !badWidths && i < colWidths.length; i += 2)\r\n    if (colWidths[i] != null && colWidths[i + 1] < height)\r\n      badWidths = true;\r\n  if (badWidths)\r\n    findBadColWidths(tableMap, colWidths, table);\r\n  return tableMap;\r\n}\r\nfunction findWidth(table) {\r\n  let width = -1;\r\n  let hasRowSpan = false;\r\n  for (let row = 0; row < table.childCount; row++) {\r\n    const rowNode = table.child(row);\r\n    let rowWidth = 0;\r\n    if (hasRowSpan)\r\n      for (let j = 0; j < row; j++) {\r\n        const prevRow = table.child(j);\r\n        for (let i = 0; i < prevRow.childCount; i++) {\r\n          const cell = prevRow.child(i);\r\n          if (j + cell.attrs.rowspan > row)\r\n            rowWidth += cell.attrs.colspan;\r\n        }\r\n      }\r\n    for (let i = 0; i < rowNode.childCount; i++) {\r\n      const cell = rowNode.child(i);\r\n      rowWidth += cell.attrs.colspan;\r\n      if (cell.attrs.rowspan > 1)\r\n        hasRowSpan = true;\r\n    }\r\n    if (width == -1)\r\n      width = rowWidth;\r\n    else if (width != rowWidth)\r\n      width = Math.max(width, rowWidth);\r\n  }\r\n  return width;\r\n}\r\nfunction findBadColWidths(map, colWidths, table) {\r\n  if (!map.problems)\r\n    map.problems = [];\r\n  const seen = {};\r\n  for (let i = 0; i < map.map.length; i++) {\r\n    const pos = map.map[i];\r\n    if (seen[pos])\r\n      continue;\r\n    seen[pos] = true;\r\n    const node = table.nodeAt(pos);\r\n    if (!node) {\r\n      throw new RangeError(`No cell with offset ${pos} found`);\r\n    }\r\n    let updated = null;\r\n    const attrs = node.attrs;\r\n    for (let j = 0; j < attrs.colspan; j++) {\r\n      const col = (i + j) % map.width;\r\n      const colWidth = colWidths[col * 2];\r\n      if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth))\r\n        (updated || (updated = freshColWidth(attrs)))[j] = colWidth;\r\n    }\r\n    if (updated)\r\n      map.problems.unshift({\r\n        type: \"colwidth mismatch\",\r\n        pos,\r\n        colwidth: updated\r\n      });\r\n  }\r\n}\r\nfunction freshColWidth(attrs) {\r\n  if (attrs.colwidth)\r\n    return attrs.colwidth.slice();\r\n  const result = [];\r\n  for (let i = 0; i < attrs.colspan; i++)\r\n    result.push(0);\r\n  return result;\r\n}\r\n\r\n// src/util.ts\r\nimport { PluginKey } from \"prosemirror-state\";\r\n\r\n// src/schema.ts\r\nfunction getCellAttrs(dom, extraAttrs) {\r\n  if (typeof dom === \"string\") {\r\n    return {};\r\n  }\r\n  const widthAttr = dom.getAttribute(\"data-colwidth\");\r\n  const widths = widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr) ? widthAttr.split(\",\").map((s) => Number(s)) : null;\r\n  const colspan = Number(dom.getAttribute(\"colspan\") || 1);\r\n  const result = {\r\n    colspan,\r\n    rowspan: Number(dom.getAttribute(\"rowspan\") || 1),\r\n    colwidth: widths && widths.length == colspan ? widths : null\r\n  };\r\n  for (const prop in extraAttrs) {\r\n    const getter = extraAttrs[prop].getFromDOM;\r\n    const value = getter && getter(dom);\r\n    if (value != null) {\r\n      result[prop] = value;\r\n    }\r\n  }\r\n  return result;\r\n}\r\nfunction setCellAttrs(node, extraAttrs) {\r\n  const attrs = {};\r\n  if (node.attrs.colspan != 1)\r\n    attrs.colspan = node.attrs.colspan;\r\n  if (node.attrs.rowspan != 1)\r\n    attrs.rowspan = node.attrs.rowspan;\r\n  if (node.attrs.colwidth)\r\n    attrs[\"data-colwidth\"] = node.attrs.colwidth.join(\",\");\r\n  for (const prop in extraAttrs) {\r\n    const setter = extraAttrs[prop].setDOMAttr;\r\n    if (setter)\r\n      setter(node.attrs[prop], attrs);\r\n  }\r\n  return attrs;\r\n}\r\nfunction tableNodes(options) {\r\n  const extraAttrs = options.cellAttributes || {};\r\n  const cellAttrs = {\r\n    colspan: { default: 1 },\r\n    rowspan: { default: 1 },\r\n    colwidth: { default: null }\r\n  };\r\n  for (const prop in extraAttrs)\r\n    cellAttrs[prop] = { default: extraAttrs[prop].default };\r\n  return {\r\n    table: {\r\n      content: \"table_row+\",\r\n      tableRole: \"table\",\r\n      isolating: true,\r\n      group: options.tableGroup,\r\n      parseDOM: [{ tag: \"table\" }],\r\n      toDOM() {\r\n        return [\"table\", [\"tbody\", 0]];\r\n      }\r\n    },\r\n    table_row: {\r\n      content: \"(table_cell | table_header)*\",\r\n      tableRole: \"row\",\r\n      parseDOM: [{ tag: \"tr\" }],\r\n      toDOM() {\r\n        return [\"tr\", 0];\r\n      }\r\n    },\r\n    table_cell: {\r\n      content: options.cellContent,\r\n      attrs: cellAttrs,\r\n      tableRole: \"cell\",\r\n      isolating: true,\r\n      parseDOM: [\r\n        { tag: \"td\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\r\n      ],\r\n      toDOM(node) {\r\n        return [\"td\", setCellAttrs(node, extraAttrs), 0];\r\n      }\r\n    },\r\n    table_header: {\r\n      content: options.cellContent,\r\n      attrs: cellAttrs,\r\n      tableRole: \"header_cell\",\r\n      isolating: true,\r\n      parseDOM: [\r\n        { tag: \"th\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\r\n      ],\r\n      toDOM(node) {\r\n        return [\"th\", setCellAttrs(node, extraAttrs), 0];\r\n      }\r\n    }\r\n  };\r\n}\r\nfunction tableNodeTypes(schema) {\r\n  let result = schema.cached.tableNodeTypes;\r\n  if (!result) {\r\n    result = schema.cached.tableNodeTypes = {};\r\n    for (const name in schema.nodes) {\r\n      const type = schema.nodes[name], role = type.spec.tableRole;\r\n      if (role)\r\n        result[role] = type;\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n// src/util.ts\r\nvar tableEditingKey = new PluginKey(\"selectingCells\");\r\nfunction cellAround($pos) {\r\n  for (let d = $pos.depth - 1; d > 0; d--)\r\n    if ($pos.node(d).type.spec.tableRole == \"row\")\r\n      return $pos.node(0).resolve($pos.before(d + 1));\r\n  return null;\r\n}\r\nfunction cellWrapping($pos) {\r\n  for (let d = $pos.depth; d > 0; d--) {\r\n    const role = $pos.node(d).type.spec.tableRole;\r\n    if (role === \"cell\" || role === \"header_cell\")\r\n      return $pos.node(d);\r\n  }\r\n  return null;\r\n}\r\nfunction isInTable(state) {\r\n  const $head = state.selection.$head;\r\n  for (let d = $head.depth; d > 0; d--)\r\n    if ($head.node(d).type.spec.tableRole == \"row\")\r\n      return true;\r\n  return false;\r\n}\r\nfunction selectionCell(state) {\r\n  const sel = state.selection;\r\n  if (\"$anchorCell\" in sel && sel.$anchorCell) {\r\n    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\r\n  } else if (\"node\" in sel && sel.node && sel.node.type.spec.tableRole == \"cell\") {\r\n    return sel.$anchor;\r\n  }\r\n  const $cell = cellAround(sel.$head) || cellNear(sel.$head);\r\n  if ($cell) {\r\n    return $cell;\r\n  }\r\n  throw new RangeError(`No cell found around position ${sel.head}`);\r\n}\r\nfunction cellNear($pos) {\r\n  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {\r\n    const role = after.type.spec.tableRole;\r\n    if (role == \"cell\" || role == \"header_cell\")\r\n      return $pos.doc.resolve(pos);\r\n  }\r\n  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {\r\n    const role = before.type.spec.tableRole;\r\n    if (role == \"cell\" || role == \"header_cell\")\r\n      return $pos.doc.resolve(pos - before.nodeSize);\r\n  }\r\n}\r\nfunction pointsAtCell($pos) {\r\n  return $pos.parent.type.spec.tableRole == \"row\" && !!$pos.nodeAfter;\r\n}\r\nfunction moveCellForward($pos) {\r\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);\r\n}\r\nfunction inSameTable($cellA, $cellB) {\r\n  return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);\r\n}\r\nfunction findCell($pos) {\r\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));\r\n}\r\nfunction colCount($pos) {\r\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));\r\n}\r\nfunction nextCell($pos, axis, dir) {\r\n  const table = $pos.node(-1);\r\n  const map = TableMap.get(table);\r\n  const tableStart = $pos.start(-1);\r\n  const moved = map.nextCell($pos.pos - tableStart, axis, dir);\r\n  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);\r\n}\r\nfunction removeColSpan(attrs, pos, n = 1) {\r\n  const result = { ...attrs, colspan: attrs.colspan - n };\r\n  if (result.colwidth) {\r\n    result.colwidth = result.colwidth.slice();\r\n    result.colwidth.splice(pos, n);\r\n    if (!result.colwidth.some((w) => w > 0))\r\n      result.colwidth = null;\r\n  }\r\n  return result;\r\n}\r\nfunction addColSpan(attrs, pos, n = 1) {\r\n  const result = { ...attrs, colspan: attrs.colspan + n };\r\n  if (result.colwidth) {\r\n    result.colwidth = result.colwidth.slice();\r\n    for (let i = 0; i < n; i++)\r\n      result.colwidth.splice(pos, 0, 0);\r\n  }\r\n  return result;\r\n}\r\nfunction columnIsHeader(map, table, col) {\r\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\r\n  for (let row = 0; row < map.height; row++)\r\n    if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)\r\n      return false;\r\n  return true;\r\n}\r\n\r\n// src/cellselection.ts\r\nvar CellSelection = class _CellSelection extends Selection {\r\n  // A table selection is identified by its anchor and head cells. The\r\n  // positions given to this constructor should point _before_ two\r\n  // cells in the same table. They may be the same, to select a single\r\n  // cell.\r\n  constructor($anchorCell, $headCell = $anchorCell) {\r\n    const table = $anchorCell.node(-1);\r\n    const map = TableMap.get(table);\r\n    const tableStart = $anchorCell.start(-1);\r\n    const rect = map.rectBetween(\r\n      $anchorCell.pos - tableStart,\r\n      $headCell.pos - tableStart\r\n    );\r\n    const doc = $anchorCell.node(0);\r\n    const cells = map.cellsInRect(rect).filter((p) => p != $headCell.pos - tableStart);\r\n    cells.unshift($headCell.pos - tableStart);\r\n    const ranges = cells.map((pos) => {\r\n      const cell = table.nodeAt(pos);\r\n      if (!cell) {\r\n        throw RangeError(`No cell with offset ${pos} found`);\r\n      }\r\n      const from = tableStart + pos + 1;\r\n      return new SelectionRange(\r\n        doc.resolve(from),\r\n        doc.resolve(from + cell.content.size)\r\n      );\r\n    });\r\n    super(ranges[0].$from, ranges[0].$to, ranges);\r\n    this.$anchorCell = $anchorCell;\r\n    this.$headCell = $headCell;\r\n  }\r\n  map(doc, mapping) {\r\n    const $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\r\n    const $headCell = doc.resolve(mapping.map(this.$headCell.pos));\r\n    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\r\n      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\r\n      if (tableChanged && this.isRowSelection())\r\n        return _CellSelection.rowSelection($anchorCell, $headCell);\r\n      else if (tableChanged && this.isColSelection())\r\n        return _CellSelection.colSelection($anchorCell, $headCell);\r\n      else\r\n        return new _CellSelection($anchorCell, $headCell);\r\n    }\r\n    return TextSelection.between($anchorCell, $headCell);\r\n  }\r\n  // Returns a rectangular slice of table rows containing the selected\r\n  // cells.\r\n  content() {\r\n    const table = this.$anchorCell.node(-1);\r\n    const map = TableMap.get(table);\r\n    const tableStart = this.$anchorCell.start(-1);\r\n    const rect = map.rectBetween(\r\n      this.$anchorCell.pos - tableStart,\r\n      this.$headCell.pos - tableStart\r\n    );\r\n    const seen = {};\r\n    const rows = [];\r\n    for (let row = rect.top; row < rect.bottom; row++) {\r\n      const rowContent = [];\r\n      for (let index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {\r\n        const pos = map.map[index];\r\n        if (seen[pos])\r\n          continue;\r\n        seen[pos] = true;\r\n        const cellRect = map.findCell(pos);\r\n        let cell = table.nodeAt(pos);\r\n        if (!cell) {\r\n          throw RangeError(`No cell with offset ${pos} found`);\r\n        }\r\n        const extraLeft = rect.left - cellRect.left;\r\n        const extraRight = cellRect.right - rect.right;\r\n        if (extraLeft > 0 || extraRight > 0) {\r\n          let attrs = cell.attrs;\r\n          if (extraLeft > 0) {\r\n            attrs = removeColSpan(attrs, 0, extraLeft);\r\n          }\r\n          if (extraRight > 0) {\r\n            attrs = removeColSpan(\r\n              attrs,\r\n              attrs.colspan - extraRight,\r\n              extraRight\r\n            );\r\n          }\r\n          if (cellRect.left < rect.left) {\r\n            cell = cell.type.createAndFill(attrs);\r\n            if (!cell) {\r\n              throw RangeError(\r\n                `Could not create cell with attrs ${JSON.stringify(attrs)}`\r\n              );\r\n            }\r\n          } else {\r\n            cell = cell.type.create(attrs, cell.content);\r\n          }\r\n        }\r\n        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\r\n          const attrs = {\r\n            ...cell.attrs,\r\n            rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)\r\n          };\r\n          if (cellRect.top < rect.top) {\r\n            cell = cell.type.createAndFill(attrs);\r\n          } else {\r\n            cell = cell.type.create(attrs, cell.content);\r\n          }\r\n        }\r\n        rowContent.push(cell);\r\n      }\r\n      rows.push(table.child(row).copy(Fragment.from(rowContent)));\r\n    }\r\n    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\r\n    return new Slice(Fragment.from(fragment), 1, 1);\r\n  }\r\n  replace(tr, content = Slice.empty) {\r\n    const mapFrom = tr.steps.length, ranges = this.ranges;\r\n    for (let i = 0; i < ranges.length; i++) {\r\n      const { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\r\n      tr.replace(\r\n        mapping.map($from.pos),\r\n        mapping.map($to.pos),\r\n        i ? Slice.empty : content\r\n      );\r\n    }\r\n    const sel = Selection.findFrom(\r\n      tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),\r\n      -1\r\n    );\r\n    if (sel)\r\n      tr.setSelection(sel);\r\n  }\r\n  replaceWith(tr, node) {\r\n    this.replace(tr, new Slice(Fragment.from(node), 0, 0));\r\n  }\r\n  forEachCell(f) {\r\n    const table = this.$anchorCell.node(-1);\r\n    const map = TableMap.get(table);\r\n    const tableStart = this.$anchorCell.start(-1);\r\n    const cells = map.cellsInRect(\r\n      map.rectBetween(\r\n        this.$anchorCell.pos - tableStart,\r\n        this.$headCell.pos - tableStart\r\n      )\r\n    );\r\n    for (let i = 0; i < cells.length; i++) {\r\n      f(table.nodeAt(cells[i]), tableStart + cells[i]);\r\n    }\r\n  }\r\n  // True if this selection goes all the way from the top to the\r\n  // bottom of the table.\r\n  isColSelection() {\r\n    const anchorTop = this.$anchorCell.index(-1);\r\n    const headTop = this.$headCell.index(-1);\r\n    if (Math.min(anchorTop, headTop) > 0)\r\n      return false;\r\n    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;\r\n    const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;\r\n    return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;\r\n  }\r\n  // Returns the smallest column selection that covers the given anchor\r\n  // and head cell.\r\n  static colSelection($anchorCell, $headCell = $anchorCell) {\r\n    const table = $anchorCell.node(-1);\r\n    const map = TableMap.get(table);\r\n    const tableStart = $anchorCell.start(-1);\r\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\r\n    const headRect = map.findCell($headCell.pos - tableStart);\r\n    const doc = $anchorCell.node(0);\r\n    if (anchorRect.top <= headRect.top) {\r\n      if (anchorRect.top > 0)\r\n        $anchorCell = doc.resolve(tableStart + map.map[anchorRect.left]);\r\n      if (headRect.bottom < map.height)\r\n        $headCell = doc.resolve(\r\n          tableStart + map.map[map.width * (map.height - 1) + headRect.right - 1]\r\n        );\r\n    } else {\r\n      if (headRect.top > 0)\r\n        $headCell = doc.resolve(tableStart + map.map[headRect.left]);\r\n      if (anchorRect.bottom < map.height)\r\n        $anchorCell = doc.resolve(\r\n          tableStart + map.map[map.width * (map.height - 1) + anchorRect.right - 1]\r\n        );\r\n    }\r\n    return new _CellSelection($anchorCell, $headCell);\r\n  }\r\n  // True if this selection goes all the way from the left to the\r\n  // right of the table.\r\n  isRowSelection() {\r\n    const table = this.$anchorCell.node(-1);\r\n    const map = TableMap.get(table);\r\n    const tableStart = this.$anchorCell.start(-1);\r\n    const anchorLeft = map.colCount(this.$anchorCell.pos - tableStart);\r\n    const headLeft = map.colCount(this.$headCell.pos - tableStart);\r\n    if (Math.min(anchorLeft, headLeft) > 0)\r\n      return false;\r\n    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;\r\n    const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;\r\n    return Math.max(anchorRight, headRight) == map.width;\r\n  }\r\n  eq(other) {\r\n    return other instanceof _CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;\r\n  }\r\n  // Returns the smallest row selection that covers the given anchor\r\n  // and head cell.\r\n  static rowSelection($anchorCell, $headCell = $anchorCell) {\r\n    const table = $anchorCell.node(-1);\r\n    const map = TableMap.get(table);\r\n    const tableStart = $anchorCell.start(-1);\r\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\r\n    const headRect = map.findCell($headCell.pos - tableStart);\r\n    const doc = $anchorCell.node(0);\r\n    if (anchorRect.left <= headRect.left) {\r\n      if (anchorRect.left > 0)\r\n        $anchorCell = doc.resolve(\r\n          tableStart + map.map[anchorRect.top * map.width]\r\n        );\r\n      if (headRect.right < map.width)\r\n        $headCell = doc.resolve(\r\n          tableStart + map.map[map.width * (headRect.top + 1) - 1]\r\n        );\r\n    } else {\r\n      if (headRect.left > 0)\r\n        $headCell = doc.resolve(tableStart + map.map[headRect.top * map.width]);\r\n      if (anchorRect.right < map.width)\r\n        $anchorCell = doc.resolve(\r\n          tableStart + map.map[map.width * (anchorRect.top + 1) - 1]\r\n        );\r\n    }\r\n    return new _CellSelection($anchorCell, $headCell);\r\n  }\r\n  toJSON() {\r\n    return {\r\n      type: \"cell\",\r\n      anchor: this.$anchorCell.pos,\r\n      head: this.$headCell.pos\r\n    };\r\n  }\r\n  static fromJSON(doc, json) {\r\n    return new _CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\r\n  }\r\n  static create(doc, anchorCell, headCell = anchorCell) {\r\n    return new _CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\r\n  }\r\n  getBookmark() {\r\n    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\r\n  }\r\n};\r\nCellSelection.prototype.visible = false;\r\nSelection.jsonID(\"cell\", CellSelection);\r\nvar CellBookmark = class _CellBookmark {\r\n  constructor(anchor, head) {\r\n    this.anchor = anchor;\r\n    this.head = head;\r\n  }\r\n  map(mapping) {\r\n    return new _CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\r\n  }\r\n  resolve(doc) {\r\n    const $anchorCell = doc.resolve(this.anchor), $headCell = doc.resolve(this.head);\r\n    if ($anchorCell.parent.type.spec.tableRole == \"row\" && $headCell.parent.type.spec.tableRole == \"row\" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell))\r\n      return new CellSelection($anchorCell, $headCell);\r\n    else\r\n      return Selection.near($headCell, 1);\r\n  }\r\n};\r\nfunction drawCellSelection(state) {\r\n  if (!(state.selection instanceof CellSelection))\r\n    return null;\r\n  const cells = [];\r\n  state.selection.forEachCell((node, pos) => {\r\n    cells.push(\r\n      Decoration.node(pos, pos + node.nodeSize, { class: \"selectedCell\" })\r\n    );\r\n  });\r\n  return DecorationSet.create(state.doc, cells);\r\n}\r\nfunction isCellBoundarySelection({ $from, $to }) {\r\n  if ($from.pos == $to.pos || $from.pos < $to.pos - 6)\r\n    return false;\r\n  let afterFrom = $from.pos;\r\n  let beforeTo = $to.pos;\r\n  let depth = $from.depth;\r\n  for (; depth >= 0; depth--, afterFrom++)\r\n    if ($from.after(depth + 1) < $from.end(depth))\r\n      break;\r\n  for (let d = $to.depth; d >= 0; d--, beforeTo--)\r\n    if ($to.before(d + 1) > $to.start(d))\r\n      break;\r\n  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);\r\n}\r\nfunction isTextSelectionAcrossCells({ $from, $to }) {\r\n  let fromCellBoundaryNode;\r\n  let toCellBoundaryNode;\r\n  for (let i = $from.depth; i > 0; i--) {\r\n    const node = $from.node(i);\r\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\r\n      fromCellBoundaryNode = node;\r\n      break;\r\n    }\r\n  }\r\n  for (let i = $to.depth; i > 0; i--) {\r\n    const node = $to.node(i);\r\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\r\n      toCellBoundaryNode = node;\r\n      break;\r\n    }\r\n  }\r\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\r\n}\r\nfunction normalizeSelection(state, tr, allowTableNodeSelection) {\r\n  const sel = (tr || state).selection;\r\n  const doc = (tr || state).doc;\r\n  let normalize;\r\n  let role;\r\n  if (sel instanceof NodeSelection2 && (role = sel.node.type.spec.tableRole)) {\r\n    if (role == \"cell\" || role == \"header_cell\") {\r\n      normalize = CellSelection.create(doc, sel.from);\r\n    } else if (role == \"row\") {\r\n      const $cell = doc.resolve(sel.from + 1);\r\n      normalize = CellSelection.rowSelection($cell, $cell);\r\n    } else if (!allowTableNodeSelection) {\r\n      const map = TableMap.get(sel.node);\r\n      const start = sel.from + 1;\r\n      const lastCell = start + map.map[map.width * map.height - 1];\r\n      normalize = CellSelection.create(doc, start + 1, lastCell);\r\n    }\r\n  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {\r\n    normalize = TextSelection.create(doc, sel.from);\r\n  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {\r\n    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());\r\n  }\r\n  if (normalize)\r\n    (tr || (tr = state.tr)).setSelection(normalize);\r\n  return tr;\r\n}\r\n\r\n// src/fixtables.ts\r\nimport { PluginKey as PluginKey2 } from \"prosemirror-state\";\r\nvar fixTablesKey = new PluginKey2(\"fix-tables\");\r\nfunction changedDescendants(old, cur, offset, f) {\r\n  const oldSize = old.childCount, curSize = cur.childCount;\r\n  outer:\r\n    for (let i = 0, j = 0; i < curSize; i++) {\r\n      const child = cur.child(i);\r\n      for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\r\n        if (old.child(scan) == child) {\r\n          j = scan + 1;\r\n          offset += child.nodeSize;\r\n          continue outer;\r\n        }\r\n      }\r\n      f(child, offset);\r\n      if (j < oldSize && old.child(j).sameMarkup(child))\r\n        changedDescendants(old.child(j), child, offset + 1, f);\r\n      else\r\n        child.nodesBetween(0, child.content.size, f, offset + 1);\r\n      offset += child.nodeSize;\r\n    }\r\n}\r\nfunction fixTables(state, oldState) {\r\n  let tr;\r\n  const check = (node, pos) => {\r\n    if (node.type.spec.tableRole == \"table\")\r\n      tr = fixTable(state, node, pos, tr);\r\n  };\r\n  if (!oldState)\r\n    state.doc.descendants(check);\r\n  else if (oldState.doc != state.doc)\r\n    changedDescendants(oldState.doc, state.doc, 0, check);\r\n  return tr;\r\n}\r\nfunction fixTable(state, table, tablePos, tr) {\r\n  const map = TableMap.get(table);\r\n  if (!map.problems)\r\n    return tr;\r\n  if (!tr)\r\n    tr = state.tr;\r\n  const mustAdd = [];\r\n  for (let i = 0; i < map.height; i++)\r\n    mustAdd.push(0);\r\n  for (let i = 0; i < map.problems.length; i++) {\r\n    const prob = map.problems[i];\r\n    if (prob.type == \"collision\") {\r\n      const cell = table.nodeAt(prob.pos);\r\n      if (!cell)\r\n        continue;\r\n      const attrs = cell.attrs;\r\n      for (let j = 0; j < attrs.rowspan; j++)\r\n        mustAdd[prob.row + j] += prob.n;\r\n      tr.setNodeMarkup(\r\n        tr.mapping.map(tablePos + 1 + prob.pos),\r\n        null,\r\n        removeColSpan(attrs, attrs.colspan - prob.n, prob.n)\r\n      );\r\n    } else if (prob.type == \"missing\") {\r\n      mustAdd[prob.row] += prob.n;\r\n    } else if (prob.type == \"overlong_rowspan\") {\r\n      const cell = table.nodeAt(prob.pos);\r\n      if (!cell)\r\n        continue;\r\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\r\n        ...cell.attrs,\r\n        rowspan: cell.attrs.rowspan - prob.n\r\n      });\r\n    } else if (prob.type == \"colwidth mismatch\") {\r\n      const cell = table.nodeAt(prob.pos);\r\n      if (!cell)\r\n        continue;\r\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\r\n        ...cell.attrs,\r\n        colwidth: prob.colwidth\r\n      });\r\n    }\r\n  }\r\n  let first, last;\r\n  for (let i = 0; i < mustAdd.length; i++)\r\n    if (mustAdd[i]) {\r\n      if (first == null)\r\n        first = i;\r\n      last = i;\r\n    }\r\n  for (let i = 0, pos = tablePos + 1; i < map.height; i++) {\r\n    const row = table.child(i);\r\n    const end = pos + row.nodeSize;\r\n    const add = mustAdd[i];\r\n    if (add > 0) {\r\n      let role = \"cell\";\r\n      if (row.firstChild) {\r\n        role = row.firstChild.type.spec.tableRole;\r\n      }\r\n      const nodes = [];\r\n      for (let j = 0; j < add; j++) {\r\n        const node = tableNodeTypes(state.schema)[role].createAndFill();\r\n        if (node)\r\n          nodes.push(node);\r\n      }\r\n      const side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;\r\n      tr.insert(tr.mapping.map(side), nodes);\r\n    }\r\n    pos = end;\r\n  }\r\n  return tr.setMeta(fixTablesKey, { fixTables: true });\r\n}\r\n\r\n// src/input.ts\r\nimport { keydownHandler } from \"prosemirror-keymap\";\r\nimport { Fragment as Fragment4 } from \"prosemirror-model\";\r\nimport {\r\n  Selection as Selection2,\r\n  TextSelection as TextSelection3\r\n} from \"prosemirror-state\";\r\n\r\n// src/commands.ts\r\nimport {\r\n  Fragment as Fragment2,\r\n  Slice as Slice2\r\n} from \"prosemirror-model\";\r\nimport {\r\n  TextSelection as TextSelection2\r\n} from \"prosemirror-state\";\r\nfunction selectedRect(state) {\r\n  const sel = state.selection;\r\n  const $pos = selectionCell(state);\r\n  const table = $pos.node(-1);\r\n  const tableStart = $pos.start(-1);\r\n  const map = TableMap.get(table);\r\n  const rect = sel instanceof CellSelection ? map.rectBetween(\r\n    sel.$anchorCell.pos - tableStart,\r\n    sel.$headCell.pos - tableStart\r\n  ) : map.findCell($pos.pos - tableStart);\r\n  return { ...rect, tableStart, map, table };\r\n}\r\nfunction addColumn(tr, { map, tableStart, table }, col) {\r\n  let refColumn = col > 0 ? -1 : 0;\r\n  if (columnIsHeader(map, table, col + refColumn)) {\r\n    refColumn = col == 0 || col == map.width ? null : 0;\r\n  }\r\n  for (let row = 0; row < map.height; row++) {\r\n    const index = row * map.width + col;\r\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\r\n      const pos = map.map[index];\r\n      const cell = table.nodeAt(pos);\r\n      tr.setNodeMarkup(\r\n        tr.mapping.map(tableStart + pos),\r\n        null,\r\n        addColSpan(cell.attrs, col - map.colCount(pos))\r\n      );\r\n      row += cell.attrs.rowspan - 1;\r\n    } else {\r\n      const type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refColumn]).type;\r\n      const pos = map.positionAt(row, col, table);\r\n      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());\r\n    }\r\n  }\r\n  return tr;\r\n}\r\nfunction addColumnBefore(state, dispatch) {\r\n  if (!isInTable(state))\r\n    return false;\r\n  if (dispatch) {\r\n    const rect = selectedRect(state);\r\n    dispatch(addColumn(state.tr, rect, rect.left));\r\n  }\r\n  return true;\r\n}\r\nfunction addColumnAfter(state, dispatch) {\r\n  if (!isInTable(state))\r\n    return false;\r\n  if (dispatch) {\r\n    const rect = selectedRect(state);\r\n    dispatch(addColumn(state.tr, rect, rect.right));\r\n  }\r\n  return true;\r\n}\r\nfunction removeColumn(tr, { map, table, tableStart }, col) {\r\n  const mapStart = tr.mapping.maps.length;\r\n  for (let row = 0; row < map.height; ) {\r\n    const index = row * map.width + col;\r\n    const pos = map.map[index];\r\n    const cell = table.nodeAt(pos);\r\n    const attrs = cell.attrs;\r\n    if (col > 0 && map.map[index - 1] == pos || col < map.width - 1 && map.map[index + 1] == pos) {\r\n      tr.setNodeMarkup(\r\n        tr.mapping.slice(mapStart).map(tableStart + pos),\r\n        null,\r\n        removeColSpan(attrs, col - map.colCount(pos))\r\n      );\r\n    } else {\r\n      const start = tr.mapping.slice(mapStart).map(tableStart + pos);\r\n      tr.delete(start, start + cell.nodeSize);\r\n    }\r\n    row += attrs.rowspan;\r\n  }\r\n}\r\nfunction deleteColumn(state, dispatch) {\r\n  if (!isInTable(state))\r\n    return false;\r\n  if (dispatch) {\r\n    const rect = selectedRect(state);\r\n    const tr = state.tr;\r\n    if (rect.left == 0 && rect.right == rect.map.width)\r\n      return false;\r\n    for (let i = rect.right - 1; ; i--) {\r\n      removeColumn(tr, rect, i);\r\n      if (i == rect.left)\r\n        break;\r\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\r\n      if (!table) {\r\n        throw RangeError(\"No table found\");\r\n      }\r\n      rect.table = table;\r\n      rect.map = TableMap.get(table);\r\n    }\r\n    dispatch(tr);\r\n  }\r\n  return true;\r\n}\r\nfunction rowIsHeader(map, table, row) {\r\n  var _a;\r\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\r\n  for (let col = 0; col < map.width; col++)\r\n    if (((_a = table.nodeAt(map.map[col + row * map.width])) == null ? void 0 : _a.type) != headerCell)\r\n      return false;\r\n  return true;\r\n}\r\nfunction addRow(tr, { map, tableStart, table }, row) {\r\n  var _a;\r\n  let rowPos = tableStart;\r\n  for (let i = 0; i < row; i++)\r\n    rowPos += table.child(i).nodeSize;\r\n  const cells = [];\r\n  let refRow = row > 0 ? -1 : 0;\r\n  if (rowIsHeader(map, table, row + refRow))\r\n    refRow = row == 0 || row == map.height ? null : 0;\r\n  for (let col = 0, index = map.width * row; col < map.width; col++, index++) {\r\n    if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\r\n      const pos = map.map[index];\r\n      const attrs = table.nodeAt(pos).attrs;\r\n      tr.setNodeMarkup(tableStart + pos, null, {\r\n        ...attrs,\r\n        rowspan: attrs.rowspan + 1\r\n      });\r\n      col += attrs.colspan - 1;\r\n    } else {\r\n      const type = refRow == null ? tableNodeTypes(table.type.schema).cell : (_a = table.nodeAt(map.map[index + refRow * map.width])) == null ? void 0 : _a.type;\r\n      const node = type == null ? void 0 : type.createAndFill();\r\n      if (node)\r\n        cells.push(node);\r\n    }\r\n  }\r\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\r\n  return tr;\r\n}\r\nfunction addRowBefore(state, dispatch) {\r\n  if (!isInTable(state))\r\n    return false;\r\n  if (dispatch) {\r\n    const rect = selectedRect(state);\r\n    dispatch(addRow(state.tr, rect, rect.top));\r\n  }\r\n  return true;\r\n}\r\nfunction addRowAfter(state, dispatch) {\r\n  if (!isInTable(state))\r\n    return false;\r\n  if (dispatch) {\r\n    const rect = selectedRect(state);\r\n    dispatch(addRow(state.tr, rect, rect.bottom));\r\n  }\r\n  return true;\r\n}\r\nfunction removeRow(tr, { map, table, tableStart }, row) {\r\n  let rowPos = 0;\r\n  for (let i = 0; i < row; i++)\r\n    rowPos += table.child(i).nodeSize;\r\n  const nextRow = rowPos + table.child(row).nodeSize;\r\n  const mapFrom = tr.mapping.maps.length;\r\n  tr.delete(rowPos + tableStart, nextRow + tableStart);\r\n  const seen = /* @__PURE__ */ new Set();\r\n  for (let col = 0, index = row * map.width; col < map.width; col++, index++) {\r\n    const pos = map.map[index];\r\n    if (seen.has(pos))\r\n      continue;\r\n    seen.add(pos);\r\n    if (row > 0 && pos == map.map[index - map.width]) {\r\n      const attrs = table.nodeAt(pos).attrs;\r\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, {\r\n        ...attrs,\r\n        rowspan: attrs.rowspan - 1\r\n      });\r\n      col += attrs.colspan - 1;\r\n    } else if (row < map.height && pos == map.map[index + map.width]) {\r\n      const cell = table.nodeAt(pos);\r\n      const attrs = cell.attrs;\r\n      const copy = cell.type.create(\r\n        { ...attrs, rowspan: cell.attrs.rowspan - 1 },\r\n        cell.content\r\n      );\r\n      const newPos = map.positionAt(row + 1, col, table);\r\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\r\n      col += attrs.colspan - 1;\r\n    }\r\n  }\r\n}\r\nfunction deleteRow(state, dispatch) {\r\n  if (!isInTable(state))\r\n    return false;\r\n  if (dispatch) {\r\n    const rect = selectedRect(state), tr = state.tr;\r\n    if (rect.top == 0 && rect.bottom == rect.map.height)\r\n      return false;\r\n    for (let i = rect.bottom - 1; ; i--) {\r\n      removeRow(tr, rect, i);\r\n      if (i == rect.top)\r\n        break;\r\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\r\n      if (!table) {\r\n        throw RangeError(\"No table found\");\r\n      }\r\n      rect.table = table;\r\n      rect.map = TableMap.get(rect.table);\r\n    }\r\n    dispatch(tr);\r\n  }\r\n  return true;\r\n}\r\nfunction isEmpty(cell) {\r\n  const c = cell.content;\r\n  return c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0;\r\n}\r\nfunction cellsOverlapRectangle({ width, height, map }, rect) {\r\n  let indexTop = rect.top * width + rect.left, indexLeft = indexTop;\r\n  let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);\r\n  for (let i = rect.top; i < rect.bottom; i++) {\r\n    if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] || rect.right < width && map[indexRight] == map[indexRight + 1])\r\n      return true;\r\n    indexLeft += width;\r\n    indexRight += width;\r\n  }\r\n  for (let i = rect.left; i < rect.right; i++) {\r\n    if (rect.top > 0 && map[indexTop] == map[indexTop - width] || rect.bottom < height && map[indexBottom] == map[indexBottom + width])\r\n      return true;\r\n    indexTop++;\r\n    indexBottom++;\r\n  }\r\n  return false;\r\n}\r\nfunction mergeCells(state, dispatch) {\r\n  const sel = state.selection;\r\n  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos)\r\n    return false;\r\n  const rect = selectedRect(state), { map } = rect;\r\n  if (cellsOverlapRectangle(map, rect))\r\n    return false;\r\n  if (dispatch) {\r\n    const tr = state.tr;\r\n    const seen = {};\r\n    let content = Fragment2.empty;\r\n    let mergedPos;\r\n    let mergedCell;\r\n    for (let row = rect.top; row < rect.bottom; row++) {\r\n      for (let col = rect.left; col < rect.right; col++) {\r\n        const cellPos = map.map[row * map.width + col];\r\n        const cell = rect.table.nodeAt(cellPos);\r\n        if (seen[cellPos] || !cell)\r\n          continue;\r\n        seen[cellPos] = true;\r\n        if (mergedPos == null) {\r\n          mergedPos = cellPos;\r\n          mergedCell = cell;\r\n        } else {\r\n          if (!isEmpty(cell))\r\n            content = content.append(cell.content);\r\n          const mapped = tr.mapping.map(cellPos + rect.tableStart);\r\n          tr.delete(mapped, mapped + cell.nodeSize);\r\n        }\r\n      }\r\n    }\r\n    if (mergedPos == null || mergedCell == null) {\r\n      return true;\r\n    }\r\n    tr.setNodeMarkup(mergedPos + rect.tableStart, null, {\r\n      ...addColSpan(\r\n        mergedCell.attrs,\r\n        mergedCell.attrs.colspan,\r\n        rect.right - rect.left - mergedCell.attrs.colspan\r\n      ),\r\n      rowspan: rect.bottom - rect.top\r\n    });\r\n    if (content.size) {\r\n      const end = mergedPos + 1 + mergedCell.content.size;\r\n      const start = isEmpty(mergedCell) ? mergedPos + 1 : end;\r\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\r\n    }\r\n    tr.setSelection(\r\n      new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart))\r\n    );\r\n    dispatch(tr);\r\n  }\r\n  return true;\r\n}\r\nfunction splitCell(state, dispatch) {\r\n  const nodeTypes = tableNodeTypes(state.schema);\r\n  return splitCellWithType(({ node }) => {\r\n    return nodeTypes[node.type.spec.tableRole];\r\n  })(state, dispatch);\r\n}\r\nfunction splitCellWithType(getCellType) {\r\n  return (state, dispatch) => {\r\n    var _a;\r\n    const sel = state.selection;\r\n    let cellNode;\r\n    let cellPos;\r\n    if (!(sel instanceof CellSelection)) {\r\n      cellNode = cellWrapping(sel.$from);\r\n      if (!cellNode)\r\n        return false;\r\n      cellPos = (_a = cellAround(sel.$from)) == null ? void 0 : _a.pos;\r\n    } else {\r\n      if (sel.$anchorCell.pos != sel.$headCell.pos)\r\n        return false;\r\n      cellNode = sel.$anchorCell.nodeAfter;\r\n      cellPos = sel.$anchorCell.pos;\r\n    }\r\n    if (cellNode == null || cellPos == null) {\r\n      return false;\r\n    }\r\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {\r\n      return false;\r\n    }\r\n    if (dispatch) {\r\n      let baseAttrs = cellNode.attrs;\r\n      const attrs = [];\r\n      const colwidth = baseAttrs.colwidth;\r\n      if (baseAttrs.rowspan > 1)\r\n        baseAttrs = { ...baseAttrs, rowspan: 1 };\r\n      if (baseAttrs.colspan > 1)\r\n        baseAttrs = { ...baseAttrs, colspan: 1 };\r\n      const rect = selectedRect(state), tr = state.tr;\r\n      for (let i = 0; i < rect.right - rect.left; i++)\r\n        attrs.push(\r\n          colwidth ? {\r\n            ...baseAttrs,\r\n            colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null\r\n          } : baseAttrs\r\n        );\r\n      let lastCell;\r\n      for (let row = rect.top; row < rect.bottom; row++) {\r\n        let pos = rect.map.positionAt(row, rect.left, rect.table);\r\n        if (row == rect.top)\r\n          pos += cellNode.nodeSize;\r\n        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {\r\n          if (col == rect.left && row == rect.top)\r\n            continue;\r\n          tr.insert(\r\n            lastCell = tr.mapping.map(pos + rect.tableStart, 1),\r\n            getCellType({ node: cellNode, row, col }).createAndFill(attrs[i])\r\n          );\r\n        }\r\n      }\r\n      tr.setNodeMarkup(\r\n        cellPos,\r\n        getCellType({ node: cellNode, row: rect.top, col: rect.left }),\r\n        attrs[0]\r\n      );\r\n      if (sel instanceof CellSelection)\r\n        tr.setSelection(\r\n          new CellSelection(\r\n            tr.doc.resolve(sel.$anchorCell.pos),\r\n            lastCell ? tr.doc.resolve(lastCell) : void 0\r\n          )\r\n        );\r\n      dispatch(tr);\r\n    }\r\n    return true;\r\n  };\r\n}\r\nfunction setCellAttr(name, value) {\r\n  return function(state, dispatch) {\r\n    if (!isInTable(state))\r\n      return false;\r\n    const $cell = selectionCell(state);\r\n    if ($cell.nodeAfter.attrs[name] === value)\r\n      return false;\r\n    if (dispatch) {\r\n      const tr = state.tr;\r\n      if (state.selection instanceof CellSelection)\r\n        state.selection.forEachCell((node, pos) => {\r\n          if (node.attrs[name] !== value)\r\n            tr.setNodeMarkup(pos, null, {\r\n              ...node.attrs,\r\n              [name]: value\r\n            });\r\n        });\r\n      else\r\n        tr.setNodeMarkup($cell.pos, null, {\r\n          ...$cell.nodeAfter.attrs,\r\n          [name]: value\r\n        });\r\n      dispatch(tr);\r\n    }\r\n    return true;\r\n  };\r\n}\r\nfunction deprecated_toggleHeader(type) {\r\n  return function(state, dispatch) {\r\n    if (!isInTable(state))\r\n      return false;\r\n    if (dispatch) {\r\n      const types = tableNodeTypes(state.schema);\r\n      const rect = selectedRect(state), tr = state.tr;\r\n      const cells = rect.map.cellsInRect(\r\n        type == \"column\" ? {\r\n          left: rect.left,\r\n          top: 0,\r\n          right: rect.right,\r\n          bottom: rect.map.height\r\n        } : type == \"row\" ? {\r\n          left: 0,\r\n          top: rect.top,\r\n          right: rect.map.width,\r\n          bottom: rect.bottom\r\n        } : rect\r\n      );\r\n      const nodes = cells.map((pos) => rect.table.nodeAt(pos));\r\n      for (let i = 0; i < cells.length; i++)\r\n        if (nodes[i].type == types.header_cell)\r\n          tr.setNodeMarkup(\r\n            rect.tableStart + cells[i],\r\n            types.cell,\r\n            nodes[i].attrs\r\n          );\r\n      if (tr.steps.length == 0)\r\n        for (let i = 0; i < cells.length; i++)\r\n          tr.setNodeMarkup(\r\n            rect.tableStart + cells[i],\r\n            types.header_cell,\r\n            nodes[i].attrs\r\n          );\r\n      dispatch(tr);\r\n    }\r\n    return true;\r\n  };\r\n}\r\nfunction isHeaderEnabledByType(type, rect, types) {\r\n  const cellPositions = rect.map.cellsInRect({\r\n    left: 0,\r\n    top: 0,\r\n    right: type == \"row\" ? rect.map.width : 1,\r\n    bottom: type == \"column\" ? rect.map.height : 1\r\n  });\r\n  for (let i = 0; i < cellPositions.length; i++) {\r\n    const cell = rect.table.nodeAt(cellPositions[i]);\r\n    if (cell && cell.type !== types.header_cell) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\nfunction toggleHeader(type, options) {\r\n  options = options || { useDeprecatedLogic: false };\r\n  if (options.useDeprecatedLogic)\r\n    return deprecated_toggleHeader(type);\r\n  return function(state, dispatch) {\r\n    if (!isInTable(state))\r\n      return false;\r\n    if (dispatch) {\r\n      const types = tableNodeTypes(state.schema);\r\n      const rect = selectedRect(state), tr = state.tr;\r\n      const isHeaderRowEnabled = isHeaderEnabledByType(\"row\", rect, types);\r\n      const isHeaderColumnEnabled = isHeaderEnabledByType(\r\n        \"column\",\r\n        rect,\r\n        types\r\n      );\r\n      const isHeaderEnabled = type === \"column\" ? isHeaderRowEnabled : type === \"row\" ? isHeaderColumnEnabled : false;\r\n      const selectionStartsAt = isHeaderEnabled ? 1 : 0;\r\n      const cellsRect = type == \"column\" ? {\r\n        left: 0,\r\n        top: selectionStartsAt,\r\n        right: 1,\r\n        bottom: rect.map.height\r\n      } : type == \"row\" ? {\r\n        left: selectionStartsAt,\r\n        top: 0,\r\n        right: rect.map.width,\r\n        bottom: 1\r\n      } : rect;\r\n      const newType = type == \"column\" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == \"row\" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;\r\n      rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {\r\n        const cellPos = relativeCellPos + rect.tableStart;\r\n        const cell = tr.doc.nodeAt(cellPos);\r\n        if (cell) {\r\n          tr.setNodeMarkup(cellPos, newType, cell.attrs);\r\n        }\r\n      });\r\n      dispatch(tr);\r\n    }\r\n    return true;\r\n  };\r\n}\r\nvar toggleHeaderRow = toggleHeader(\"row\", {\r\n  useDeprecatedLogic: true\r\n});\r\nvar toggleHeaderColumn = toggleHeader(\"column\", {\r\n  useDeprecatedLogic: true\r\n});\r\nvar toggleHeaderCell = toggleHeader(\"cell\", {\r\n  useDeprecatedLogic: true\r\n});\r\nfunction findNextCell($cell, dir) {\r\n  if (dir < 0) {\r\n    const before = $cell.nodeBefore;\r\n    if (before)\r\n      return $cell.pos - before.nodeSize;\r\n    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {\r\n      const rowNode = $cell.node(-1).child(row);\r\n      const lastChild = rowNode.lastChild;\r\n      if (lastChild) {\r\n        return rowEnd - 1 - lastChild.nodeSize;\r\n      }\r\n      rowEnd -= rowNode.nodeSize;\r\n    }\r\n  } else {\r\n    if ($cell.index() < $cell.parent.childCount - 1) {\r\n      return $cell.pos + $cell.nodeAfter.nodeSize;\r\n    }\r\n    const table = $cell.node(-1);\r\n    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {\r\n      const rowNode = table.child(row);\r\n      if (rowNode.childCount)\r\n        return rowStart + 1;\r\n      rowStart += rowNode.nodeSize;\r\n    }\r\n  }\r\n  return null;\r\n}\r\nfunction goToNextCell(direction) {\r\n  return function(state, dispatch) {\r\n    if (!isInTable(state))\r\n      return false;\r\n    const cell = findNextCell(selectionCell(state), direction);\r\n    if (cell == null)\r\n      return false;\r\n    if (dispatch) {\r\n      const $cell = state.doc.resolve(cell);\r\n      dispatch(\r\n        state.tr.setSelection(TextSelection2.between($cell, moveCellForward($cell))).scrollIntoView()\r\n      );\r\n    }\r\n    return true;\r\n  };\r\n}\r\nfunction deleteTable(state, dispatch) {\r\n  const $pos = state.selection.$anchor;\r\n  for (let d = $pos.depth; d > 0; d--) {\r\n    const node = $pos.node(d);\r\n    if (node.type.spec.tableRole == \"table\") {\r\n      if (dispatch)\r\n        dispatch(\r\n          state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView()\r\n        );\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\nfunction deleteCellSelection(state, dispatch) {\r\n  const sel = state.selection;\r\n  if (!(sel instanceof CellSelection))\r\n    return false;\r\n  if (dispatch) {\r\n    const tr = state.tr;\r\n    const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\r\n    sel.forEachCell((cell, pos) => {\r\n      if (!cell.content.eq(baseContent))\r\n        tr.replace(\r\n          tr.mapping.map(pos + 1),\r\n          tr.mapping.map(pos + cell.nodeSize - 1),\r\n          new Slice2(baseContent, 0, 0)\r\n        );\r\n    });\r\n    if (tr.docChanged)\r\n      dispatch(tr);\r\n  }\r\n  return true;\r\n}\r\n\r\n// src/copypaste.ts\r\nimport { Fragment as Fragment3, Slice as Slice3 } from \"prosemirror-model\";\r\nimport { Transform } from \"prosemirror-transform\";\r\nfunction pastedCells(slice) {\r\n  if (!slice.size)\r\n    return null;\r\n  let { content, openStart, openEnd } = slice;\r\n  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.child(0).type.spec.tableRole == \"table\")) {\r\n    openStart--;\r\n    openEnd--;\r\n    content = content.child(0).content;\r\n  }\r\n  const first = content.child(0);\r\n  const role = first.type.spec.tableRole;\r\n  const schema = first.type.schema, rows = [];\r\n  if (role == \"row\") {\r\n    for (let i = 0; i < content.childCount; i++) {\r\n      let cells = content.child(i).content;\r\n      const left = i ? 0 : Math.max(0, openStart - 1);\r\n      const right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\r\n      if (left || right)\r\n        cells = fitSlice(\r\n          tableNodeTypes(schema).row,\r\n          new Slice3(cells, left, right)\r\n        ).content;\r\n      rows.push(cells);\r\n    }\r\n  } else if (role == \"cell\" || role == \"header_cell\") {\r\n    rows.push(\r\n      openStart || openEnd ? fitSlice(\r\n        tableNodeTypes(schema).row,\r\n        new Slice3(content, openStart, openEnd)\r\n      ).content : content\r\n    );\r\n  } else {\r\n    return null;\r\n  }\r\n  return ensureRectangular(schema, rows);\r\n}\r\nfunction ensureRectangular(schema, rows) {\r\n  const widths = [];\r\n  for (let i = 0; i < rows.length; i++) {\r\n    const row = rows[i];\r\n    for (let j = row.childCount - 1; j >= 0; j--) {\r\n      const { rowspan, colspan } = row.child(j).attrs;\r\n      for (let r = i; r < i + rowspan; r++)\r\n        widths[r] = (widths[r] || 0) + colspan;\r\n    }\r\n  }\r\n  let width = 0;\r\n  for (let r = 0; r < widths.length; r++)\r\n    width = Math.max(width, widths[r]);\r\n  for (let r = 0; r < widths.length; r++) {\r\n    if (r >= rows.length)\r\n      rows.push(Fragment3.empty);\r\n    if (widths[r] < width) {\r\n      const empty = tableNodeTypes(schema).cell.createAndFill();\r\n      const cells = [];\r\n      for (let i = widths[r]; i < width; i++) {\r\n        cells.push(empty);\r\n      }\r\n      rows[r] = rows[r].append(Fragment3.from(cells));\r\n    }\r\n  }\r\n  return { height: rows.length, width, rows };\r\n}\r\nfunction fitSlice(nodeType, slice) {\r\n  const node = nodeType.createAndFill();\r\n  const tr = new Transform(node).replace(0, node.content.size, slice);\r\n  return tr.doc;\r\n}\r\nfunction clipCells({ width, height, rows }, newWidth, newHeight) {\r\n  if (width != newWidth) {\r\n    const added = [];\r\n    const newRows = [];\r\n    for (let row = 0; row < rows.length; row++) {\r\n      const frag = rows[row], cells = [];\r\n      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {\r\n        let cell = frag.child(i % frag.childCount);\r\n        if (col + cell.attrs.colspan > newWidth)\r\n          cell = cell.type.createChecked(\r\n            removeColSpan(\r\n              cell.attrs,\r\n              cell.attrs.colspan,\r\n              col + cell.attrs.colspan - newWidth\r\n            ),\r\n            cell.content\r\n          );\r\n        cells.push(cell);\r\n        col += cell.attrs.colspan;\r\n        for (let j = 1; j < cell.attrs.rowspan; j++)\r\n          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;\r\n      }\r\n      newRows.push(Fragment3.from(cells));\r\n    }\r\n    rows = newRows;\r\n    width = newWidth;\r\n  }\r\n  if (height != newHeight) {\r\n    const newRows = [];\r\n    for (let row = 0, i = 0; row < newHeight; row++, i++) {\r\n      const cells = [], source = rows[i % height];\r\n      for (let j = 0; j < source.childCount; j++) {\r\n        let cell = source.child(j);\r\n        if (row + cell.attrs.rowspan > newHeight)\r\n          cell = cell.type.create(\r\n            {\r\n              ...cell.attrs,\r\n              rowspan: Math.max(1, newHeight - cell.attrs.rowspan)\r\n            },\r\n            cell.content\r\n          );\r\n        cells.push(cell);\r\n      }\r\n      newRows.push(Fragment3.from(cells));\r\n    }\r\n    rows = newRows;\r\n    height = newHeight;\r\n  }\r\n  return { width, height, rows };\r\n}\r\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\r\n  const schema = tr.doc.type.schema;\r\n  const types = tableNodeTypes(schema);\r\n  let empty;\r\n  let emptyHead;\r\n  if (width > map.width) {\r\n    for (let row = 0, rowEnd = 0; row < map.height; row++) {\r\n      const rowNode = table.child(row);\r\n      rowEnd += rowNode.nodeSize;\r\n      const cells = [];\r\n      let add;\r\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)\r\n        add = empty || (empty = types.cell.createAndFill());\r\n      else\r\n        add = emptyHead || (emptyHead = types.header_cell.createAndFill());\r\n      for (let i = map.width; i < width; i++)\r\n        cells.push(add);\r\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\r\n    }\r\n  }\r\n  if (height > map.height) {\r\n    const cells = [];\r\n    for (let i = 0, start2 = (map.height - 1) * map.width; i < Math.max(map.width, width); i++) {\r\n      const header = i >= map.width ? false : table.nodeAt(map.map[start2 + i]).type == types.header_cell;\r\n      cells.push(\r\n        header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty || (empty = types.cell.createAndFill())\r\n      );\r\n    }\r\n    const emptyRow = types.row.create(null, Fragment3.from(cells)), rows = [];\r\n    for (let i = map.height; i < height; i++)\r\n      rows.push(emptyRow);\r\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\r\n  }\r\n  return !!(empty || emptyHead);\r\n}\r\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\r\n  if (top == 0 || top == map.height)\r\n    return false;\r\n  let found = false;\r\n  for (let col = left; col < right; col++) {\r\n    const index = top * map.width + col, pos = map.map[index];\r\n    if (map.map[index - map.width] == pos) {\r\n      found = true;\r\n      const cell = table.nodeAt(pos);\r\n      const { top: cellTop, left: cellLeft } = map.findCell(pos);\r\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, {\r\n        ...cell.attrs,\r\n        rowspan: top - cellTop\r\n      });\r\n      tr.insert(\r\n        tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)),\r\n        cell.type.createAndFill({\r\n          ...cell.attrs,\r\n          rowspan: cellTop + cell.attrs.rowspan - top\r\n        })\r\n      );\r\n      col += cell.attrs.colspan - 1;\r\n    }\r\n  }\r\n  return found;\r\n}\r\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\r\n  if (left == 0 || left == map.width)\r\n    return false;\r\n  let found = false;\r\n  for (let row = top; row < bottom; row++) {\r\n    const index = row * map.width + left, pos = map.map[index];\r\n    if (map.map[index - 1] == pos) {\r\n      found = true;\r\n      const cell = table.nodeAt(pos);\r\n      const cellLeft = map.colCount(pos);\r\n      const updatePos = tr.mapping.slice(mapFrom).map(pos + start);\r\n      tr.setNodeMarkup(\r\n        updatePos,\r\n        null,\r\n        removeColSpan(\r\n          cell.attrs,\r\n          left - cellLeft,\r\n          cell.attrs.colspan - (left - cellLeft)\r\n        )\r\n      );\r\n      tr.insert(\r\n        updatePos + cell.nodeSize,\r\n        cell.type.createAndFill(\r\n          removeColSpan(cell.attrs, 0, left - cellLeft)\r\n        )\r\n      );\r\n      row += cell.attrs.rowspan - 1;\r\n    }\r\n  }\r\n  return found;\r\n}\r\nfunction insertCells(state, dispatch, tableStart, rect, cells) {\r\n  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;\r\n  if (!table) {\r\n    throw new Error(\"No table found\");\r\n  }\r\n  let map = TableMap.get(table);\r\n  const { top, left } = rect;\r\n  const right = left + cells.width, bottom = top + cells.height;\r\n  const tr = state.tr;\r\n  let mapFrom = 0;\r\n  function recomp() {\r\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\r\n    if (!table) {\r\n      throw new Error(\"No table found\");\r\n    }\r\n    map = TableMap.get(table);\r\n    mapFrom = tr.mapping.maps.length;\r\n  }\r\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom))\r\n    recomp();\r\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom))\r\n    recomp();\r\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom))\r\n    recomp();\r\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom))\r\n    recomp();\r\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom))\r\n    recomp();\r\n  for (let row = top; row < bottom; row++) {\r\n    const from = map.positionAt(row, left, table), to = map.positionAt(row, right, table);\r\n    tr.replace(\r\n      tr.mapping.slice(mapFrom).map(from + tableStart),\r\n      tr.mapping.slice(mapFrom).map(to + tableStart),\r\n      new Slice3(cells.rows[row - top], 0, 0)\r\n    );\r\n  }\r\n  recomp();\r\n  tr.setSelection(\r\n    new CellSelection(\r\n      tr.doc.resolve(tableStart + map.positionAt(top, left, table)),\r\n      tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))\r\n    )\r\n  );\r\n  dispatch(tr);\r\n}\r\n\r\n// src/input.ts\r\nvar handleKeyDown = keydownHandler({\r\n  ArrowLeft: arrow(\"horiz\", -1),\r\n  ArrowRight: arrow(\"horiz\", 1),\r\n  ArrowUp: arrow(\"vert\", -1),\r\n  ArrowDown: arrow(\"vert\", 1),\r\n  \"Shift-ArrowLeft\": shiftArrow(\"horiz\", -1),\r\n  \"Shift-ArrowRight\": shiftArrow(\"horiz\", 1),\r\n  \"Shift-ArrowUp\": shiftArrow(\"vert\", -1),\r\n  \"Shift-ArrowDown\": shiftArrow(\"vert\", 1),\r\n  Backspace: deleteCellSelection,\r\n  \"Mod-Backspace\": deleteCellSelection,\r\n  Delete: deleteCellSelection,\r\n  \"Mod-Delete\": deleteCellSelection\r\n});\r\nfunction maybeSetSelection(state, dispatch, selection) {\r\n  if (selection.eq(state.selection))\r\n    return false;\r\n  if (dispatch)\r\n    dispatch(state.tr.setSelection(selection).scrollIntoView());\r\n  return true;\r\n}\r\nfunction arrow(axis, dir) {\r\n  return (state, dispatch, view) => {\r\n    if (!view)\r\n      return false;\r\n    const sel = state.selection;\r\n    if (sel instanceof CellSelection) {\r\n      return maybeSetSelection(\r\n        state,\r\n        dispatch,\r\n        Selection2.near(sel.$headCell, dir)\r\n      );\r\n    }\r\n    if (axis != \"horiz\" && !sel.empty)\r\n      return false;\r\n    const end = atEndOfCell(view, axis, dir);\r\n    if (end == null)\r\n      return false;\r\n    if (axis == \"horiz\") {\r\n      return maybeSetSelection(\r\n        state,\r\n        dispatch,\r\n        Selection2.near(state.doc.resolve(sel.head + dir), dir)\r\n      );\r\n    } else {\r\n      const $cell = state.doc.resolve(end);\r\n      const $next = nextCell($cell, axis, dir);\r\n      let newSel;\r\n      if ($next)\r\n        newSel = Selection2.near($next, 1);\r\n      else if (dir < 0)\r\n        newSel = Selection2.near(state.doc.resolve($cell.before(-1)), -1);\r\n      else\r\n        newSel = Selection2.near(state.doc.resolve($cell.after(-1)), 1);\r\n      return maybeSetSelection(state, dispatch, newSel);\r\n    }\r\n  };\r\n}\r\nfunction shiftArrow(axis, dir) {\r\n  return (state, dispatch, view) => {\r\n    if (!view)\r\n      return false;\r\n    const sel = state.selection;\r\n    let cellSel;\r\n    if (sel instanceof CellSelection) {\r\n      cellSel = sel;\r\n    } else {\r\n      const end = atEndOfCell(view, axis, dir);\r\n      if (end == null)\r\n        return false;\r\n      cellSel = new CellSelection(state.doc.resolve(end));\r\n    }\r\n    const $head = nextCell(cellSel.$headCell, axis, dir);\r\n    if (!$head)\r\n      return false;\r\n    return maybeSetSelection(\r\n      state,\r\n      dispatch,\r\n      new CellSelection(cellSel.$anchorCell, $head)\r\n    );\r\n  };\r\n}\r\nfunction handleTripleClick(view, pos) {\r\n  const doc = view.state.doc, $cell = cellAround(doc.resolve(pos));\r\n  if (!$cell)\r\n    return false;\r\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\r\n  return true;\r\n}\r\nfunction handlePaste(view, _, slice) {\r\n  if (!isInTable(view.state))\r\n    return false;\r\n  let cells = pastedCells(slice);\r\n  const sel = view.state.selection;\r\n  if (sel instanceof CellSelection) {\r\n    if (!cells)\r\n      cells = {\r\n        width: 1,\r\n        height: 1,\r\n        rows: [\r\n          Fragment4.from(\r\n            fitSlice(tableNodeTypes(view.state.schema).cell, slice)\r\n          )\r\n        ]\r\n      };\r\n    const table = sel.$anchorCell.node(-1);\r\n    const start = sel.$anchorCell.start(-1);\r\n    const rect = TableMap.get(table).rectBetween(\r\n      sel.$anchorCell.pos - start,\r\n      sel.$headCell.pos - start\r\n    );\r\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\r\n    insertCells(view.state, view.dispatch, start, rect, cells);\r\n    return true;\r\n  } else if (cells) {\r\n    const $cell = selectionCell(view.state);\r\n    const start = $cell.start(-1);\r\n    insertCells(\r\n      view.state,\r\n      view.dispatch,\r\n      start,\r\n      TableMap.get($cell.node(-1)).findCell($cell.pos - start),\r\n      cells\r\n    );\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\nfunction handleMouseDown(view, startEvent) {\r\n  var _a;\r\n  if (startEvent.ctrlKey || startEvent.metaKey)\r\n    return;\r\n  const startDOMCell = domInCell(view, startEvent.target);\r\n  let $anchor;\r\n  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\r\n    setCellSelection(view.state.selection.$anchorCell, startEvent);\r\n    startEvent.preventDefault();\r\n  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a = cellUnderMouse(view, startEvent)) == null ? void 0 : _a.pos) != $anchor.pos) {\r\n    setCellSelection($anchor, startEvent);\r\n    startEvent.preventDefault();\r\n  } else if (!startDOMCell) {\r\n    return;\r\n  }\r\n  function setCellSelection($anchor2, event) {\r\n    let $head = cellUnderMouse(view, event);\r\n    const starting = tableEditingKey.getState(view.state) == null;\r\n    if (!$head || !inSameTable($anchor2, $head)) {\r\n      if (starting)\r\n        $head = $anchor2;\r\n      else\r\n        return;\r\n    }\r\n    const selection = new CellSelection($anchor2, $head);\r\n    if (starting || !view.state.selection.eq(selection)) {\r\n      const tr = view.state.tr.setSelection(selection);\r\n      if (starting)\r\n        tr.setMeta(tableEditingKey, $anchor2.pos);\r\n      view.dispatch(tr);\r\n    }\r\n  }\r\n  function stop() {\r\n    view.root.removeEventListener(\"mouseup\", stop);\r\n    view.root.removeEventListener(\"dragstart\", stop);\r\n    view.root.removeEventListener(\"mousemove\", move);\r\n    if (tableEditingKey.getState(view.state) != null)\r\n      view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));\r\n  }\r\n  function move(_event) {\r\n    const event = _event;\r\n    const anchor = tableEditingKey.getState(view.state);\r\n    let $anchor2;\r\n    if (anchor != null) {\r\n      $anchor2 = view.state.doc.resolve(anchor);\r\n    } else if (domInCell(view, event.target) != startDOMCell) {\r\n      $anchor2 = cellUnderMouse(view, startEvent);\r\n      if (!$anchor2)\r\n        return stop();\r\n    }\r\n    if ($anchor2)\r\n      setCellSelection($anchor2, event);\r\n  }\r\n  view.root.addEventListener(\"mouseup\", stop);\r\n  view.root.addEventListener(\"dragstart\", stop);\r\n  view.root.addEventListener(\"mousemove\", move);\r\n}\r\nfunction atEndOfCell(view, axis, dir) {\r\n  if (!(view.state.selection instanceof TextSelection3))\r\n    return null;\r\n  const { $head } = view.state.selection;\r\n  for (let d = $head.depth - 1; d >= 0; d--) {\r\n    const parent = $head.node(d), index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\r\n    if (index != (dir < 0 ? 0 : parent.childCount))\r\n      return null;\r\n    if (parent.type.spec.tableRole == \"cell\" || parent.type.spec.tableRole == \"header_cell\") {\r\n      const cellPos = $head.before(d);\r\n      const dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\r\n      return view.endOfTextblock(dirStr) ? cellPos : null;\r\n    }\r\n  }\r\n  return null;\r\n}\r\nfunction domInCell(view, dom) {\r\n  for (; dom && dom != view.dom; dom = dom.parentNode) {\r\n    if (dom.nodeName == \"TD\" || dom.nodeName == \"TH\") {\r\n      return dom;\r\n    }\r\n  }\r\n  return null;\r\n}\r\nfunction cellUnderMouse(view, event) {\r\n  const mousePos = view.posAtCoords({\r\n    left: event.clientX,\r\n    top: event.clientY\r\n  });\r\n  if (!mousePos)\r\n    return null;\r\n  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;\r\n}\r\n\r\n// src/columnresizing.ts\r\nimport { Plugin, PluginKey as PluginKey3 } from \"prosemirror-state\";\r\nimport {\r\n  Decoration as Decoration2,\r\n  DecorationSet as DecorationSet2\r\n} from \"prosemirror-view\";\r\n\r\n// src/tableview.ts\r\nvar TableView = class {\r\n  constructor(node, defaultCellMinWidth) {\r\n    this.node = node;\r\n    this.defaultCellMinWidth = defaultCellMinWidth;\r\n    this.dom = document.createElement(\"div\");\r\n    this.dom.className = \"tableWrapper\";\r\n    this.table = this.dom.appendChild(document.createElement(\"table\"));\r\n    this.table.style.setProperty(\r\n      \"--default-cell-min-width\",\r\n      `${defaultCellMinWidth}px`\r\n    );\r\n    this.colgroup = this.table.appendChild(document.createElement(\"colgroup\"));\r\n    updateColumnsOnResize(node, this.colgroup, this.table, defaultCellMinWidth);\r\n    this.contentDOM = this.table.appendChild(document.createElement(\"tbody\"));\r\n  }\r\n  update(node) {\r\n    if (node.type != this.node.type)\r\n      return false;\r\n    this.node = node;\r\n    updateColumnsOnResize(\r\n      node,\r\n      this.colgroup,\r\n      this.table,\r\n      this.defaultCellMinWidth\r\n    );\r\n    return true;\r\n  }\r\n  ignoreMutation(record) {\r\n    return record.type == \"attributes\" && (record.target == this.table || this.colgroup.contains(record.target));\r\n  }\r\n};\r\nfunction updateColumnsOnResize(node, colgroup, table, defaultCellMinWidth, overrideCol, overrideValue) {\r\n  var _a;\r\n  let totalWidth = 0;\r\n  let fixedWidth = true;\r\n  let nextDOM = colgroup.firstChild;\r\n  const row = node.firstChild;\r\n  if (!row)\r\n    return;\r\n  for (let i = 0, col = 0; i < row.childCount; i++) {\r\n    const { colspan, colwidth } = row.child(i).attrs;\r\n    for (let j = 0; j < colspan; j++, col++) {\r\n      const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];\r\n      const cssWidth = hasWidth ? hasWidth + \"px\" : \"\";\r\n      totalWidth += hasWidth || defaultCellMinWidth;\r\n      if (!hasWidth)\r\n        fixedWidth = false;\r\n      if (!nextDOM) {\r\n        const col2 = document.createElement(\"col\");\r\n        col2.style.width = cssWidth;\r\n        colgroup.appendChild(col2);\r\n      } else {\r\n        if (nextDOM.style.width != cssWidth) {\r\n          nextDOM.style.width = cssWidth;\r\n        }\r\n        nextDOM = nextDOM.nextSibling;\r\n      }\r\n    }\r\n  }\r\n  while (nextDOM) {\r\n    const after = nextDOM.nextSibling;\r\n    (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);\r\n    nextDOM = after;\r\n  }\r\n  if (fixedWidth) {\r\n    table.style.width = totalWidth + \"px\";\r\n    table.style.minWidth = \"\";\r\n  } else {\r\n    table.style.width = \"\";\r\n    table.style.minWidth = totalWidth + \"px\";\r\n  }\r\n}\r\n\r\n// src/columnresizing.ts\r\nvar columnResizingPluginKey = new PluginKey3(\r\n  \"tableColumnResizing\"\r\n);\r\nfunction columnResizing({\r\n  handleWidth = 5,\r\n  cellMinWidth = 25,\r\n  defaultCellMinWidth = 100,\r\n  View = TableView,\r\n  lastColumnResizable = true\r\n} = {}) {\r\n  const plugin = new Plugin({\r\n    key: columnResizingPluginKey,\r\n    state: {\r\n      init(_, state) {\r\n        var _a, _b;\r\n        const nodeViews = (_b = (_a = plugin.spec) == null ? void 0 : _a.props) == null ? void 0 : _b.nodeViews;\r\n        const tableName = tableNodeTypes(state.schema).table.name;\r\n        if (View && nodeViews) {\r\n          nodeViews[tableName] = (node, view) => {\r\n            return new View(node, defaultCellMinWidth, view);\r\n          };\r\n        }\r\n        return new ResizeState(-1, false);\r\n      },\r\n      apply(tr, prev) {\r\n        return prev.apply(tr);\r\n      }\r\n    },\r\n    props: {\r\n      attributes: (state) => {\r\n        const pluginState = columnResizingPluginKey.getState(state);\r\n        return pluginState && pluginState.activeHandle > -1 ? { class: \"resize-cursor\" } : {};\r\n      },\r\n      handleDOMEvents: {\r\n        mousemove: (view, event) => {\r\n          handleMouseMove(view, event, handleWidth, lastColumnResizable);\r\n        },\r\n        mouseleave: (view) => {\r\n          handleMouseLeave(view);\r\n        },\r\n        mousedown: (view, event) => {\r\n          handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth);\r\n        }\r\n      },\r\n      decorations: (state) => {\r\n        const pluginState = columnResizingPluginKey.getState(state);\r\n        if (pluginState && pluginState.activeHandle > -1) {\r\n          return handleDecorations(state, pluginState.activeHandle);\r\n        }\r\n      },\r\n      nodeViews: {}\r\n    }\r\n  });\r\n  return plugin;\r\n}\r\nvar ResizeState = class _ResizeState {\r\n  constructor(activeHandle, dragging) {\r\n    this.activeHandle = activeHandle;\r\n    this.dragging = dragging;\r\n  }\r\n  apply(tr) {\r\n    const state = this;\r\n    const action = tr.getMeta(columnResizingPluginKey);\r\n    if (action && action.setHandle != null)\r\n      return new _ResizeState(action.setHandle, false);\r\n    if (action && action.setDragging !== void 0)\r\n      return new _ResizeState(state.activeHandle, action.setDragging);\r\n    if (state.activeHandle > -1 && tr.docChanged) {\r\n      let handle = tr.mapping.map(state.activeHandle, -1);\r\n      if (!pointsAtCell(tr.doc.resolve(handle))) {\r\n        handle = -1;\r\n      }\r\n      return new _ResizeState(handle, state.dragging);\r\n    }\r\n    return state;\r\n  }\r\n};\r\nfunction handleMouseMove(view, event, handleWidth, lastColumnResizable) {\r\n  const pluginState = columnResizingPluginKey.getState(view.state);\r\n  if (!pluginState)\r\n    return;\r\n  if (!pluginState.dragging) {\r\n    const target = domCellAround(event.target);\r\n    let cell = -1;\r\n    if (target) {\r\n      const { left, right } = target.getBoundingClientRect();\r\n      if (event.clientX - left <= handleWidth)\r\n        cell = edgeCell(view, event, \"left\", handleWidth);\r\n      else if (right - event.clientX <= handleWidth)\r\n        cell = edgeCell(view, event, \"right\", handleWidth);\r\n    }\r\n    if (cell != pluginState.activeHandle) {\r\n      if (!lastColumnResizable && cell !== -1) {\r\n        const $cell = view.state.doc.resolve(cell);\r\n        const table = $cell.node(-1);\r\n        const map = TableMap.get(table);\r\n        const tableStart = $cell.start(-1);\r\n        const col = map.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;\r\n        if (col == map.width - 1) {\r\n          return;\r\n        }\r\n      }\r\n      updateHandle(view, cell);\r\n    }\r\n  }\r\n}\r\nfunction handleMouseLeave(view) {\r\n  const pluginState = columnResizingPluginKey.getState(view.state);\r\n  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging)\r\n    updateHandle(view, -1);\r\n}\r\nfunction handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth) {\r\n  var _a;\r\n  const win = (_a = view.dom.ownerDocument.defaultView) != null ? _a : window;\r\n  const pluginState = columnResizingPluginKey.getState(view.state);\r\n  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging)\r\n    return false;\r\n  const cell = view.state.doc.nodeAt(pluginState.activeHandle);\r\n  const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\r\n  view.dispatch(\r\n    view.state.tr.setMeta(columnResizingPluginKey, {\r\n      setDragging: { startX: event.clientX, startWidth: width }\r\n    })\r\n  );\r\n  function finish(event2) {\r\n    win.removeEventListener(\"mouseup\", finish);\r\n    win.removeEventListener(\"mousemove\", move);\r\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\r\n    if (pluginState2 == null ? void 0 : pluginState2.dragging) {\r\n      updateColumnWidth(\r\n        view,\r\n        pluginState2.activeHandle,\r\n        draggedWidth(pluginState2.dragging, event2, cellMinWidth)\r\n      );\r\n      view.dispatch(\r\n        view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null })\r\n      );\r\n    }\r\n  }\r\n  function move(event2) {\r\n    if (!event2.which)\r\n      return finish(event2);\r\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\r\n    if (!pluginState2)\r\n      return;\r\n    if (pluginState2.dragging) {\r\n      const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);\r\n      displayColumnWidth(\r\n        view,\r\n        pluginState2.activeHandle,\r\n        dragged,\r\n        defaultCellMinWidth\r\n      );\r\n    }\r\n  }\r\n  displayColumnWidth(\r\n    view,\r\n    pluginState.activeHandle,\r\n    width,\r\n    defaultCellMinWidth\r\n  );\r\n  win.addEventListener(\"mouseup\", finish);\r\n  win.addEventListener(\"mousemove\", move);\r\n  event.preventDefault();\r\n  return true;\r\n}\r\nfunction currentColWidth(view, cellPos, { colspan, colwidth }) {\r\n  const width = colwidth && colwidth[colwidth.length - 1];\r\n  if (width)\r\n    return width;\r\n  const dom = view.domAtPos(cellPos);\r\n  const node = dom.node.childNodes[dom.offset];\r\n  let domWidth = node.offsetWidth, parts = colspan;\r\n  if (colwidth) {\r\n    for (let i = 0; i < colspan; i++)\r\n      if (colwidth[i]) {\r\n        domWidth -= colwidth[i];\r\n        parts--;\r\n      }\r\n  }\r\n  return domWidth / parts;\r\n}\r\nfunction domCellAround(target) {\r\n  while (target && target.nodeName != \"TD\" && target.nodeName != \"TH\")\r\n    target = target.classList && target.classList.contains(\"ProseMirror\") ? null : target.parentNode;\r\n  return target;\r\n}\r\nfunction edgeCell(view, event, side, handleWidth) {\r\n  const offset = side == \"right\" ? -handleWidth : handleWidth;\r\n  const found = view.posAtCoords({\r\n    left: event.clientX + offset,\r\n    top: event.clientY\r\n  });\r\n  if (!found)\r\n    return -1;\r\n  const { pos } = found;\r\n  const $cell = cellAround(view.state.doc.resolve(pos));\r\n  if (!$cell)\r\n    return -1;\r\n  if (side == \"right\")\r\n    return $cell.pos;\r\n  const map = TableMap.get($cell.node(-1)), start = $cell.start(-1);\r\n  const index = map.map.indexOf($cell.pos - start);\r\n  return index % map.width == 0 ? -1 : start + map.map[index - 1];\r\n}\r\nfunction draggedWidth(dragging, event, resizeMinWidth) {\r\n  const offset = event.clientX - dragging.startX;\r\n  return Math.max(resizeMinWidth, dragging.startWidth + offset);\r\n}\r\nfunction updateHandle(view, value) {\r\n  view.dispatch(\r\n    view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value })\r\n  );\r\n}\r\nfunction updateColumnWidth(view, cell, width) {\r\n  const $cell = view.state.doc.resolve(cell);\r\n  const table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);\r\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\r\n  const tr = view.state.tr;\r\n  for (let row = 0; row < map.height; row++) {\r\n    const mapIndex = row * map.width + col;\r\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width])\r\n      continue;\r\n    const pos = map.map[mapIndex];\r\n    const attrs = table.nodeAt(pos).attrs;\r\n    const index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\r\n    if (attrs.colwidth && attrs.colwidth[index] == width)\r\n      continue;\r\n    const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);\r\n    colwidth[index] = width;\r\n    tr.setNodeMarkup(start + pos, null, { ...attrs, colwidth });\r\n  }\r\n  if (tr.docChanged)\r\n    view.dispatch(tr);\r\n}\r\nfunction displayColumnWidth(view, cell, width, defaultCellMinWidth) {\r\n  const $cell = view.state.doc.resolve(cell);\r\n  const table = $cell.node(-1), start = $cell.start(-1);\r\n  const col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\r\n  let dom = view.domAtPos($cell.start(-1)).node;\r\n  while (dom && dom.nodeName != \"TABLE\") {\r\n    dom = dom.parentNode;\r\n  }\r\n  if (!dom)\r\n    return;\r\n  updateColumnsOnResize(\r\n    table,\r\n    dom.firstChild,\r\n    dom,\r\n    defaultCellMinWidth,\r\n    col,\r\n    width\r\n  );\r\n}\r\nfunction zeroes(n) {\r\n  return Array(n).fill(0);\r\n}\r\nfunction handleDecorations(state, cell) {\r\n  var _a;\r\n  const decorations = [];\r\n  const $cell = state.doc.resolve(cell);\r\n  const table = $cell.node(-1);\r\n  if (!table) {\r\n    return DecorationSet2.empty;\r\n  }\r\n  const map = TableMap.get(table);\r\n  const start = $cell.start(-1);\r\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\r\n  for (let row = 0; row < map.height; row++) {\r\n    const index = col + row * map.width;\r\n    if ((col == map.width - 1 || map.map[index] != map.map[index + 1]) && (row == 0 || map.map[index] != map.map[index - map.width])) {\r\n      const cellPos = map.map[index];\r\n      const pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;\r\n      const dom = document.createElement(\"div\");\r\n      dom.className = \"column-resize-handle\";\r\n      if ((_a = columnResizingPluginKey.getState(state)) == null ? void 0 : _a.dragging) {\r\n        decorations.push(\r\n          Decoration2.node(\r\n            start + cellPos,\r\n            start + cellPos + table.nodeAt(cellPos).nodeSize,\r\n            {\r\n              class: \"column-resize-dragging\"\r\n            }\r\n          )\r\n        );\r\n      }\r\n      decorations.push(Decoration2.widget(pos, dom));\r\n    }\r\n  }\r\n  return DecorationSet2.create(state.doc, decorations);\r\n}\r\n\r\n// src/index.ts\r\nfunction tableEditing({\r\n  allowTableNodeSelection = false\r\n} = {}) {\r\n  return new Plugin2({\r\n    key: tableEditingKey,\r\n    // This piece of state is used to remember when a mouse-drag\r\n    // cell-selection is happening, so that it can continue even as\r\n    // transactions (which might move its anchor cell) come in.\r\n    state: {\r\n      init() {\r\n        return null;\r\n      },\r\n      apply(tr, cur) {\r\n        const set = tr.getMeta(tableEditingKey);\r\n        if (set != null)\r\n          return set == -1 ? null : set;\r\n        if (cur == null || !tr.docChanged)\r\n          return cur;\r\n        const { deleted, pos } = tr.mapping.mapResult(cur);\r\n        return deleted ? null : pos;\r\n      }\r\n    },\r\n    props: {\r\n      decorations: drawCellSelection,\r\n      handleDOMEvents: {\r\n        mousedown: handleMouseDown\r\n      },\r\n      createSelectionBetween(view) {\r\n        return tableEditingKey.getState(view.state) != null ? view.state.selection : null;\r\n      },\r\n      handleTripleClick,\r\n      handleKeyDown,\r\n      handlePaste\r\n    },\r\n    appendTransaction(_, oldState, state) {\r\n      return normalizeSelection(\r\n        state,\r\n        fixTables(state, oldState),\r\n        allowTableNodeSelection\r\n      );\r\n    }\r\n  });\r\n}\r\nexport {\r\n  CellBookmark,\r\n  CellSelection,\r\n  ResizeState,\r\n  TableMap,\r\n  TableView,\r\n  clipCells as __clipCells,\r\n  insertCells as __insertCells,\r\n  pastedCells as __pastedCells,\r\n  addColSpan,\r\n  addColumn,\r\n  addColumnAfter,\r\n  addColumnBefore,\r\n  addRow,\r\n  addRowAfter,\r\n  addRowBefore,\r\n  cellAround,\r\n  cellNear,\r\n  colCount,\r\n  columnIsHeader,\r\n  columnResizing,\r\n  columnResizingPluginKey,\r\n  deleteCellSelection,\r\n  deleteColumn,\r\n  deleteRow,\r\n  deleteTable,\r\n  findCell,\r\n  fixTables,\r\n  fixTablesKey,\r\n  goToNextCell,\r\n  handlePaste,\r\n  inSameTable,\r\n  isInTable,\r\n  mergeCells,\r\n  moveCellForward,\r\n  nextCell,\r\n  pointsAtCell,\r\n  removeColSpan,\r\n  removeColumn,\r\n  removeRow,\r\n  rowIsHeader,\r\n  selectedRect,\r\n  selectionCell,\r\n  setCellAttr,\r\n  splitCell,\r\n  splitCellWithType,\r\n  tableEditing,\r\n  tableEditingKey,\r\n  tableNodeTypes,\r\n  tableNodes,\r\n  toggleHeader,\r\n  toggleHeaderCell,\r\n  toggleHeaderColumn,\r\n  toggleHeaderRow,\r\n  updateColumnsOnResize\r\n};\r\n", "export function getColStyleDeclaration(minWidth: number, width: number | undefined): [string, string] {\n  if (width) {\n    // apply the stored width unless it is below the configured minimum cell width\n    return ['width', `${Math.max(width, minWidth)}px`]\n  }\n\n  // set the minimum with on the column if it has no stored width\n  return ['min-width', `${minWidth}px`]\n\n}\n", "import { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { NodeView, ViewMutationRecord } from '@tiptap/pm/view'\n\nimport { getColStyleDeclaration } from './utilities/colStyle.js'\n\nexport function updateColumns(\n  node: ProseMirrorNode,\n  colgroup: HTMLTableColElement, // <colgroup> has the same prototype as <col>\n  table: HTMLTableElement,\n  cellMinWidth: number,\n  overrideCol?: number,\n  overrideValue?: number,\n) {\n  let totalWidth = 0\n  let fixedWidth = true\n  let nextDOM = colgroup.firstChild\n  const row = node.firstChild\n\n  if (row !== null) {\n    for (let i = 0, col = 0; i < row.childCount; i += 1) {\n      const { colspan, colwidth } = row.child(i).attrs\n\n      for (let j = 0; j < colspan; j += 1, col += 1) {\n        const hasWidth = overrideCol === col ? overrideValue : (colwidth && colwidth[j]) as number | undefined\n        const cssWidth = hasWidth ? `${hasWidth}px` : ''\n\n        totalWidth += hasWidth || cellMinWidth\n\n        if (!hasWidth) {\n          fixedWidth = false\n        }\n\n        if (!nextDOM) {\n          const colElement = document.createElement('col')\n\n          const [propertyKey, propertyValue] = getColStyleDeclaration(cellMinWidth, hasWidth)\n\n          colElement.style.setProperty(propertyKey, propertyValue)\n\n          colgroup.appendChild(colElement)\n        } else {\n          if ((nextDOM as HTMLTableColElement).style.width !== cssWidth) {\n            const [propertyKey, propertyValue] = getColStyleDeclaration(cellMinWidth, hasWidth);\n\n            (nextDOM as HTMLTableColElement).style.setProperty(propertyKey, propertyValue)\n          }\n\n          nextDOM = nextDOM.nextSibling\n        }\n      }\n    }\n  }\n\n  while (nextDOM) {\n    const after = nextDOM.nextSibling\n\n    nextDOM.parentNode?.removeChild(nextDOM)\n    nextDOM = after\n  }\n\n  if (fixedWidth) {\n    table.style.width = `${totalWidth}px`\n    table.style.minWidth = ''\n  } else {\n    table.style.width = ''\n    table.style.minWidth = `${totalWidth}px`\n  }\n}\n\nexport class TableView implements NodeView {\n  node: ProseMirrorNode\n\n  cellMinWidth: number\n\n  dom: HTMLDivElement\n\n  table: HTMLTableElement\n\n  colgroup: HTMLTableColElement\n\n  contentDOM: HTMLTableSectionElement\n\n  constructor(node: ProseMirrorNode, cellMinWidth: number) {\n    this.node = node\n    this.cellMinWidth = cellMinWidth\n    this.dom = document.createElement('div')\n    this.dom.className = 'tableWrapper'\n    this.table = this.dom.appendChild(document.createElement('table'))\n    this.colgroup = this.table.appendChild(document.createElement('colgroup'))\n    updateColumns(node, this.colgroup, this.table, cellMinWidth)\n    this.contentDOM = this.table.appendChild(document.createElement('tbody'))\n  }\n\n  update(node: ProseMirrorNode) {\n    if (node.type !== this.node.type) {\n      return false\n    }\n\n    this.node = node\n    updateColumns(node, this.colgroup, this.table, this.cellMinWidth)\n\n    return true\n  }\n\n  ignoreMutation(mutation: ViewMutationRecord) {\n    return (\n      mutation.type === 'attributes'\n      && (mutation.target === this.table || this.colgroup.contains(mutation.target))\n    )\n  }\n}\n", "import { DOMOutputSpec, Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { getColStyleDeclaration } from './colStyle.js'\n\nexport type ColGroup = {\n  colgroup: DOMOutputSpec\n  tableWidth: string\n  tableMinWidth: string\n} | Record<string, never>;\n\n/**\n * Creates a colgroup element for a table node in ProseMirror.\n *\n * @param node - The ProseMirror node representing the table.\n * @param cellMinWidth - The minimum width of a cell in the table.\n * @param overrideCol - (Optional) The index of the column to override the width of.\n * @param overrideValue - (Optional) The width value to use for the overridden column.\n * @returns An object containing the colgroup element, the total width of the table, and the minimum width of the table.\n */\nexport function createColGroup(\n  node: ProseMirrorNode,\n  cellMinWidth: number,\n): ColGroup\nexport function createColGroup(\n  node: ProseMirrorNode,\n  cellMinWidth: number,\n  overrideCol: number,\n  overrideValue: number,\n): ColGroup\nexport function createColGroup(\n  node: ProseMirrorNode,\n  cellMinWidth: number,\n  overrideCol?: number,\n  overrideValue?: number,\n): ColGroup {\n  let totalWidth = 0\n  let fixedWidth = true\n  const cols: DOMOutputSpec[] = []\n  const row = node.firstChild\n\n  if (!row) {\n    return {}\n  }\n\n  for (let i = 0, col = 0; i < row.childCount; i += 1) {\n    const { colspan, colwidth } = row.child(i).attrs\n\n    for (let j = 0; j < colspan; j += 1, col += 1) {\n      const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j] as number | undefined\n\n      totalWidth += hasWidth || cellMinWidth\n\n      if (!hasWidth) {\n        fixedWidth = false\n      }\n\n      const [property, value] = getColStyleDeclaration(cellMinWidth, hasWidth)\n\n      cols.push([\n        'col',\n        { style: `${property}: ${value}` },\n      ])\n    }\n  }\n\n  const tableWidth = fixedWidth ? `${totalWidth}px` : ''\n  const tableMinWidth = fixedWidth ? '' : `${totalWidth}px`\n\n  const colgroup: DOMOutputSpec = ['colgroup', {}, ...cols]\n\n  return { colgroup, tableWidth, tableMinWidth }\n}\n", "import { Fragment, Node as ProsemirrorNode, NodeType } from '@tiptap/pm/model'\n\nexport function createCell(\n  cellType: NodeType,\n  cellContent?: Fragment | ProsemirrorNode | Array<ProsemirrorNode>,\n): ProsemirrorNode | null | undefined {\n  if (cellContent) {\n    return cellType.createChecked(null, cellContent)\n  }\n\n  return cellType.createAndFill()\n}\n", "import { NodeType, Schema } from '@tiptap/pm/model'\n\nexport function getTableNodeTypes(schema: Schema): { [key: string]: NodeType } {\n  if (schema.cached.tableNodeTypes) {\n    return schema.cached.tableNodeTypes\n  }\n\n  const roles: { [key: string]: NodeType } = {}\n\n  Object.keys(schema.nodes).forEach(type => {\n    const nodeType = schema.nodes[type]\n\n    if (nodeType.spec.tableRole) {\n      roles[nodeType.spec.tableRole] = nodeType\n    }\n  })\n\n  schema.cached.tableNodeTypes = roles\n\n  return roles\n}\n", "import { Fragment, Node as ProsemirrorNode, Schema } from '@tiptap/pm/model'\n\nimport { createCell } from './createCell.js'\nimport { getTableNodeTypes } from './getTableNodeTypes.js'\n\nexport function createTable(\n  schema: Schema,\n  rowsCount: number,\n  colsCount: number,\n  withHeaderRow: boolean,\n  cellContent?: Fragment | ProsemirrorNode | Array<ProsemirrorNode>,\n): ProsemirrorNode {\n  const types = getTableNodeTypes(schema)\n  const headerCells: ProsemirrorNode[] = []\n  const cells: ProsemirrorNode[] = []\n\n  for (let index = 0; index < colsCount; index += 1) {\n    const cell = createCell(types.cell, cellContent)\n\n    if (cell) {\n      cells.push(cell)\n    }\n\n    if (withHeaderRow) {\n      const headerCell = createCell(types.header_cell, cellContent)\n\n      if (headerCell) {\n        headerCells.push(headerCell)\n      }\n    }\n  }\n\n  const rows: ProsemirrorNode[] = []\n\n  for (let index = 0; index < rowsCount; index += 1) {\n    rows.push(types.row.createChecked(null, withHeaderRow && index === 0 ? headerCells : cells))\n  }\n\n  return types.table.createChecked(null, rows)\n}\n", "import { CellSelection } from '@tiptap/pm/tables'\n\nexport function isCellSelection(value: unknown): value is CellSelection {\n  return value instanceof CellSelection\n}\n", "import { findParentNodeClosestToPos, KeyboardShortcutCommand } from '@tiptap/core'\n\nimport { isCellSelection } from './isCellSelection.js'\n\nexport const deleteTableWhenAllCellsSelected: KeyboardShortcutCommand = ({ editor }) => {\n  const { selection } = editor.state\n\n  if (!isCellSelection(selection)) {\n    return false\n  }\n\n  let cellCount = 0\n  const table = findParentNodeClosestToPos(selection.ranges[0].$from, node => {\n    return node.type.name === 'table'\n  })\n\n  table?.node.descendants(node => {\n    if (node.type.name === 'table') {\n      return false\n    }\n\n    if (['tableCell', 'tableHeader'].includes(node.type.name)) {\n      cellCount += 1\n    }\n  })\n\n  const allCellsSelected = cellCount === selection.ranges.length\n\n  if (!allCellsSelected) {\n    return false\n  }\n\n  editor.commands.deleteTable()\n\n  return true\n}\n", "import {\n  callOrReturn, getExtensionField, mergeAttributes, Node, ParentConfig,\n} from '@tiptap/core'\nimport { DOMOutputSpec, Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { TextSelection } from '@tiptap/pm/state'\nimport {\n  addColumnAfter,\n  addColumnBefore,\n  addRowAfter,\n  addRowBefore,\n  CellSelection,\n  columnResizing,\n  deleteColumn,\n  deleteRow,\n  deleteTable,\n  fixTables,\n  goToNextCell,\n  mergeCells,\n  setCellAttr,\n  splitCell,\n  tableEditing,\n  toggleHeader,\n  toggleHeaderCell,\n} from '@tiptap/pm/tables'\nimport { EditorView, NodeView } from '@tiptap/pm/view'\n\nimport { TableView } from './TableView.js'\nimport { createColGroup } from './utilities/createColGroup.js'\nimport { createTable } from './utilities/createTable.js'\nimport { deleteTableWhenAllCellsSelected } from './utilities/deleteTableWhenAllCellsSelected.js'\n\nexport interface TableOptions {\n  /**\n   * HTML attributes for the table element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * Enables the resizing of tables.\n   * @default false\n   * @example true\n   */\n  resizable: boolean\n\n  /**\n   * The width of the resize handle.\n   * @default 5\n   * @example 10\n   */\n  handleWidth: number\n\n  /**\n   * The minimum width of a cell.\n   * @default 25\n   * @example 50\n   */\n  cellMinWidth: number\n\n  /**\n   * The node view to render the table.\n   * @default TableView\n   */\n  View: (new (node: ProseMirrorNode, cellMinWidth: number, view: EditorView) => NodeView) | null\n\n  /**\n   * Enables the resizing of the last column.\n   * @default true\n   * @example false\n   */\n  lastColumnResizable: boolean\n\n  /**\n   * Allow table node selection.\n   * @default false\n   * @example true\n   */\n  allowTableNodeSelection: boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    table: {\n      /**\n       * Insert a table\n       * @param options The table attributes\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.insertTable({ rows: 3, cols: 3, withHeaderRow: true })\n       */\n      insertTable: (options?: {\n        rows?: number\n        cols?: number\n        withHeaderRow?: boolean\n      }) => ReturnType\n\n      /**\n       * Add a column before the current column\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.addColumnBefore()\n       */\n      addColumnBefore: () => ReturnType\n\n      /**\n       * Add a column after the current column\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.addColumnAfter()\n       */\n      addColumnAfter: () => ReturnType\n\n      /**\n       * Delete the current column\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.deleteColumn()\n       */\n      deleteColumn: () => ReturnType\n\n      /**\n       * Add a row before the current row\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.addRowBefore()\n       */\n      addRowBefore: () => ReturnType\n\n      /**\n       * Add a row after the current row\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.addRowAfter()\n       */\n      addRowAfter: () => ReturnType\n\n      /**\n       * Delete the current row\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.deleteRow()\n       */\n      deleteRow: () => ReturnType\n\n      /**\n       * Delete the current table\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.deleteTable()\n       */\n      deleteTable: () => ReturnType\n\n      /**\n       * Merge the currently selected cells\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.mergeCells()\n       */\n      mergeCells: () => ReturnType\n\n      /**\n       * Split the currently selected cell\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.splitCell()\n       */\n      splitCell: () => ReturnType\n\n      /**\n       * Toggle the header column\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.toggleHeaderColumn()\n       */\n      toggleHeaderColumn: () => ReturnType\n\n      /**\n       * Toggle the header row\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.toggleHeaderRow()\n       */\n      toggleHeaderRow: () => ReturnType\n\n      /**\n       * Toggle the header cell\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.toggleHeaderCell()\n       */\n      toggleHeaderCell: () => ReturnType\n\n      /**\n       * Merge or split the currently selected cells\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.mergeOrSplit()\n       */\n      mergeOrSplit: () => ReturnType\n\n      /**\n       * Set a cell attribute\n       * @param name The attribute name\n       * @param value The attribute value\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.setCellAttribute('align', 'right')\n       */\n      setCellAttribute: (name: string, value: any) => ReturnType\n\n      /**\n       * Moves the selection to the next cell\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.goToNextCell()\n       */\n      goToNextCell: () => ReturnType\n\n      /**\n       * Moves the selection to the previous cell\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.goToPreviousCell()\n       */\n      goToPreviousCell: () => ReturnType\n\n      /**\n       * Try to fix the table structure if necessary\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.fixTables()\n       */\n      fixTables: () => ReturnType\n\n      /**\n       * Set a cell selection inside the current table\n       * @param position The cell position\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.setCellSelection({ anchorCell: 1, headCell: 2 })\n       */\n      setCellSelection: (position: { anchorCell: number; headCell?: number }) => ReturnType\n    }\n  }\n\n  interface NodeConfig<Options, Storage> {\n    /**\n     * A string or function to determine the role of the table.\n     * @default 'table'\n     * @example () => 'table'\n     */\n    tableRole?:\n      | string\n      | ((this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<NodeConfig<Options>>['tableRole']\n    }) => string)\n  }\n}\n\n/**\n * This extension allows you to create tables.\n * @see https://www.tiptap.dev/api/nodes/table\n */\nexport const Table = Node.create<TableOptions>({\n  name: 'table',\n\n  // @ts-ignore\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      resizable: false,\n      handleWidth: 5,\n      cellMinWidth: 25,\n      // TODO: fix\n      View: TableView,\n      lastColumnResizable: true,\n      allowTableNodeSelection: false,\n    }\n  },\n\n  content: 'tableRow+',\n\n  tableRole: 'table',\n\n  isolating: true,\n\n  group: 'block',\n\n  parseHTML() {\n    return [{ tag: 'table' }]\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    const { colgroup, tableWidth, tableMinWidth } = createColGroup(\n      node,\n      this.options.cellMinWidth,\n    )\n\n    const table: DOMOutputSpec = [\n      'table',\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {\n        style: tableWidth\n          ? `width: ${tableWidth}`\n          : `min-width: ${tableMinWidth}`,\n      }),\n      colgroup,\n      ['tbody', 0],\n    ]\n\n    return table\n  },\n\n  addCommands() {\n    return {\n      insertTable:\n        ({ rows = 3, cols = 3, withHeaderRow = true } = {}) => ({ tr, dispatch, editor }) => {\n          const node = createTable(editor.schema, rows, cols, withHeaderRow)\n\n          if (dispatch) {\n            const offset = tr.selection.from + 1\n\n            tr.replaceSelectionWith(node)\n              .scrollIntoView()\n              .setSelection(TextSelection.near(tr.doc.resolve(offset)))\n          }\n\n          return true\n        },\n      addColumnBefore:\n        () => ({ state, dispatch }) => {\n          return addColumnBefore(state, dispatch)\n        },\n      addColumnAfter:\n        () => ({ state, dispatch }) => {\n          return addColumnAfter(state, dispatch)\n        },\n      deleteColumn:\n        () => ({ state, dispatch }) => {\n          return deleteColumn(state, dispatch)\n        },\n      addRowBefore:\n        () => ({ state, dispatch }) => {\n          return addRowBefore(state, dispatch)\n        },\n      addRowAfter:\n        () => ({ state, dispatch }) => {\n          return addRowAfter(state, dispatch)\n        },\n      deleteRow:\n        () => ({ state, dispatch }) => {\n          return deleteRow(state, dispatch)\n        },\n      deleteTable:\n        () => ({ state, dispatch }) => {\n          return deleteTable(state, dispatch)\n        },\n      mergeCells:\n        () => ({ state, dispatch }) => {\n          return mergeCells(state, dispatch)\n        },\n      splitCell:\n        () => ({ state, dispatch }) => {\n          return splitCell(state, dispatch)\n        },\n      toggleHeaderColumn:\n        () => ({ state, dispatch }) => {\n          return toggleHeader('column')(state, dispatch)\n        },\n      toggleHeaderRow:\n        () => ({ state, dispatch }) => {\n          return toggleHeader('row')(state, dispatch)\n        },\n      toggleHeaderCell:\n        () => ({ state, dispatch }) => {\n          return toggleHeaderCell(state, dispatch)\n        },\n      mergeOrSplit:\n        () => ({ state, dispatch }) => {\n          if (mergeCells(state, dispatch)) {\n            return true\n          }\n\n          return splitCell(state, dispatch)\n        },\n      setCellAttribute:\n        (name, value) => ({ state, dispatch }) => {\n          return setCellAttr(name, value)(state, dispatch)\n        },\n      goToNextCell:\n        () => ({ state, dispatch }) => {\n          return goToNextCell(1)(state, dispatch)\n        },\n      goToPreviousCell:\n        () => ({ state, dispatch }) => {\n          return goToNextCell(-1)(state, dispatch)\n        },\n      fixTables:\n        () => ({ state, dispatch }) => {\n          if (dispatch) {\n            fixTables(state)\n          }\n\n          return true\n        },\n      setCellSelection:\n        position => ({ tr, dispatch }) => {\n          if (dispatch) {\n            const selection = CellSelection.create(tr.doc, position.anchorCell, position.headCell)\n\n            // @ts-ignore\n            tr.setSelection(selection)\n          }\n\n          return true\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Tab: () => {\n        if (this.editor.commands.goToNextCell()) {\n          return true\n        }\n\n        if (!this.editor.can().addRowAfter()) {\n          return false\n        }\n\n        return this.editor.chain().addRowAfter().goToNextCell().run()\n      },\n      'Shift-Tab': () => this.editor.commands.goToPreviousCell(),\n      Backspace: deleteTableWhenAllCellsSelected,\n      'Mod-Backspace': deleteTableWhenAllCellsSelected,\n      Delete: deleteTableWhenAllCellsSelected,\n      'Mod-Delete': deleteTableWhenAllCellsSelected,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    const isResizable = this.options.resizable && this.editor.isEditable\n\n    return [\n      ...(isResizable\n        ? [\n          columnResizing({\n            handleWidth: this.options.handleWidth,\n            cellMinWidth: this.options.cellMinWidth,\n            defaultCellMinWidth: this.options.cellMinWidth,\n            View: this.options.View,\n            lastColumnResizable: this.options.lastColumnResizable,\n          }),\n        ]\n        : []),\n      tableEditing({\n        allowTableNodeSelection: this.options.allowTableNodeSelection,\n      }),\n    ]\n  },\n\n  extendNodeSchema(extension) {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    }\n\n    return {\n      tableRole: callOrReturn(getExtensionField(extension, 'tableRole', context)),\n    }\n  },\n})\n"],
  "mappings": "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",
  "names": ["TableView"]
}
