{
  "version": 3,
  "sources": ["../../mdast-util-to-markdown/lib/configure.js", "../../mdast-util-to-markdown/lib/handle/blockquote.js", "../../mdast-util-to-markdown/lib/handle/break.js", "../../longest-streak/index.js", "../../mdast-util-to-markdown/lib/util/format-code-as-indented.js", "../../mdast-util-to-markdown/lib/util/check-fence.js", "../../mdast-util-to-markdown/lib/handle/code.js", "../../mdast-util-to-markdown/lib/util/check-quote.js", "../../mdast-util-to-markdown/lib/handle/definition.js", "../../mdast-util-to-markdown/lib/util/check-emphasis.js", "../../mdast-util-to-markdown/lib/handle/emphasis.js", "../../mdast-util-to-markdown/lib/util/format-heading-as-setext.js", "../../mdast-util-to-markdown/lib/handle/heading.js", "../../mdast-util-to-markdown/lib/handle/html.js", "../../mdast-util-to-markdown/lib/handle/image.js", "../../mdast-util-to-markdown/lib/handle/image-reference.js", "../../mdast-util-to-markdown/lib/util/format-link-as-autolink.js", "../../mdast-util-to-markdown/lib/handle/link.js", "../../mdast-util-to-markdown/lib/handle/link-reference.js", "../../mdast-util-to-markdown/lib/util/check-bullet-other.js", "../../mdast-util-to-markdown/lib/util/check-bullet-ordered.js", "../../mdast-util-to-markdown/lib/util/check-bullet-ordered-other.js", "../../mdast-util-to-markdown/lib/util/check-rule.js", "../../mdast-util-to-markdown/lib/handle/list.js", "../../mdast-util-to-markdown/lib/handle/paragraph.js", "../../mdast-util-to-markdown/lib/handle/root.js", "../../mdast-util-to-markdown/lib/util/check-strong.js", "../../mdast-util-to-markdown/lib/handle/strong.js", "../../mdast-util-to-markdown/lib/handle/text.js", "../../mdast-util-to-markdown/lib/util/check-rule-repetition.js", "../../mdast-util-to-markdown/lib/handle/thematic-break.js", "../../mdast-util-to-markdown/lib/handle/index.js", "../../mdast-util-to-markdown/lib/join.js", "../../mdast-util-to-markdown/lib/unsafe.js", "../../mdast-util-to-markdown/lib/index.js", "../../remark-stringify/lib/index.js"],
  "sourcesContent": ["/**\r\n * @typedef {import('./types.js').Options} Options\r\n * @typedef {import('./types.js').State} State\r\n */\r\n\r\n/**\r\n * @param {State} base\r\n * @param {Options} extension\r\n * @returns {State}\r\n */\r\nexport function configure(base, extension) {\r\n  let index = -1\r\n  /** @type {keyof Options} */\r\n  let key\r\n\r\n  // First do subextensions.\r\n  if (extension.extensions) {\r\n    while (++index < extension.extensions.length) {\r\n      configure(base, extension.extensions[index])\r\n    }\r\n  }\r\n\r\n  for (key in extension) {\r\n    if (key === 'extensions') {\r\n      // Empty.\r\n    } else if (key === 'unsafe' || key === 'join') {\r\n      /* c8 ignore next 2 */\r\n      // @ts-expect-error: hush.\r\n      base[key] = [...(base[key] || []), ...(extension[key] || [])]\r\n    } else if (key === 'handlers') {\r\n      base[key] = Object.assign(base[key], extension[key] || {})\r\n    } else {\r\n      // @ts-expect-error: hush.\r\n      base.options[key] = extension[key]\r\n    }\r\n  }\r\n\r\n  return base\r\n}\r\n", "/**\r\n * @typedef {import('mdast').Blockquote} Blockquote\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Info} Info\r\n * @typedef {import('../types.js').Map} Map\r\n */\r\n\r\n/**\r\n * @param {Blockquote} node\r\n * @param {Parent | undefined} _\r\n * @param {State} state\r\n * @param {Info} info\r\n * @returns {string}\r\n */\r\nexport function blockquote(node, _, state, info) {\r\n  const exit = state.enter('blockquote')\r\n  const tracker = state.createTracker(info)\r\n  tracker.move('> ')\r\n  tracker.shift(2)\r\n  const value = state.indentLines(\r\n    state.containerFlow(node, tracker.current()),\r\n    map\r\n  )\r\n  exit()\r\n  return value\r\n}\r\n\r\n/** @type {Map} */\r\nfunction map(line, _, blank) {\r\n  return '>' + (blank ? '' : ' ') + line\r\n}\r\n", "/**\r\n * @typedef {import('mdast').Break} Break\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Info} Info\r\n */\r\n\r\nimport {patternInScope} from '../util/pattern-in-scope.js'\r\n\r\n/**\r\n * @param {Break} _\r\n * @param {Parent | undefined} _1\r\n * @param {State} state\r\n * @param {Info} info\r\n * @returns {string}\r\n */\r\nexport function hardBreak(_, _1, state, info) {\r\n  let index = -1\r\n\r\n  while (++index < state.unsafe.length) {\r\n    // If we can’t put eols in this construct (setext headings, tables), use a\r\n    // space instead.\r\n    if (\r\n      state.unsafe[index].character === '\\n' &&\r\n      patternInScope(state.stack, state.unsafe[index])\r\n    ) {\r\n      return /[ \\t]/.test(info.before) ? '' : ' '\r\n    }\r\n  }\r\n\r\n  return '\\\\\\n'\r\n}\r\n", "/**\r\n * Get the count of the longest repeating streak of `substring` in `value`.\r\n *\r\n * @param {string} value\r\n *   Content to search in.\r\n * @param {string} substring\r\n *   Substring to look for, typically one character.\r\n * @returns {number}\r\n *   Count of most frequent adjacent `substring`s in `value`.\r\n */\r\nexport function longestStreak(value, substring) {\r\n  const source = String(value)\r\n  let index = source.indexOf(substring)\r\n  let expected = index\r\n  let count = 0\r\n  let max = 0\r\n\r\n  if (typeof substring !== 'string') {\r\n    throw new TypeError('Expected substring')\r\n  }\r\n\r\n  while (index !== -1) {\r\n    if (index === expected) {\r\n      if (++count > max) {\r\n        max = count\r\n      }\r\n    } else {\r\n      count = 1\r\n    }\r\n\r\n    expected = index + substring.length\r\n    index = source.indexOf(substring, expected)\r\n  }\r\n\r\n  return max\r\n}\r\n", "/**\r\n * @typedef {import('mdast').Code} Code\r\n * @typedef {import('../types.js').State} State\r\n */\r\n\r\n/**\r\n * @param {Code} node\r\n * @param {State} state\r\n * @returns {boolean}\r\n */\r\nexport function formatCodeAsIndented(node, state) {\r\n  return Boolean(\r\n    !state.options.fences &&\r\n      node.value &&\r\n      // If there’s no info…\r\n      !node.lang &&\r\n      // And there’s a non-whitespace character…\r\n      /[^ \\r\\n]/.test(node.value) &&\r\n      // And the value doesn’t start or end in a blank…\r\n      !/^[\\t ]*(?:[\\r\\n]|$)|(?:^|[\\r\\n])[\\t ]*$/.test(node.value)\r\n  )\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Options} Options\r\n */\r\n\r\n/**\r\n * @param {State} state\r\n * @returns {Exclude<Options['fence'], null | undefined>}\r\n */\r\nexport function checkFence(state) {\r\n  const marker = state.options.fence || '`'\r\n\r\n  if (marker !== '`' && marker !== '~') {\r\n    throw new Error(\r\n      'Cannot serialize code with `' +\r\n        marker +\r\n        '` for `options.fence`, expected `` ` `` or `~`'\r\n    )\r\n  }\r\n\r\n  return marker\r\n}\r\n", "/**\r\n * @typedef {import('mdast').Code} Code\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Info} Info\r\n * @typedef {import('../types.js').Map} Map\r\n */\r\n\r\nimport {longestStreak} from 'longest-streak'\r\nimport {formatCodeAsIndented} from '../util/format-code-as-indented.js'\r\nimport {checkFence} from '../util/check-fence.js'\r\n\r\n/**\r\n * @param {Code} node\r\n * @param {Parent | undefined} _\r\n * @param {State} state\r\n * @param {Info} info\r\n * @returns {string}\r\n */\r\nexport function code(node, _, state, info) {\r\n  const marker = checkFence(state)\r\n  const raw = node.value || ''\r\n  const suffix = marker === '`' ? 'GraveAccent' : 'Tilde'\r\n\r\n  if (formatCodeAsIndented(node, state)) {\r\n    const exit = state.enter('codeIndented')\r\n    const value = state.indentLines(raw, map)\r\n    exit()\r\n    return value\r\n  }\r\n\r\n  const tracker = state.createTracker(info)\r\n  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3))\r\n  const exit = state.enter('codeFenced')\r\n  let value = tracker.move(sequence)\r\n\r\n  if (node.lang) {\r\n    const subexit = state.enter(`codeFencedLang${suffix}`)\r\n    value += tracker.move(\r\n      state.safe(node.lang, {\r\n        before: value,\r\n        after: ' ',\r\n        encode: ['`'],\r\n        ...tracker.current()\r\n      })\r\n    )\r\n    subexit()\r\n  }\r\n\r\n  if (node.lang && node.meta) {\r\n    const subexit = state.enter(`codeFencedMeta${suffix}`)\r\n    value += tracker.move(' ')\r\n    value += tracker.move(\r\n      state.safe(node.meta, {\r\n        before: value,\r\n        after: '\\n',\r\n        encode: ['`'],\r\n        ...tracker.current()\r\n      })\r\n    )\r\n    subexit()\r\n  }\r\n\r\n  value += tracker.move('\\n')\r\n\r\n  if (raw) {\r\n    value += tracker.move(raw + '\\n')\r\n  }\r\n\r\n  value += tracker.move(sequence)\r\n  exit()\r\n  return value\r\n}\r\n\r\n/** @type {Map} */\r\nfunction map(line, _, blank) {\r\n  return (blank ? '' : '    ') + line\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Options} Options\r\n */\r\n\r\n/**\r\n * @param {State} state\r\n * @returns {Exclude<Options['quote'], null | undefined>}\r\n */\r\nexport function checkQuote(state) {\r\n  const marker = state.options.quote || '\"'\r\n\r\n  if (marker !== '\"' && marker !== \"'\") {\r\n    throw new Error(\r\n      'Cannot serialize title with `' +\r\n        marker +\r\n        '` for `options.quote`, expected `\"`, or `\\'`'\r\n    )\r\n  }\r\n\r\n  return marker\r\n}\r\n", "/**\r\n * @typedef {import('mdast').Definition} Definition\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Info} Info\r\n */\r\n\r\nimport {checkQuote} from '../util/check-quote.js'\r\n\r\n/**\r\n * @param {Definition} node\r\n * @param {Parent | undefined} _\r\n * @param {State} state\r\n * @param {Info} info\r\n * @returns {string}\r\n */\r\nexport function definition(node, _, state, info) {\r\n  const quote = checkQuote(state)\r\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\r\n  const exit = state.enter('definition')\r\n  let subexit = state.enter('label')\r\n  const tracker = state.createTracker(info)\r\n  let value = tracker.move('[')\r\n  value += tracker.move(\r\n    state.safe(state.associationId(node), {\r\n      before: value,\r\n      after: ']',\r\n      ...tracker.current()\r\n    })\r\n  )\r\n  value += tracker.move(']: ')\r\n\r\n  subexit()\r\n\r\n  if (\r\n    // If there’s no url, or…\r\n    !node.url ||\r\n    // If there are control characters or whitespace.\r\n    /[\\0- \\u007F]/.test(node.url)\r\n  ) {\r\n    subexit = state.enter('destinationLiteral')\r\n    value += tracker.move('<')\r\n    value += tracker.move(\r\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\r\n    )\r\n    value += tracker.move('>')\r\n  } else {\r\n    // No whitespace, raw is prettier.\r\n    subexit = state.enter('destinationRaw')\r\n    value += tracker.move(\r\n      state.safe(node.url, {\r\n        before: value,\r\n        after: node.title ? ' ' : '\\n',\r\n        ...tracker.current()\r\n      })\r\n    )\r\n  }\r\n\r\n  subexit()\r\n\r\n  if (node.title) {\r\n    subexit = state.enter(`title${suffix}`)\r\n    value += tracker.move(' ' + quote)\r\n    value += tracker.move(\r\n      state.safe(node.title, {\r\n        before: value,\r\n        after: quote,\r\n        ...tracker.current()\r\n      })\r\n    )\r\n    value += tracker.move(quote)\r\n    subexit()\r\n  }\r\n\r\n  exit()\r\n\r\n  return value\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Options} Options\r\n */\r\n\r\n/**\r\n * @param {State} state\r\n * @returns {Exclude<Options['emphasis'], null | undefined>}\r\n */\r\nexport function checkEmphasis(state) {\r\n  const marker = state.options.emphasis || '*'\r\n\r\n  if (marker !== '*' && marker !== '_') {\r\n    throw new Error(\r\n      'Cannot serialize emphasis with `' +\r\n        marker +\r\n        '` for `options.emphasis`, expected `*`, or `_`'\r\n    )\r\n  }\r\n\r\n  return marker\r\n}\r\n", "/**\r\n * @typedef {import('mdast').Emphasis} Emphasis\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Info} Info\r\n */\r\n\r\nimport {checkEmphasis} from '../util/check-emphasis.js'\r\n\r\nemphasis.peek = emphasisPeek\r\n\r\n// To do: there are cases where emphasis cannot “form” depending on the\r\n// previous or next character of sequences.\r\n// There’s no way around that though, except for injecting zero-width stuff.\r\n// Do we need to safeguard against that?\r\n/**\r\n * @param {Emphasis} node\r\n * @param {Parent | undefined} _\r\n * @param {State} state\r\n * @param {Info} info\r\n * @returns {string}\r\n */\r\nexport function emphasis(node, _, state, info) {\r\n  const marker = checkEmphasis(state)\r\n  const exit = state.enter('emphasis')\r\n  const tracker = state.createTracker(info)\r\n  let value = tracker.move(marker)\r\n  value += tracker.move(\r\n    state.containerPhrasing(node, {\r\n      before: value,\r\n      after: marker,\r\n      ...tracker.current()\r\n    })\r\n  )\r\n  value += tracker.move(marker)\r\n  exit()\r\n  return value\r\n}\r\n\r\n/**\r\n * @param {Emphasis} _\r\n * @param {Parent | undefined} _1\r\n * @param {State} state\r\n * @returns {string}\r\n */\r\nfunction emphasisPeek(_, _1, state) {\r\n  return state.options.emphasis || '*'\r\n}\r\n", "/**\r\n * @typedef {import('mdast').Heading} Heading\r\n * @typedef {import('../types.js').State} State\r\n */\r\n\r\nimport {visit, EXIT} from 'unist-util-visit'\r\nimport {toString} from 'mdast-util-to-string'\r\n\r\n/**\r\n * @param {Heading} node\r\n * @param {State} state\r\n * @returns {boolean}\r\n */\r\nexport function formatHeadingAsSetext(node, state) {\r\n  let literalWithBreak = false\r\n\r\n  // Look for literals with a line break.\r\n  // Note that this also\r\n  visit(node, (node) => {\r\n    if (\r\n      ('value' in node && /\\r?\\n|\\r/.test(node.value)) ||\r\n      node.type === 'break'\r\n    ) {\r\n      literalWithBreak = true\r\n      return EXIT\r\n    }\r\n  })\r\n\r\n  return Boolean(\r\n    (!node.depth || node.depth < 3) &&\r\n      toString(node) &&\r\n      (state.options.setext || literalWithBreak)\r\n  )\r\n}\r\n", "/**\r\n * @typedef {import('mdast').Heading} Heading\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Info} Info\r\n */\r\n\r\nimport {formatHeadingAsSetext} from '../util/format-heading-as-setext.js'\r\n\r\n/**\r\n * @param {Heading} node\r\n * @param {Parent | undefined} _\r\n * @param {State} state\r\n * @param {Info} info\r\n * @returns {string}\r\n */\r\nexport function heading(node, _, state, info) {\r\n  const rank = Math.max(Math.min(6, node.depth || 1), 1)\r\n  const tracker = state.createTracker(info)\r\n\r\n  if (formatHeadingAsSetext(node, state)) {\r\n    const exit = state.enter('headingSetext')\r\n    const subexit = state.enter('phrasing')\r\n    const value = state.containerPhrasing(node, {\r\n      ...tracker.current(),\r\n      before: '\\n',\r\n      after: '\\n'\r\n    })\r\n    subexit()\r\n    exit()\r\n\r\n    return (\r\n      value +\r\n      '\\n' +\r\n      (rank === 1 ? '=' : '-').repeat(\r\n        // The whole size…\r\n        value.length -\r\n          // Minus the position of the character after the last EOL (or\r\n          // 0 if there is none)…\r\n          (Math.max(value.lastIndexOf('\\r'), value.lastIndexOf('\\n')) + 1)\r\n      )\r\n    )\r\n  }\r\n\r\n  const sequence = '#'.repeat(rank)\r\n  const exit = state.enter('headingAtx')\r\n  const subexit = state.enter('phrasing')\r\n\r\n  // Note: for proper tracking, we should reset the output positions when there\r\n  // is no content returned, because then the space is not output.\r\n  // Practically, in that case, there is no content, so it doesn’t matter that\r\n  // we’ve tracked one too many characters.\r\n  tracker.move(sequence + ' ')\r\n\r\n  let value = state.containerPhrasing(node, {\r\n    before: '# ',\r\n    after: '\\n',\r\n    ...tracker.current()\r\n  })\r\n\r\n  if (/^[\\t ]/.test(value)) {\r\n    // To do: what effect has the character reference on tracking?\r\n    value =\r\n      '&#x' +\r\n      value.charCodeAt(0).toString(16).toUpperCase() +\r\n      ';' +\r\n      value.slice(1)\r\n  }\r\n\r\n  value = value ? sequence + ' ' + value : sequence\r\n\r\n  if (state.options.closeAtx) {\r\n    value += ' ' + sequence\r\n  }\r\n\r\n  subexit()\r\n  exit()\r\n\r\n  return value\r\n}\r\n", "/**\r\n * @typedef {import('mdast').HTML} HTML\r\n */\r\n\r\nhtml.peek = htmlPeek\r\n\r\n/**\r\n * @param {HTML} node\r\n * @returns {string}\r\n */\r\nexport function html(node) {\r\n  return node.value || ''\r\n}\r\n\r\n/**\r\n * @returns {string}\r\n */\r\nfunction htmlPeek() {\r\n  return '<'\r\n}\r\n", "/**\r\n * @typedef {import('mdast').Image} Image\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Info} Info\r\n */\r\n\r\nimport {checkQuote} from '../util/check-quote.js'\r\n\r\nimage.peek = imagePeek\r\n\r\n/**\r\n * @param {Image} node\r\n * @param {Parent | undefined} _\r\n * @param {State} state\r\n * @param {Info} info\r\n * @returns {string}\r\n */\r\nexport function image(node, _, state, info) {\r\n  const quote = checkQuote(state)\r\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\r\n  const exit = state.enter('image')\r\n  let subexit = state.enter('label')\r\n  const tracker = state.createTracker(info)\r\n  let value = tracker.move('![')\r\n  value += tracker.move(\r\n    state.safe(node.alt, {before: value, after: ']', ...tracker.current()})\r\n  )\r\n  value += tracker.move('](')\r\n\r\n  subexit()\r\n\r\n  if (\r\n    // If there’s no url but there is a title…\r\n    (!node.url && node.title) ||\r\n    // If there are control characters or whitespace.\r\n    /[\\0- \\u007F]/.test(node.url)\r\n  ) {\r\n    subexit = state.enter('destinationLiteral')\r\n    value += tracker.move('<')\r\n    value += tracker.move(\r\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\r\n    )\r\n    value += tracker.move('>')\r\n  } else {\r\n    // No whitespace, raw is prettier.\r\n    subexit = state.enter('destinationRaw')\r\n    value += tracker.move(\r\n      state.safe(node.url, {\r\n        before: value,\r\n        after: node.title ? ' ' : ')',\r\n        ...tracker.current()\r\n      })\r\n    )\r\n  }\r\n\r\n  subexit()\r\n\r\n  if (node.title) {\r\n    subexit = state.enter(`title${suffix}`)\r\n    value += tracker.move(' ' + quote)\r\n    value += tracker.move(\r\n      state.safe(node.title, {\r\n        before: value,\r\n        after: quote,\r\n        ...tracker.current()\r\n      })\r\n    )\r\n    value += tracker.move(quote)\r\n    subexit()\r\n  }\r\n\r\n  value += tracker.move(')')\r\n  exit()\r\n\r\n  return value\r\n}\r\n\r\n/**\r\n * @returns {string}\r\n */\r\nfunction imagePeek() {\r\n  return '!'\r\n}\r\n", "/**\r\n * @typedef {import('mdast').ImageReference} ImageReference\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Info} Info\r\n */\r\n\r\nimageReference.peek = imageReferencePeek\r\n\r\n/**\r\n * @param {ImageReference} node\r\n * @param {Parent | undefined} _\r\n * @param {State} state\r\n * @param {Info} info\r\n * @returns {string}\r\n */\r\nexport function imageReference(node, _, state, info) {\r\n  const type = node.referenceType\r\n  const exit = state.enter('imageReference')\r\n  let subexit = state.enter('label')\r\n  const tracker = state.createTracker(info)\r\n  let value = tracker.move('![')\r\n  const alt = state.safe(node.alt, {\r\n    before: value,\r\n    after: ']',\r\n    ...tracker.current()\r\n  })\r\n  value += tracker.move(alt + '][')\r\n\r\n  subexit()\r\n  // Hide the fact that we’re in phrasing, because escapes don’t work.\r\n  const stack = state.stack\r\n  state.stack = []\r\n  subexit = state.enter('reference')\r\n  // Note: for proper tracking, we should reset the output positions when we end\r\n  // up making a `shortcut` reference, because then there is no brace output.\r\n  // Practically, in that case, there is no content, so it doesn’t matter that\r\n  // we’ve tracked one too many characters.\r\n  const reference = state.safe(state.associationId(node), {\r\n    before: value,\r\n    after: ']',\r\n    ...tracker.current()\r\n  })\r\n  subexit()\r\n  state.stack = stack\r\n  exit()\r\n\r\n  if (type === 'full' || !alt || alt !== reference) {\r\n    value += tracker.move(reference + ']')\r\n  } else if (type === 'shortcut') {\r\n    // Remove the unwanted `[`.\r\n    value = value.slice(0, -1)\r\n  } else {\r\n    value += tracker.move(']')\r\n  }\r\n\r\n  return value\r\n}\r\n\r\n/**\r\n * @returns {string}\r\n */\r\nfunction imageReferencePeek() {\r\n  return '!'\r\n}\r\n", "/**\r\n * @typedef {import('mdast').Link} Link\r\n * @typedef {import('../types.js').State} State\r\n */\r\n\r\nimport {toString} from 'mdast-util-to-string'\r\n\r\n/**\r\n * @param {Link} node\r\n * @param {State} state\r\n * @returns {boolean}\r\n */\r\nexport function formatLinkAsAutolink(node, state) {\r\n  const raw = toString(node)\r\n\r\n  return Boolean(\r\n    !state.options.resourceLink &&\r\n      // If there’s a url…\r\n      node.url &&\r\n      // And there’s a no title…\r\n      !node.title &&\r\n      // And the content of `node` is a single text node…\r\n      node.children &&\r\n      node.children.length === 1 &&\r\n      node.children[0].type === 'text' &&\r\n      // And if the url is the same as the content…\r\n      (raw === node.url || 'mailto:' + raw === node.url) &&\r\n      // And that starts w/ a protocol…\r\n      /^[a-z][a-z+.-]+:/i.test(node.url) &&\r\n      // And that doesn’t contain ASCII control codes (character escapes and\r\n      // references don’t work), space, or angle brackets…\r\n      !/[\\0- <>\\u007F]/.test(node.url)\r\n  )\r\n}\r\n", "/**\r\n * @typedef {import('mdast').Link} Link\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Info} Info\r\n * @typedef {import('../types.js').Exit} Exit\r\n */\r\n\r\nimport {checkQuote} from '../util/check-quote.js'\r\nimport {formatLinkAsAutolink} from '../util/format-link-as-autolink.js'\r\n\r\nlink.peek = linkPeek\r\n\r\n/**\r\n * @param {Link} node\r\n * @param {Parent | undefined} _\r\n * @param {State} state\r\n * @param {Info} info\r\n * @returns {string}\r\n */\r\nexport function link(node, _, state, info) {\r\n  const quote = checkQuote(state)\r\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\r\n  const tracker = state.createTracker(info)\r\n  /** @type {Exit} */\r\n  let exit\r\n  /** @type {Exit} */\r\n  let subexit\r\n\r\n  if (formatLinkAsAutolink(node, state)) {\r\n    // Hide the fact that we’re in phrasing, because escapes don’t work.\r\n    const stack = state.stack\r\n    state.stack = []\r\n    exit = state.enter('autolink')\r\n    let value = tracker.move('<')\r\n    value += tracker.move(\r\n      state.containerPhrasing(node, {\r\n        before: value,\r\n        after: '>',\r\n        ...tracker.current()\r\n      })\r\n    )\r\n    value += tracker.move('>')\r\n    exit()\r\n    state.stack = stack\r\n    return value\r\n  }\r\n\r\n  exit = state.enter('link')\r\n  subexit = state.enter('label')\r\n  let value = tracker.move('[')\r\n  value += tracker.move(\r\n    state.containerPhrasing(node, {\r\n      before: value,\r\n      after: '](',\r\n      ...tracker.current()\r\n    })\r\n  )\r\n  value += tracker.move('](')\r\n  subexit()\r\n\r\n  if (\r\n    // If there’s no url but there is a title…\r\n    (!node.url && node.title) ||\r\n    // If there are control characters or whitespace.\r\n    /[\\0- \\u007F]/.test(node.url)\r\n  ) {\r\n    subexit = state.enter('destinationLiteral')\r\n    value += tracker.move('<')\r\n    value += tracker.move(\r\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\r\n    )\r\n    value += tracker.move('>')\r\n  } else {\r\n    // No whitespace, raw is prettier.\r\n    subexit = state.enter('destinationRaw')\r\n    value += tracker.move(\r\n      state.safe(node.url, {\r\n        before: value,\r\n        after: node.title ? ' ' : ')',\r\n        ...tracker.current()\r\n      })\r\n    )\r\n  }\r\n\r\n  subexit()\r\n\r\n  if (node.title) {\r\n    subexit = state.enter(`title${suffix}`)\r\n    value += tracker.move(' ' + quote)\r\n    value += tracker.move(\r\n      state.safe(node.title, {\r\n        before: value,\r\n        after: quote,\r\n        ...tracker.current()\r\n      })\r\n    )\r\n    value += tracker.move(quote)\r\n    subexit()\r\n  }\r\n\r\n  value += tracker.move(')')\r\n\r\n  exit()\r\n  return value\r\n}\r\n\r\n/**\r\n * @param {Link} node\r\n * @param {Parent | undefined} _\r\n * @param {State} state\r\n * @returns {string}\r\n */\r\nfunction linkPeek(node, _, state) {\r\n  return formatLinkAsAutolink(node, state) ? '<' : '['\r\n}\r\n", "/**\r\n * @typedef {import('mdast').LinkReference} LinkReference\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Info} Info\r\n */\r\n\r\nlinkReference.peek = linkReferencePeek\r\n\r\n/**\r\n * @param {LinkReference} node\r\n * @param {Parent | undefined} _\r\n * @param {State} state\r\n * @param {Info} info\r\n * @returns {string}\r\n */\r\nexport function linkReference(node, _, state, info) {\r\n  const type = node.referenceType\r\n  const exit = state.enter('linkReference')\r\n  let subexit = state.enter('label')\r\n  const tracker = state.createTracker(info)\r\n  let value = tracker.move('[')\r\n  const text = state.containerPhrasing(node, {\r\n    before: value,\r\n    after: ']',\r\n    ...tracker.current()\r\n  })\r\n  value += tracker.move(text + '][')\r\n\r\n  subexit()\r\n  // Hide the fact that we’re in phrasing, because escapes don’t work.\r\n  const stack = state.stack\r\n  state.stack = []\r\n  subexit = state.enter('reference')\r\n  // Note: for proper tracking, we should reset the output positions when we end\r\n  // up making a `shortcut` reference, because then there is no brace output.\r\n  // Practically, in that case, there is no content, so it doesn’t matter that\r\n  // we’ve tracked one too many characters.\r\n  const reference = state.safe(state.associationId(node), {\r\n    before: value,\r\n    after: ']',\r\n    ...tracker.current()\r\n  })\r\n  subexit()\r\n  state.stack = stack\r\n  exit()\r\n\r\n  if (type === 'full' || !text || text !== reference) {\r\n    value += tracker.move(reference + ']')\r\n  } else if (type === 'shortcut') {\r\n    // Remove the unwanted `[`.\r\n    value = value.slice(0, -1)\r\n  } else {\r\n    value += tracker.move(']')\r\n  }\r\n\r\n  return value\r\n}\r\n\r\n/**\r\n * @returns {string}\r\n */\r\nfunction linkReferencePeek() {\r\n  return '['\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Options} Options\r\n */\r\n\r\nimport {checkBullet} from './check-bullet.js'\r\n\r\n/**\r\n * @param {State} state\r\n * @returns {Exclude<Options['bullet'], null | undefined>}\r\n */\r\nexport function checkBulletOther(state) {\r\n  const bullet = checkBullet(state)\r\n  const bulletOther = state.options.bulletOther\r\n\r\n  if (!bulletOther) {\r\n    return bullet === '*' ? '-' : '*'\r\n  }\r\n\r\n  if (bulletOther !== '*' && bulletOther !== '+' && bulletOther !== '-') {\r\n    throw new Error(\r\n      'Cannot serialize items with `' +\r\n        bulletOther +\r\n        '` for `options.bulletOther`, expected `*`, `+`, or `-`'\r\n    )\r\n  }\r\n\r\n  if (bulletOther === bullet) {\r\n    throw new Error(\r\n      'Expected `bullet` (`' +\r\n        bullet +\r\n        '`) and `bulletOther` (`' +\r\n        bulletOther +\r\n        '`) to be different'\r\n    )\r\n  }\r\n\r\n  return bulletOther\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Options} Options\r\n */\r\n\r\n/**\r\n * @param {State} state\r\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\r\n */\r\nexport function checkBulletOrdered(state) {\r\n  const marker = state.options.bulletOrdered || '.'\r\n\r\n  if (marker !== '.' && marker !== ')') {\r\n    throw new Error(\r\n      'Cannot serialize items with `' +\r\n        marker +\r\n        '` for `options.bulletOrdered`, expected `.` or `)`'\r\n    )\r\n  }\r\n\r\n  return marker\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Options} Options\r\n */\r\n\r\nimport {checkBulletOrdered} from './check-bullet-ordered.js'\r\n\r\n/**\r\n * @param {State} state\r\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\r\n */\r\nexport function checkBulletOrderedOther(state) {\r\n  const bulletOrdered = checkBulletOrdered(state)\r\n  const bulletOrderedOther = state.options.bulletOrderedOther\r\n\r\n  if (!bulletOrderedOther) {\r\n    return bulletOrdered === '.' ? ')' : '.'\r\n  }\r\n\r\n  if (bulletOrderedOther !== '.' && bulletOrderedOther !== ')') {\r\n    throw new Error(\r\n      'Cannot serialize items with `' +\r\n        bulletOrderedOther +\r\n        '` for `options.bulletOrderedOther`, expected `*`, `+`, or `-`'\r\n    )\r\n  }\r\n\r\n  if (bulletOrderedOther === bulletOrdered) {\r\n    throw new Error(\r\n      'Expected `bulletOrdered` (`' +\r\n        bulletOrdered +\r\n        '`) and `bulletOrderedOther` (`' +\r\n        bulletOrderedOther +\r\n        '`) to be different'\r\n    )\r\n  }\r\n\r\n  return bulletOrderedOther\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Options} Options\r\n */\r\n\r\n/**\r\n * @param {State} state\r\n * @returns {Exclude<Options['rule'], null | undefined>}\r\n */\r\nexport function checkRule(state) {\r\n  const marker = state.options.rule || '*'\r\n\r\n  if (marker !== '*' && marker !== '-' && marker !== '_') {\r\n    throw new Error(\r\n      'Cannot serialize rules with `' +\r\n        marker +\r\n        '` for `options.rule`, expected `*`, `-`, or `_`'\r\n    )\r\n  }\r\n\r\n  return marker\r\n}\r\n", "/**\r\n * @typedef {import('mdast').List} List\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Info} Info\r\n */\r\n\r\nimport {checkBullet} from '../util/check-bullet.js'\r\nimport {checkBulletOther} from '../util/check-bullet-other.js'\r\nimport {checkBulletOrdered} from '../util/check-bullet-ordered.js'\r\nimport {checkBulletOrderedOther} from '../util/check-bullet-ordered-other.js'\r\nimport {checkRule} from '../util/check-rule.js'\r\n\r\n/**\r\n * @param {List} node\r\n * @param {Parent | undefined} parent\r\n * @param {State} state\r\n * @param {Info} info\r\n * @returns {string}\r\n */\r\nexport function list(node, parent, state, info) {\r\n  const exit = state.enter('list')\r\n  const bulletCurrent = state.bulletCurrent\r\n  /** @type {string} */\r\n  let bullet = node.ordered ? checkBulletOrdered(state) : checkBullet(state)\r\n  /** @type {string} */\r\n  const bulletOther = node.ordered\r\n    ? checkBulletOrderedOther(state)\r\n    : checkBulletOther(state)\r\n  const bulletLastUsed = state.bulletLastUsed\r\n  let useDifferentMarker = false\r\n\r\n  if (\r\n    parent &&\r\n    // Explicit `other` set.\r\n    (node.ordered\r\n      ? state.options.bulletOrderedOther\r\n      : state.options.bulletOther) &&\r\n    bulletLastUsed &&\r\n    bullet === bulletLastUsed\r\n  ) {\r\n    useDifferentMarker = true\r\n  }\r\n\r\n  if (!node.ordered) {\r\n    const firstListItem = node.children ? node.children[0] : undefined\r\n\r\n    // If there’s an empty first list item directly in two list items,\r\n    // we have to use a different bullet:\r\n    //\r\n    // ```markdown\r\n    // * - *\r\n    // ```\r\n    //\r\n    // …because otherwise it would become one big thematic break.\r\n    if (\r\n      // Bullet could be used as a thematic break marker:\r\n      (bullet === '*' || bullet === '-') &&\r\n      // Empty first list item:\r\n      firstListItem &&\r\n      (!firstListItem.children || !firstListItem.children[0]) &&\r\n      // Directly in two other list items:\r\n      state.stack[state.stack.length - 1] === 'list' &&\r\n      state.stack[state.stack.length - 2] === 'listItem' &&\r\n      state.stack[state.stack.length - 3] === 'list' &&\r\n      state.stack[state.stack.length - 4] === 'listItem' &&\r\n      // That are each the first child.\r\n      state.indexStack[state.indexStack.length - 1] === 0 &&\r\n      state.indexStack[state.indexStack.length - 2] === 0 &&\r\n      state.indexStack[state.indexStack.length - 3] === 0\r\n    ) {\r\n      useDifferentMarker = true\r\n    }\r\n\r\n    // If there’s a thematic break at the start of the first list item,\r\n    // we have to use a different bullet:\r\n    //\r\n    // ```markdown\r\n    // * ---\r\n    // ```\r\n    //\r\n    // …because otherwise it would become one big thematic break.\r\n    if (checkRule(state) === bullet && firstListItem) {\r\n      let index = -1\r\n\r\n      while (++index < node.children.length) {\r\n        const item = node.children[index]\r\n\r\n        if (\r\n          item &&\r\n          item.type === 'listItem' &&\r\n          item.children &&\r\n          item.children[0] &&\r\n          item.children[0].type === 'thematicBreak'\r\n        ) {\r\n          useDifferentMarker = true\r\n          break\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (useDifferentMarker) {\r\n    bullet = bulletOther\r\n  }\r\n\r\n  state.bulletCurrent = bullet\r\n  const value = state.containerFlow(node, info)\r\n  state.bulletLastUsed = bullet\r\n  state.bulletCurrent = bulletCurrent\r\n  exit()\r\n  return value\r\n}\r\n", "/**\r\n * @typedef {import('mdast').Paragraph} Paragraph\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Info} Info\r\n */\r\n\r\n/**\r\n * @param {Paragraph} node\r\n * @param {Parent | undefined} _\r\n * @param {State} state\r\n * @param {Info} info\r\n * @returns {string}\r\n */\r\nexport function paragraph(node, _, state, info) {\r\n  const exit = state.enter('paragraph')\r\n  const subexit = state.enter('phrasing')\r\n  const value = state.containerPhrasing(node, info)\r\n  subexit()\r\n  exit()\r\n  return value\r\n}\r\n", "/**\r\n * @typedef {import('mdast').Root} Root\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Info} Info\r\n */\r\n\r\nimport {phrasing} from 'mdast-util-phrasing'\r\n\r\n/**\r\n * @param {Root} node\r\n * @param {Parent | undefined} _\r\n * @param {State} state\r\n * @param {Info} info\r\n * @returns {string}\r\n */\r\nexport function root(node, _, state, info) {\r\n  // Note: `html` nodes are ambiguous.\r\n  const hasPhrasing = node.children.some((d) => phrasing(d))\r\n  const fn = hasPhrasing ? state.containerPhrasing : state.containerFlow\r\n  // @ts-expect-error: `root`s are supposed to have one type of content\r\n  return fn.call(state, node, info)\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Options} Options\r\n */\r\n\r\n/**\r\n * @param {State} state\r\n * @returns {Exclude<Options['strong'], null | undefined>}\r\n */\r\nexport function checkStrong(state) {\r\n  const marker = state.options.strong || '*'\r\n\r\n  if (marker !== '*' && marker !== '_') {\r\n    throw new Error(\r\n      'Cannot serialize strong with `' +\r\n        marker +\r\n        '` for `options.strong`, expected `*`, or `_`'\r\n    )\r\n  }\r\n\r\n  return marker\r\n}\r\n", "/**\r\n * @typedef {import('mdast').Strong} Strong\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Info} Info\r\n */\r\n\r\nimport {checkStrong} from '../util/check-strong.js'\r\n\r\nstrong.peek = strongPeek\r\n\r\n// To do: there are cases where emphasis cannot “form” depending on the\r\n// previous or next character of sequences.\r\n// There’s no way around that though, except for injecting zero-width stuff.\r\n// Do we need to safeguard against that?\r\n/**\r\n * @param {Strong} node\r\n * @param {Parent | undefined} _\r\n * @param {State} state\r\n * @param {Info} info\r\n * @returns {string}\r\n */\r\nexport function strong(node, _, state, info) {\r\n  const marker = checkStrong(state)\r\n  const exit = state.enter('strong')\r\n  const tracker = state.createTracker(info)\r\n  let value = tracker.move(marker + marker)\r\n  value += tracker.move(\r\n    state.containerPhrasing(node, {\r\n      before: value,\r\n      after: marker,\r\n      ...tracker.current()\r\n    })\r\n  )\r\n  value += tracker.move(marker + marker)\r\n  exit()\r\n  return value\r\n}\r\n\r\n/**\r\n * @param {Strong} _\r\n * @param {Parent | undefined} _1\r\n * @param {State} state\r\n * @returns {string}\r\n */\r\nfunction strongPeek(_, _1, state) {\r\n  return state.options.strong || '*'\r\n}\r\n", "/**\r\n * @typedef {import('mdast').Text} Text\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Info} Info\r\n */\r\n\r\n/**\r\n * @param {Text} node\r\n * @param {Parent | undefined} _\r\n * @param {State} state\r\n * @param {Info} info\r\n * @returns {string}\r\n */\r\nexport function text(node, _, state, info) {\r\n  return state.safe(node.value, info)\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Options} Options\r\n */\r\n\r\n/**\r\n * @param {State} state\r\n * @returns {Exclude<Options['ruleRepetition'], null | undefined>}\r\n */\r\nexport function checkRuleRepetition(state) {\r\n  const repetition = state.options.ruleRepetition || 3\r\n\r\n  if (repetition < 3) {\r\n    throw new Error(\r\n      'Cannot serialize rules with repetition `' +\r\n        repetition +\r\n        '` for `options.ruleRepetition`, expected `3` or more'\r\n    )\r\n  }\r\n\r\n  return repetition\r\n}\r\n", "/**\r\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').State} State\r\n */\r\n\r\nimport {checkRuleRepetition} from '../util/check-rule-repetition.js'\r\nimport {checkRule} from '../util/check-rule.js'\r\n\r\n/**\r\n * @param {ThematicBreak} _\r\n * @param {Parent | undefined} _1\r\n * @param {State} state\r\n * @returns {string}\r\n */\r\nexport function thematicBreak(_, _1, state) {\r\n  const value = (\r\n    checkRule(state) + (state.options.ruleSpaces ? ' ' : '')\r\n  ).repeat(checkRuleRepetition(state))\r\n\r\n  return state.options.ruleSpaces ? value.slice(0, -1) : value\r\n}\r\n", "import {blockquote} from './blockquote.js'\r\nimport {hardBreak} from './break.js'\r\nimport {code} from './code.js'\r\nimport {definition} from './definition.js'\r\nimport {emphasis} from './emphasis.js'\r\nimport {heading} from './heading.js'\r\nimport {html} from './html.js'\r\nimport {image} from './image.js'\r\nimport {imageReference} from './image-reference.js'\r\nimport {inlineCode} from './inline-code.js'\r\nimport {link} from './link.js'\r\nimport {linkReference} from './link-reference.js'\r\nimport {list} from './list.js'\r\nimport {listItem} from './list-item.js'\r\nimport {paragraph} from './paragraph.js'\r\nimport {root} from './root.js'\r\nimport {strong} from './strong.js'\r\nimport {text} from './text.js'\r\nimport {thematicBreak} from './thematic-break.js'\r\n\r\n/**\r\n * Default (CommonMark) handlers.\r\n */\r\nexport const handle = {\r\n  blockquote,\r\n  break: hardBreak,\r\n  code,\r\n  definition,\r\n  emphasis,\r\n  hardBreak,\r\n  heading,\r\n  html,\r\n  image,\r\n  imageReference,\r\n  inlineCode,\r\n  link,\r\n  linkReference,\r\n  list,\r\n  listItem,\r\n  paragraph,\r\n  root,\r\n  strong,\r\n  text,\r\n  thematicBreak\r\n}\r\n", "/**\r\n * @typedef {import('./types.js').Join} Join\r\n */\r\n\r\nimport {formatCodeAsIndented} from './util/format-code-as-indented.js'\r\nimport {formatHeadingAsSetext} from './util/format-heading-as-setext.js'\r\n\r\n/** @type {Array<Join>} */\r\nexport const join = [joinDefaults]\r\n\r\n/** @type {Join} */\r\nfunction joinDefaults(left, right, parent, state) {\r\n  // Indented code after list or another indented code.\r\n  if (\r\n    right.type === 'code' &&\r\n    formatCodeAsIndented(right, state) &&\r\n    (left.type === 'list' ||\r\n      (left.type === right.type && formatCodeAsIndented(left, state)))\r\n  ) {\r\n    return false\r\n  }\r\n\r\n  // Two lists with the same marker.\r\n  if (\r\n    left.type === 'list' &&\r\n    left.type === right.type &&\r\n    Boolean(left.ordered) === Boolean(right.ordered) &&\r\n    !(left.ordered\r\n      ? state.options.bulletOrderedOther\r\n      : state.options.bulletOther)\r\n  ) {\r\n    return false\r\n  }\r\n\r\n  // Join children of a list or an item.\r\n  // In which case, `parent` has a `spread` field.\r\n  if ('spread' in parent && typeof parent.spread === 'boolean') {\r\n    if (\r\n      left.type === 'paragraph' &&\r\n      // Two paragraphs.\r\n      (left.type === right.type ||\r\n        right.type === 'definition' ||\r\n        // Paragraph followed by a setext heading.\r\n        (right.type === 'heading' && formatHeadingAsSetext(right, state)))\r\n    ) {\r\n      return\r\n    }\r\n\r\n    return parent.spread ? 1 : 0\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('./types.js').Unsafe} Unsafe\r\n * @typedef {import('./types.js').ConstructName} ConstructName\r\n */\r\n\r\n/**\r\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\r\n * contain things like attention (emphasis, strong), images, or links.\r\n * So they sort of cancel each other out.\r\n * Note: could use a better name.\r\n *\r\n * @type {Array<ConstructName>}\r\n */\r\nconst fullPhrasingSpans = [\r\n  'autolink',\r\n  'destinationLiteral',\r\n  'destinationRaw',\r\n  'reference',\r\n  'titleQuote',\r\n  'titleApostrophe'\r\n]\r\n\r\n/** @type {Array<Unsafe>} */\r\nexport const unsafe = [\r\n  {character: '\\t', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\r\n  {character: '\\t', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\r\n  {\r\n    character: '\\t',\r\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\r\n  },\r\n  {\r\n    character: '\\r',\r\n    inConstruct: [\r\n      'codeFencedLangGraveAccent',\r\n      'codeFencedLangTilde',\r\n      'codeFencedMetaGraveAccent',\r\n      'codeFencedMetaTilde',\r\n      'destinationLiteral',\r\n      'headingAtx'\r\n    ]\r\n  },\r\n  {\r\n    character: '\\n',\r\n    inConstruct: [\r\n      'codeFencedLangGraveAccent',\r\n      'codeFencedLangTilde',\r\n      'codeFencedMetaGraveAccent',\r\n      'codeFencedMetaTilde',\r\n      'destinationLiteral',\r\n      'headingAtx'\r\n    ]\r\n  },\r\n  {character: ' ', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\r\n  {character: ' ', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\r\n  {\r\n    character: ' ',\r\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\r\n  },\r\n  // An exclamation mark can start an image, if it is followed by a link or\r\n  // a link reference.\r\n  {\r\n    character: '!',\r\n    after: '\\\\[',\r\n    inConstruct: 'phrasing',\r\n    notInConstruct: fullPhrasingSpans\r\n  },\r\n  // A quote can break out of a title.\r\n  {character: '\"', inConstruct: 'titleQuote'},\r\n  // A number sign could start an ATX heading if it starts a line.\r\n  {atBreak: true, character: '#'},\r\n  {character: '#', inConstruct: 'headingAtx', after: '(?:[\\r\\n]|$)'},\r\n  // Dollar sign and percentage are not used in markdown.\r\n  // An ampersand could start a character reference.\r\n  {character: '&', after: '[#A-Za-z]', inConstruct: 'phrasing'},\r\n  // An apostrophe can break out of a title.\r\n  {character: \"'\", inConstruct: 'titleApostrophe'},\r\n  // A left paren could break out of a destination raw.\r\n  {character: '(', inConstruct: 'destinationRaw'},\r\n  // A left paren followed by `]` could make something into a link or image.\r\n  {\r\n    before: '\\\\]',\r\n    character: '(',\r\n    inConstruct: 'phrasing',\r\n    notInConstruct: fullPhrasingSpans\r\n  },\r\n  // A right paren could start a list item or break out of a destination\r\n  // raw.\r\n  {atBreak: true, before: '\\\\d+', character: ')'},\r\n  {character: ')', inConstruct: 'destinationRaw'},\r\n  // An asterisk can start thematic breaks, list items, emphasis, strong.\r\n  {atBreak: true, character: '*', after: '(?:[ \\t\\r\\n*])'},\r\n  {character: '*', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\r\n  // A plus sign could start a list item.\r\n  {atBreak: true, character: '+', after: '(?:[ \\t\\r\\n])'},\r\n  // A dash can start thematic breaks, list items, and setext heading\r\n  // underlines.\r\n  {atBreak: true, character: '-', after: '(?:[ \\t\\r\\n-])'},\r\n  // A dot could start a list item.\r\n  {atBreak: true, before: '\\\\d+', character: '.', after: '(?:[ \\t\\r\\n]|$)'},\r\n  // Slash, colon, and semicolon are not used in markdown for constructs.\r\n  // A less than can start html (flow or text) or an autolink.\r\n  // HTML could start with an exclamation mark (declaration, cdata, comment),\r\n  // slash (closing tag), question mark (instruction), or a letter (tag).\r\n  // An autolink also starts with a letter.\r\n  // Finally, it could break out of a destination literal.\r\n  {atBreak: true, character: '<', after: '[!/?A-Za-z]'},\r\n  {\r\n    character: '<',\r\n    after: '[!/?A-Za-z]',\r\n    inConstruct: 'phrasing',\r\n    notInConstruct: fullPhrasingSpans\r\n  },\r\n  {character: '<', inConstruct: 'destinationLiteral'},\r\n  // An equals to can start setext heading underlines.\r\n  {atBreak: true, character: '='},\r\n  // A greater than can start block quotes and it can break out of a\r\n  // destination literal.\r\n  {atBreak: true, character: '>'},\r\n  {character: '>', inConstruct: 'destinationLiteral'},\r\n  // Question mark and at sign are not used in markdown for constructs.\r\n  // A left bracket can start definitions, references, labels,\r\n  {atBreak: true, character: '['},\r\n  {character: '[', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\r\n  {character: '[', inConstruct: ['label', 'reference']},\r\n  // A backslash can start an escape (when followed by punctuation) or a\r\n  // hard break (when followed by an eol).\r\n  // Note: typical escapes are handled in `safe`!\r\n  {character: '\\\\', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\r\n  // A right bracket can exit labels.\r\n  {character: ']', inConstruct: ['label', 'reference']},\r\n  // Caret is not used in markdown for constructs.\r\n  // An underscore can start emphasis, strong, or a thematic break.\r\n  {atBreak: true, character: '_'},\r\n  {character: '_', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\r\n  // A grave accent can start code (fenced or text), or it can break out of\r\n  // a grave accent code fence.\r\n  {atBreak: true, character: '`'},\r\n  {\r\n    character: '`',\r\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedMetaGraveAccent']\r\n  },\r\n  {character: '`', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\r\n  // Left brace, vertical bar, right brace are not used in markdown for\r\n  // constructs.\r\n  // A tilde can start code (fenced).\r\n  {atBreak: true, character: '~'}\r\n]\r\n", "/**\r\n * @typedef {import('./types.js').Enter} Enter\r\n * @typedef {import('./types.js').Info} Info\r\n * @typedef {import('./types.js').Join} Join\r\n * @typedef {import('./types.js').FlowContent} FlowContent\r\n * @typedef {import('./types.js').Node} Node\r\n * @typedef {import('./types.js').Options} Options\r\n * @typedef {import('./types.js').Parent} Parent\r\n * @typedef {import('./types.js').PhrasingContent} PhrasingContent\r\n * @typedef {import('./types.js').SafeConfig} SafeConfig\r\n * @typedef {import('./types.js').State} State\r\n * @typedef {import('./types.js').TrackFields} TrackFields\r\n */\r\n\r\nimport {zwitch} from 'zwitch'\r\nimport {configure} from './configure.js'\r\nimport {handle as handlers} from './handle/index.js'\r\nimport {join} from './join.js'\r\nimport {unsafe} from './unsafe.js'\r\nimport {association} from './util/association.js'\r\nimport {containerPhrasing} from './util/container-phrasing.js'\r\nimport {containerFlow} from './util/container-flow.js'\r\nimport {indentLines} from './util/indent-lines.js'\r\nimport {safe} from './util/safe.js'\r\nimport {track} from './util/track.js'\r\n\r\n/**\r\n * Turn an mdast syntax tree into markdown.\r\n *\r\n * @param {Node} tree\r\n *   Tree to serialize.\r\n * @param {Options} [options]\r\n *   Configuration (optional).\r\n * @returns {string}\r\n *   Serialized markdown representing `tree`.\r\n */\r\nexport function toMarkdown(tree, options = {}) {\r\n  /** @type {State} */\r\n  const state = {\r\n    enter,\r\n    indentLines,\r\n    associationId: association,\r\n    containerPhrasing: containerPhrasingBound,\r\n    containerFlow: containerFlowBound,\r\n    createTracker: track,\r\n    safe: safeBound,\r\n    stack: [],\r\n    unsafe: [],\r\n    join: [],\r\n    // @ts-expect-error: we’ll fill it next.\r\n    handlers: {},\r\n    options: {},\r\n    indexStack: [],\r\n    // @ts-expect-error: we’ll add `handle` later.\r\n    handle: undefined\r\n  }\r\n\r\n  configure(state, {unsafe, join, handlers})\r\n  configure(state, options)\r\n\r\n  if (state.options.tightDefinitions) {\r\n    configure(state, {join: [joinDefinition]})\r\n  }\r\n\r\n  state.handle = zwitch('type', {\r\n    invalid,\r\n    unknown,\r\n    handlers: state.handlers\r\n  })\r\n\r\n  let result = state.handle(tree, undefined, state, {\r\n    before: '\\n',\r\n    after: '\\n',\r\n    now: {line: 1, column: 1},\r\n    lineShift: 0\r\n  })\r\n\r\n  if (\r\n    result &&\r\n    result.charCodeAt(result.length - 1) !== 10 &&\r\n    result.charCodeAt(result.length - 1) !== 13\r\n  ) {\r\n    result += '\\n'\r\n  }\r\n\r\n  return result\r\n\r\n  /** @type {Enter} */\r\n  function enter(name) {\r\n    state.stack.push(name)\r\n    return exit\r\n\r\n    function exit() {\r\n      state.stack.pop()\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {unknown} value\r\n * @returns {never}\r\n */\r\nfunction invalid(value) {\r\n  throw new Error('Cannot handle value `' + value + '`, expected node')\r\n}\r\n\r\n/**\r\n * @param {unknown} node\r\n * @returns {never}\r\n */\r\nfunction unknown(node) {\r\n  // @ts-expect-error: fine.\r\n  throw new Error('Cannot handle unknown node `' + node.type + '`')\r\n}\r\n\r\n/** @type {Join} */\r\nfunction joinDefinition(left, right) {\r\n  // No blank line between adjacent definitions.\r\n  if (left.type === 'definition' && left.type === right.type) {\r\n    return 0\r\n  }\r\n}\r\n\r\n/**\r\n * Serialize the children of a parent that contains phrasing children.\r\n *\r\n * These children will be joined flush together.\r\n *\r\n * @this {State}\r\n *   Info passed around about the current state.\r\n * @param {Parent & {children: Array<PhrasingContent>}} parent\r\n *   Parent of flow nodes.\r\n * @param {Info} info\r\n *   Info on where we are in the document we are generating.\r\n * @returns {string}\r\n *   Serialized children, joined together.\r\n */\r\nfunction containerPhrasingBound(parent, info) {\r\n  return containerPhrasing(parent, this, info)\r\n}\r\n\r\n/**\r\n * Serialize the children of a parent that contains flow children.\r\n *\r\n * These children will typically be joined by blank lines.\r\n * What they are joined by exactly is defined by `Join` functions.\r\n *\r\n * @this {State}\r\n *   Info passed around about the current state.\r\n * @param {Parent & {children: Array<FlowContent>}} parent\r\n *   Parent of flow nodes.\r\n * @param {TrackFields} info\r\n *   Info on where we are in the document we are generating.\r\n * @returns {string}\r\n *   Serialized children, joined by (blank) lines.\r\n */\r\nfunction containerFlowBound(parent, info) {\r\n  return containerFlow(parent, this, info)\r\n}\r\n\r\n/**\r\n * Make a string safe for embedding in markdown constructs.\r\n *\r\n * In markdown, almost all punctuation characters can, in certain cases,\r\n * result in something.\r\n * Whether they do is highly subjective to where they happen and in what\r\n * they happen.\r\n *\r\n * To solve this, `mdast-util-to-markdown` tracks:\r\n *\r\n * * Characters before and after something;\r\n * * What “constructs” we are in.\r\n *\r\n * This information is then used by this function to escape or encode\r\n * special characters.\r\n *\r\n * @this {State}\r\n *   Info passed around about the current state.\r\n * @param {string | null | undefined} value\r\n *   Raw value to make safe.\r\n * @param {SafeConfig} config\r\n *   Configuration.\r\n * @returns {string}\r\n *   Serialized markdown safe for embedding.\r\n */\r\nfunction safeBound(value, config) {\r\n  return safe(this, value, config)\r\n}\r\n", "/**\r\n * @typedef {import('mdast').Root|import('mdast').Content} Node\r\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownOptions\r\n * @typedef {Omit<ToMarkdownOptions, 'extensions'>} Options\r\n */\r\n\r\nimport {toMarkdown} from 'mdast-util-to-markdown'\r\n\r\n/**\r\n * @this {import('unified').Processor}\r\n * @type {import('unified').Plugin<[Options?]|void[], Node, string>}\r\n */\r\nexport default function remarkStringify(options) {\r\n  /** @type {import('unified').CompilerFunction<Node, string>} */\r\n  const compiler = (tree) => {\r\n    // Assume options.\r\n    const settings = /** @type {Options} */ (this.data('settings'))\r\n\r\n    return toMarkdown(\r\n      tree,\r\n      Object.assign({}, settings, options, {\r\n        // Note: this option is not in the readme.\r\n        // The goal is for it to be set by plugins on `data` instead of being\r\n        // passed by users.\r\n        extensions:\r\n          /** @type {ToMarkdownOptions['extensions']} */ (\r\n            this.data('toMarkdownExtensions')\r\n          ) || []\r\n      })\r\n    )\r\n  }\r\n\r\n  Object.assign(this, {Compiler: compiler})\r\n}\r\n"],
  "mappings": "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",
  "names": ["exit", "value", "map", "node", "exit", "subexit", "value", "value", "text"]
}
