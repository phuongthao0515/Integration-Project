{
  "version": 3,
  "sources": ["../../html-void-elements/index.js", "../../hast-util-to-html/lib/handle/comment.js", "../../hast-util-to-html/lib/handle/doctype.js", "../../hast-util-to-html/node_modules/hast-util-whitespace/index.js", "../../hast-util-to-html/lib/omission/util/siblings.js", "../../hast-util-to-html/lib/omission/omission.js", "../../hast-util-to-html/lib/omission/closing.js", "../../hast-util-to-html/lib/omission/opening.js", "../../hast-util-to-html/lib/handle/element.js", "../../hast-util-to-html/lib/handle/text.js", "../../hast-util-to-html/lib/handle/raw.js", "../../hast-util-to-html/lib/handle/root.js", "../../hast-util-to-html/lib/handle/index.js", "../../hast-util-to-html/lib/index.js", "../../rehype-stringify/lib/index.js"],
  "sourcesContent": ["/**\r\n * List of HTML void tag names.\r\n *\r\n * @type {Array<string>}\r\n */\r\nexport const htmlVoidElements = [\r\n  'area',\r\n  'base',\r\n  'basefont',\r\n  'bgsound',\r\n  'br',\r\n  'col',\r\n  'command',\r\n  'embed',\r\n  'frame',\r\n  'hr',\r\n  'image',\r\n  'img',\r\n  'input',\r\n  'isindex',\r\n  'keygen',\r\n  'link',\r\n  'menuitem',\r\n  'meta',\r\n  'nextid',\r\n  'param',\r\n  'source',\r\n  'track',\r\n  'wbr'\r\n]\r\n", "/**\r\n * @typedef {import('../types.js').Comment} Comment\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').State} State\r\n */\r\n\r\nimport {stringifyEntities} from 'stringify-entities'\r\n\r\n/**\r\n * Serialize a comment.\r\n *\r\n * @param {Comment} node\r\n *   Node to handle.\r\n * @param {number | undefined} _1\r\n *   Index of `node` in `parent.\r\n * @param {Parent | undefined} _2\r\n *   Parent of `node`.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {string}\r\n *   Serialized node.\r\n */\r\nexport function comment(node, _1, _2, state) {\r\n  // See: <https://html.spec.whatwg.org/multipage/syntax.html#comments>\r\n  return state.settings.bogusComments\r\n    ? '<?' +\r\n        stringifyEntities(\r\n          node.value,\r\n          Object.assign({}, state.settings.characterReferences, {subset: ['>']})\r\n        ) +\r\n        '>'\r\n    : '<!--' + node.value.replace(/^>|^->|<!--|-->|--!>|<!-$/g, encode) + '-->'\r\n\r\n  /**\r\n   * @param {string} $0\r\n   */\r\n  function encode($0) {\r\n    return stringifyEntities(\r\n      $0,\r\n      Object.assign({}, state.settings.characterReferences, {\r\n        subset: ['<', '>']\r\n      })\r\n    )\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').DocType} DocType\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').State} State\r\n */\r\n\r\n/**\r\n * Serialize a doctype.\r\n *\r\n * @param {DocType} _1\r\n *   Node to handle.\r\n * @param {number | undefined} _2\r\n *   Index of `node` in `parent.\r\n * @param {Parent | undefined} _3\r\n *   Parent of `node`.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {string}\r\n *   Serialized node.\r\n */\r\nexport function doctype(_1, _2, _3, state) {\r\n  return (\r\n    '<!' +\r\n    (state.settings.upperDoctype ? 'DOCTYPE' : 'doctype') +\r\n    (state.settings.tightDoctype ? '' : ' ') +\r\n    'html>'\r\n  )\r\n}\r\n", "/**\r\n * Check if the given value is *inter-element whitespace*.\r\n *\r\n * @param {unknown} thing\r\n *   Thing to check (typically `Node` or `string`).\r\n * @returns {boolean}\r\n *   Whether the `value` is inter-element whitespace (`boolean`): consisting of\r\n *   zero or more of space, tab (`\\t`), line feed (`\\n`), carriage return\r\n *   (`\\r`), or form feed (`\\f`).\r\n *   If a node is passed it must be a `Text` node, whose `value` field is\r\n *   checked.\r\n */\r\nexport function whitespace(thing) {\r\n  /** @type {string} */\r\n  const value =\r\n    // @ts-expect-error looks like a node.\r\n    thing && typeof thing === 'object' && thing.type === 'text'\r\n      ? // @ts-expect-error looks like a text.\r\n        thing.value || ''\r\n      : thing\r\n\r\n  // HTML whitespace expression.\r\n  // See <https://infra.spec.whatwg.org/#ascii-whitespace>.\r\n  return typeof value === 'string' && value.replace(/[ \\t\\n\\f\\r]/g, '') === ''\r\n}\r\n", "/**\r\n * @typedef {import('../../types.js').Parent} Parent\r\n * @typedef {import('../../types.js').Content} Content\r\n */\r\n\r\nimport {whitespace} from 'hast-util-whitespace'\r\n\r\nexport const siblingAfter = siblings(1)\r\nexport const siblingBefore = siblings(-1)\r\n\r\n/**\r\n * Factory to check siblings in a direction.\r\n *\r\n * @param {number} increment\r\n */\r\nfunction siblings(increment) {\r\n  return sibling\r\n\r\n  /**\r\n   * Find applicable siblings in a direction.\r\n   *\r\n   * @param {Parent | null | undefined} parent\r\n   * @param {number | null | undefined} index\r\n   * @param {boolean | null | undefined} [includeWhitespace=false]\r\n   * @returns {Content}\r\n   */\r\n  function sibling(parent, index, includeWhitespace) {\r\n    const siblings = parent ? parent.children : []\r\n    let offset = (index || 0) + increment\r\n    let next = siblings && siblings[offset]\r\n\r\n    if (!includeWhitespace) {\r\n      while (next && whitespace(next)) {\r\n        offset += increment\r\n        next = siblings[offset]\r\n      }\r\n    }\r\n\r\n    return next\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').OmitHandle} OmitHandle\r\n */\r\n\r\nconst own = {}.hasOwnProperty\r\n\r\n/**\r\n * Factory to check if a given node can have a tag omitted.\r\n *\r\n * @param {Record<string, OmitHandle>} handlers\r\n *   Omission handlers, where each key is a tag name, and each value is the\r\n *   corresponding handler.\r\n * @returns {OmitHandle}\r\n *   Whether to omit a tag of an element.\r\n */\r\nexport function omission(handlers) {\r\n  return omit\r\n\r\n  /**\r\n   * Check if a given node can have a tag omitted.\r\n   *\r\n   * @type {OmitHandle}\r\n   */\r\n  function omit(node, index, parent) {\r\n    return (\r\n      own.call(handlers, node.tagName) &&\r\n      handlers[node.tagName](node, index, parent)\r\n    )\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').Element} Element\r\n * @typedef {import('../types.js').Parent} Parent\r\n */\r\n\r\nimport {whitespace} from 'hast-util-whitespace'\r\nimport {siblingAfter} from './util/siblings.js'\r\nimport {omission} from './omission.js'\r\n\r\nexport const closing = omission({\r\n  html,\r\n  head: headOrColgroupOrCaption,\r\n  body,\r\n  p,\r\n  li,\r\n  dt,\r\n  dd,\r\n  rt: rubyElement,\r\n  rp: rubyElement,\r\n  optgroup,\r\n  option,\r\n  menuitem,\r\n  colgroup: headOrColgroupOrCaption,\r\n  caption: headOrColgroupOrCaption,\r\n  thead,\r\n  tbody,\r\n  tfoot,\r\n  tr,\r\n  td: cells,\r\n  th: cells\r\n})\r\n\r\n/**\r\n * Macro for `</head>`, `</colgroup>`, and `</caption>`.\r\n *\r\n * @param {Element} _\r\n *   Element.\r\n * @param {number | undefined} index\r\n *   Index of element in parent.\r\n * @param {Parent | undefined} parent\r\n *   Parent of element.\r\n * @returns {boolean}\r\n *   Whether the closing tag can be omitted.\r\n */\r\nfunction headOrColgroupOrCaption(_, index, parent) {\r\n  const next = siblingAfter(parent, index, true)\r\n  return (\r\n    !next ||\r\n    (next.type !== 'comment' &&\r\n      !(next.type === 'text' && whitespace(next.value.charAt(0))))\r\n  )\r\n}\r\n\r\n/**\r\n * Whether to omit `</html>`.\r\n *\r\n * @param {Element} _\r\n *   Element.\r\n * @param {number | undefined} index\r\n *   Index of element in parent.\r\n * @param {Parent | undefined} parent\r\n *   Parent of element.\r\n * @returns {boolean}\r\n *   Whether the closing tag can be omitted.\r\n */\r\nfunction html(_, index, parent) {\r\n  const next = siblingAfter(parent, index)\r\n  return !next || next.type !== 'comment'\r\n}\r\n\r\n/**\r\n * Whether to omit `</body>`.\r\n *\r\n * @param {Element} _\r\n *   Element.\r\n * @param {number | undefined} index\r\n *   Index of element in parent.\r\n * @param {Parent | undefined} parent\r\n *   Parent of element.\r\n * @returns {boolean}\r\n *   Whether the closing tag can be omitted.\r\n */\r\nfunction body(_, index, parent) {\r\n  const next = siblingAfter(parent, index)\r\n  return !next || next.type !== 'comment'\r\n}\r\n\r\n/**\r\n * Whether to omit `</p>`.\r\n *\r\n * @param {Element} _\r\n *   Element.\r\n * @param {number | undefined} index\r\n *   Index of element in parent.\r\n * @param {Parent | undefined} parent\r\n *   Parent of element.\r\n * @returns {boolean}\r\n *   Whether the closing tag can be omitted.\r\n */\r\n// eslint-disable-next-line complexity\r\nfunction p(_, index, parent) {\r\n  const next = siblingAfter(parent, index)\r\n  return next\r\n    ? next.type === 'element' &&\r\n        (next.tagName === 'address' ||\r\n          next.tagName === 'article' ||\r\n          next.tagName === 'aside' ||\r\n          next.tagName === 'blockquote' ||\r\n          next.tagName === 'details' ||\r\n          next.tagName === 'div' ||\r\n          next.tagName === 'dl' ||\r\n          next.tagName === 'fieldset' ||\r\n          next.tagName === 'figcaption' ||\r\n          next.tagName === 'figure' ||\r\n          next.tagName === 'footer' ||\r\n          next.tagName === 'form' ||\r\n          next.tagName === 'h1' ||\r\n          next.tagName === 'h2' ||\r\n          next.tagName === 'h3' ||\r\n          next.tagName === 'h4' ||\r\n          next.tagName === 'h5' ||\r\n          next.tagName === 'h6' ||\r\n          next.tagName === 'header' ||\r\n          next.tagName === 'hgroup' ||\r\n          next.tagName === 'hr' ||\r\n          next.tagName === 'main' ||\r\n          next.tagName === 'menu' ||\r\n          next.tagName === 'nav' ||\r\n          next.tagName === 'ol' ||\r\n          next.tagName === 'p' ||\r\n          next.tagName === 'pre' ||\r\n          next.tagName === 'section' ||\r\n          next.tagName === 'table' ||\r\n          next.tagName === 'ul')\r\n    : !parent ||\r\n        // Confusing parent.\r\n        !(\r\n          parent.type === 'element' &&\r\n          (parent.tagName === 'a' ||\r\n            parent.tagName === 'audio' ||\r\n            parent.tagName === 'del' ||\r\n            parent.tagName === 'ins' ||\r\n            parent.tagName === 'map' ||\r\n            parent.tagName === 'noscript' ||\r\n            parent.tagName === 'video')\r\n        )\r\n}\r\n\r\n/**\r\n * Whether to omit `</li>`.\r\n *\r\n * @param {Element} _\r\n *   Element.\r\n * @param {number | undefined} index\r\n *   Index of element in parent.\r\n * @param {Parent | undefined} parent\r\n *   Parent of element.\r\n * @returns {boolean}\r\n *   Whether the closing tag can be omitted.\r\n */\r\nfunction li(_, index, parent) {\r\n  const next = siblingAfter(parent, index)\r\n  return !next || (next.type === 'element' && next.tagName === 'li')\r\n}\r\n\r\n/**\r\n * Whether to omit `</dt>`.\r\n *\r\n * @param {Element} _\r\n *   Element.\r\n * @param {number | undefined} index\r\n *   Index of element in parent.\r\n * @param {Parent | undefined} parent\r\n *   Parent of element.\r\n * @returns {boolean}\r\n *   Whether the closing tag can be omitted.\r\n */\r\nfunction dt(_, index, parent) {\r\n  const next = siblingAfter(parent, index)\r\n  return (\r\n    next &&\r\n    next.type === 'element' &&\r\n    (next.tagName === 'dt' || next.tagName === 'dd')\r\n  )\r\n}\r\n\r\n/**\r\n * Whether to omit `</dd>`.\r\n *\r\n * @param {Element} _\r\n *   Element.\r\n * @param {number | undefined} index\r\n *   Index of element in parent.\r\n * @param {Parent | undefined} parent\r\n *   Parent of element.\r\n * @returns {boolean}\r\n *   Whether the closing tag can be omitted.\r\n */\r\nfunction dd(_, index, parent) {\r\n  const next = siblingAfter(parent, index)\r\n  return (\r\n    !next ||\r\n    (next.type === 'element' &&\r\n      (next.tagName === 'dt' || next.tagName === 'dd'))\r\n  )\r\n}\r\n\r\n/**\r\n * Whether to omit `</rt>` or `</rp>`.\r\n *\r\n * @param {Element} _\r\n *   Element.\r\n * @param {number | undefined} index\r\n *   Index of element in parent.\r\n * @param {Parent | undefined} parent\r\n *   Parent of element.\r\n * @returns {boolean}\r\n *   Whether the closing tag can be omitted.\r\n */\r\nfunction rubyElement(_, index, parent) {\r\n  const next = siblingAfter(parent, index)\r\n  return (\r\n    !next ||\r\n    (next.type === 'element' &&\r\n      (next.tagName === 'rp' || next.tagName === 'rt'))\r\n  )\r\n}\r\n\r\n/**\r\n * Whether to omit `</optgroup>`.\r\n *\r\n * @param {Element} _\r\n *   Element.\r\n * @param {number | undefined} index\r\n *   Index of element in parent.\r\n * @param {Parent | undefined} parent\r\n *   Parent of element.\r\n * @returns {boolean}\r\n *   Whether the closing tag can be omitted.\r\n */\r\nfunction optgroup(_, index, parent) {\r\n  const next = siblingAfter(parent, index)\r\n  return !next || (next.type === 'element' && next.tagName === 'optgroup')\r\n}\r\n\r\n/**\r\n * Whether to omit `</option>`.\r\n *\r\n * @param {Element} _\r\n *   Element.\r\n * @param {number | undefined} index\r\n *   Index of element in parent.\r\n * @param {Parent | undefined} parent\r\n *   Parent of element.\r\n * @returns {boolean}\r\n *   Whether the closing tag can be omitted.\r\n */\r\nfunction option(_, index, parent) {\r\n  const next = siblingAfter(parent, index)\r\n  return (\r\n    !next ||\r\n    (next.type === 'element' &&\r\n      (next.tagName === 'option' || next.tagName === 'optgroup'))\r\n  )\r\n}\r\n\r\n/**\r\n * Whether to omit `</menuitem>`.\r\n *\r\n * @param {Element} _\r\n *   Element.\r\n * @param {number | undefined} index\r\n *   Index of element in parent.\r\n * @param {Parent | undefined} parent\r\n *   Parent of element.\r\n * @returns {boolean}\r\n *   Whether the closing tag can be omitted.\r\n */\r\nfunction menuitem(_, index, parent) {\r\n  const next = siblingAfter(parent, index)\r\n  return (\r\n    !next ||\r\n    (next.type === 'element' &&\r\n      (next.tagName === 'menuitem' ||\r\n        next.tagName === 'hr' ||\r\n        next.tagName === 'menu'))\r\n  )\r\n}\r\n\r\n/**\r\n * Whether to omit `</thead>`.\r\n *\r\n * @param {Element} _\r\n *   Element.\r\n * @param {number | undefined} index\r\n *   Index of element in parent.\r\n * @param {Parent | undefined} parent\r\n *   Parent of element.\r\n * @returns {boolean}\r\n *   Whether the closing tag can be omitted.\r\n */\r\nfunction thead(_, index, parent) {\r\n  const next = siblingAfter(parent, index)\r\n  return (\r\n    next &&\r\n    next.type === 'element' &&\r\n    (next.tagName === 'tbody' || next.tagName === 'tfoot')\r\n  )\r\n}\r\n\r\n/**\r\n * Whether to omit `</tbody>`.\r\n *\r\n * @param {Element} _\r\n *   Element.\r\n * @param {number | undefined} index\r\n *   Index of element in parent.\r\n * @param {Parent | undefined} parent\r\n *   Parent of element.\r\n * @returns {boolean}\r\n *   Whether the closing tag can be omitted.\r\n */\r\nfunction tbody(_, index, parent) {\r\n  const next = siblingAfter(parent, index)\r\n  return (\r\n    !next ||\r\n    (next.type === 'element' &&\r\n      (next.tagName === 'tbody' || next.tagName === 'tfoot'))\r\n  )\r\n}\r\n\r\n/**\r\n * Whether to omit `</tfoot>`.\r\n *\r\n * @param {Element} _\r\n *   Element.\r\n * @param {number | undefined} index\r\n *   Index of element in parent.\r\n * @param {Parent | undefined} parent\r\n *   Parent of element.\r\n * @returns {boolean}\r\n *   Whether the closing tag can be omitted.\r\n */\r\nfunction tfoot(_, index, parent) {\r\n  return !siblingAfter(parent, index)\r\n}\r\n\r\n/**\r\n * Whether to omit `</tr>`.\r\n *\r\n * @param {Element} _\r\n *   Element.\r\n * @param {number | undefined} index\r\n *   Index of element in parent.\r\n * @param {Parent | undefined} parent\r\n *   Parent of element.\r\n * @returns {boolean}\r\n *   Whether the closing tag can be omitted.\r\n */\r\nfunction tr(_, index, parent) {\r\n  const next = siblingAfter(parent, index)\r\n  return !next || (next.type === 'element' && next.tagName === 'tr')\r\n}\r\n\r\n/**\r\n * Whether to omit `</td>` or `</th>`.\r\n *\r\n * @param {Element} _\r\n *   Element.\r\n * @param {number | undefined} index\r\n *   Index of element in parent.\r\n * @param {Parent | undefined} parent\r\n *   Parent of element.\r\n * @returns {boolean}\r\n *   Whether the closing tag can be omitted.\r\n */\r\nfunction cells(_, index, parent) {\r\n  const next = siblingAfter(parent, index)\r\n  return (\r\n    !next ||\r\n    (next.type === 'element' &&\r\n      (next.tagName === 'td' || next.tagName === 'th'))\r\n  )\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').Element} Element\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').Content} Content\r\n */\r\n\r\nimport {whitespace} from 'hast-util-whitespace'\r\nimport {siblingBefore, siblingAfter} from './util/siblings.js'\r\nimport {closing} from './closing.js'\r\nimport {omission} from './omission.js'\r\n\r\nexport const opening = omission({\r\n  html,\r\n  head,\r\n  body,\r\n  colgroup,\r\n  tbody\r\n})\r\n\r\n/**\r\n * Whether to omit `<html>`.\r\n *\r\n * @param {Element} node\r\n *   Element.\r\n * @returns {boolean}\r\n *   Whether the opening tag can be omitted.\r\n */\r\nfunction html(node) {\r\n  const head = siblingAfter(node, -1)\r\n  return !head || head.type !== 'comment'\r\n}\r\n\r\n/**\r\n * Whether to omit `<head>`.\r\n *\r\n * @param {Element} node\r\n *   Element.\r\n * @returns {boolean}\r\n *   Whether the opening tag can be omitted.\r\n */\r\nfunction head(node) {\r\n  const children = node.children\r\n  /** @type {Array<string>} */\r\n  const seen = []\r\n  let index = -1\r\n\r\n  while (++index < children.length) {\r\n    const child = children[index]\r\n    if (\r\n      child.type === 'element' &&\r\n      (child.tagName === 'title' || child.tagName === 'base')\r\n    ) {\r\n      if (seen.includes(child.tagName)) return false\r\n      seen.push(child.tagName)\r\n    }\r\n  }\r\n\r\n  return children.length > 0\r\n}\r\n\r\n/**\r\n * Whether to omit `<body>`.\r\n *\r\n * @param {Element} node\r\n *   Element.\r\n * @returns {boolean}\r\n *   Whether the opening tag can be omitted.\r\n */\r\nfunction body(node) {\r\n  const head = siblingAfter(node, -1, true)\r\n\r\n  return (\r\n    !head ||\r\n    (head.type !== 'comment' &&\r\n      !(head.type === 'text' && whitespace(head.value.charAt(0))) &&\r\n      !(\r\n        head.type === 'element' &&\r\n        (head.tagName === 'meta' ||\r\n          head.tagName === 'link' ||\r\n          head.tagName === 'script' ||\r\n          head.tagName === 'style' ||\r\n          head.tagName === 'template')\r\n      ))\r\n  )\r\n}\r\n\r\n/**\r\n * Whether to omit `<colgroup>`.\r\n * The spec describes some logic for the opening tag, but it’s easier to\r\n * implement in the closing tag, to the same effect, so we handle it there\r\n * instead.\r\n *\r\n * @param {Element} node\r\n *   Element.\r\n * @param {number | undefined} index\r\n *   Index of element in parent.\r\n * @param {Parent | undefined} parent\r\n *   Parent of element.\r\n * @returns {boolean}\r\n *   Whether the opening tag can be omitted.\r\n */\r\nfunction colgroup(node, index, parent) {\r\n  const previous = siblingBefore(parent, index)\r\n  const head = siblingAfter(node, -1, true)\r\n\r\n  // Previous colgroup was already omitted.\r\n  if (\r\n    parent &&\r\n    previous &&\r\n    previous.type === 'element' &&\r\n    previous.tagName === 'colgroup' &&\r\n    closing(previous, parent.children.indexOf(previous), parent)\r\n  ) {\r\n    return false\r\n  }\r\n\r\n  return head && head.type === 'element' && head.tagName === 'col'\r\n}\r\n\r\n/**\r\n * Whether to omit `<tbody>`.\r\n *\r\n * @param {Element} node\r\n *   Element.\r\n * @param {number | undefined} index\r\n *   Index of element in parent.\r\n * @param {Parent | undefined} parent\r\n *   Parent of element.\r\n * @returns {boolean}\r\n *   Whether the opening tag can be omitted.\r\n */\r\nfunction tbody(node, index, parent) {\r\n  const previous = siblingBefore(parent, index)\r\n  const head = siblingAfter(node, -1)\r\n\r\n  // Previous table section was already omitted.\r\n  if (\r\n    parent &&\r\n    previous &&\r\n    previous.type === 'element' &&\r\n    (previous.tagName === 'thead' || previous.tagName === 'tbody') &&\r\n    closing(previous, parent.children.indexOf(previous), parent)\r\n  ) {\r\n    return false\r\n  }\r\n\r\n  return head && head.type === 'element' && head.tagName === 'tr'\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').Element} Element\r\n * @typedef {import('../types.js').Properties} Properties\r\n * @typedef {import('../types.js').PropertyValue} PropertyValue\r\n */\r\n\r\nimport {ccount} from 'ccount'\r\nimport {stringify as commas} from 'comma-separated-tokens'\r\nimport {svg, find} from 'property-information'\r\nimport {stringify as spaces} from 'space-separated-tokens'\r\nimport {stringifyEntities} from 'stringify-entities'\r\nimport {opening} from '../omission/opening.js'\r\nimport {closing} from '../omission/closing.js'\r\n\r\n/**\r\n * Maps of subsets.\r\n *\r\n * Each value is a matrix of tuples.\r\n * The value at `0` causes parse errors, the value at `1` is valid.\r\n * Of both, the value at `0` is unsafe, and the value at `1` is safe.\r\n *\r\n * @type {Record<'name' | 'unquoted' | 'single' | 'double', Array<[Array<string>, Array<string>]>>}\r\n */\r\nconst constants = {\r\n  // See: <https://html.spec.whatwg.org/#attribute-name-state>.\r\n  name: [\r\n    ['\\t\\n\\f\\r &/=>'.split(''), '\\t\\n\\f\\r \"&\\'/=>`'.split('')],\r\n    ['\\0\\t\\n\\f\\r \"&\\'/<=>'.split(''), '\\0\\t\\n\\f\\r \"&\\'/<=>`'.split('')]\r\n  ],\r\n  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.\r\n  unquoted: [\r\n    ['\\t\\n\\f\\r &>'.split(''), '\\0\\t\\n\\f\\r \"&\\'<=>`'.split('')],\r\n    ['\\0\\t\\n\\f\\r \"&\\'<=>`'.split(''), '\\0\\t\\n\\f\\r \"&\\'<=>`'.split('')]\r\n  ],\r\n  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.\r\n  single: [\r\n    [\"&'\".split(''), '\"&\\'`'.split('')],\r\n    [\"\\0&'\".split(''), '\\0\"&\\'`'.split('')]\r\n  ],\r\n  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.\r\n  double: [\r\n    ['\"&'.split(''), '\"&\\'`'.split('')],\r\n    ['\\0\"&'.split(''), '\\0\"&\\'`'.split('')]\r\n  ]\r\n}\r\n\r\n/**\r\n * Serialize an element node.\r\n *\r\n * @param {Element} node\r\n *   Node to handle.\r\n * @param {number | undefined} index\r\n *   Index of `node` in `parent.\r\n * @param {Parent | undefined} parent\r\n *   Parent of `node`.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {string}\r\n *   Serialized node.\r\n */\r\n// eslint-disable-next-line complexity\r\nexport function element(node, index, parent, state) {\r\n  const schema = state.schema\r\n  const omit = schema.space === 'svg' ? false : state.settings.omitOptionalTags\r\n  let selfClosing =\r\n    schema.space === 'svg'\r\n      ? state.settings.closeEmptyElements\r\n      : state.settings.voids.includes(node.tagName.toLowerCase())\r\n  /** @type {Array<string>} */\r\n  const parts = []\r\n  /** @type {string} */\r\n  let last\r\n\r\n  if (schema.space === 'html' && node.tagName === 'svg') {\r\n    state.schema = svg\r\n  }\r\n\r\n  const attrs = serializeAttributes(state, node.properties)\r\n\r\n  const content = state.all(\r\n    schema.space === 'html' && node.tagName === 'template' ? node.content : node\r\n  )\r\n\r\n  state.schema = schema\r\n\r\n  // If the node is categorised as void, but it has children, remove the\r\n  // categorisation.\r\n  // This enables for example `menuitem`s, which are void in W3C HTML but not\r\n  // void in WHATWG HTML, to be stringified properly.\r\n  if (content) selfClosing = false\r\n\r\n  if (attrs || !omit || !opening(node, index, parent)) {\r\n    parts.push('<', node.tagName, attrs ? ' ' + attrs : '')\r\n\r\n    if (\r\n      selfClosing &&\r\n      (schema.space === 'svg' || state.settings.closeSelfClosing)\r\n    ) {\r\n      last = attrs.charAt(attrs.length - 1)\r\n      if (\r\n        !state.settings.tightSelfClosing ||\r\n        last === '/' ||\r\n        (last && last !== '\"' && last !== \"'\")\r\n      ) {\r\n        parts.push(' ')\r\n      }\r\n\r\n      parts.push('/')\r\n    }\r\n\r\n    parts.push('>')\r\n  }\r\n\r\n  parts.push(content)\r\n\r\n  if (!selfClosing && (!omit || !closing(node, index, parent))) {\r\n    parts.push('</' + node.tagName + '>')\r\n  }\r\n\r\n  return parts.join('')\r\n}\r\n\r\n/**\r\n * @param {State} state\r\n * @param {Properties | null | undefined} props\r\n * @returns {string}\r\n */\r\nfunction serializeAttributes(state, props) {\r\n  /** @type {Array<string>} */\r\n  const values = []\r\n  let index = -1\r\n  /** @type {string} */\r\n  let key\r\n\r\n  if (props) {\r\n    for (key in props) {\r\n      if (props[key] !== undefined && props[key] !== null) {\r\n        const value = serializeAttribute(state, key, props[key])\r\n        if (value) values.push(value)\r\n      }\r\n    }\r\n  }\r\n\r\n  while (++index < values.length) {\r\n    const last = state.settings.tightAttributes\r\n      ? values[index].charAt(values[index].length - 1)\r\n      : null\r\n\r\n    // In tight mode, don’t add a space after quoted attributes.\r\n    if (index !== values.length - 1 && last !== '\"' && last !== \"'\") {\r\n      values[index] += ' '\r\n    }\r\n  }\r\n\r\n  return values.join('')\r\n}\r\n\r\n/**\r\n * @param {State} state\r\n * @param {string} key\r\n * @param {PropertyValue} value\r\n * @returns {string}\r\n */\r\n// eslint-disable-next-line complexity\r\nfunction serializeAttribute(state, key, value) {\r\n  const info = find(state.schema, key)\r\n  const x =\r\n    state.settings.allowParseErrors && state.schema.space === 'html' ? 0 : 1\r\n  const y = state.settings.allowDangerousCharacters ? 0 : 1\r\n  let quote = state.quote\r\n  /** @type {string | undefined} */\r\n  let result\r\n\r\n  if (info.overloadedBoolean && (value === info.attribute || value === '')) {\r\n    value = true\r\n  } else if (\r\n    info.boolean ||\r\n    (info.overloadedBoolean && typeof value !== 'string')\r\n  ) {\r\n    value = Boolean(value)\r\n  }\r\n\r\n  if (\r\n    value === undefined ||\r\n    value === null ||\r\n    value === false ||\r\n    (typeof value === 'number' && Number.isNaN(value))\r\n  ) {\r\n    return ''\r\n  }\r\n\r\n  const name = stringifyEntities(\r\n    info.attribute,\r\n    Object.assign({}, state.settings.characterReferences, {\r\n      // Always encode without parse errors in non-HTML.\r\n      subset: constants.name[x][y]\r\n    })\r\n  )\r\n\r\n  // No value.\r\n  // There is currently only one boolean property in SVG: `[download]` on\r\n  // `<a>`.\r\n  // This property does not seem to work in browsers (Firefox, Safari, Chrome),\r\n  // so I can’t test if dropping the value works.\r\n  // But I assume that it should:\r\n  //\r\n  // ```html\r\n  // <!doctype html>\r\n  // <svg viewBox=\"0 0 100 100\">\r\n  //   <a href=https://example.com download>\r\n  //     <circle cx=50 cy=40 r=35 />\r\n  //   </a>\r\n  // </svg>\r\n  // ```\r\n  //\r\n  // See: <https://github.com/wooorm/property-information/blob/main/lib/svg.js>\r\n  if (value === true) return name\r\n\r\n  // `spaces` doesn’t accept a second argument, but it’s given here just to\r\n  // keep the code cleaner.\r\n  value = Array.isArray(value)\r\n    ? (info.commaSeparated ? commas : spaces)(value, {\r\n        padLeft: !state.settings.tightCommaSeparatedLists\r\n      })\r\n    : String(value)\r\n\r\n  if (state.settings.collapseEmptyAttributes && !value) return name\r\n\r\n  // Check unquoted value.\r\n  if (state.settings.preferUnquoted) {\r\n    result = stringifyEntities(\r\n      value,\r\n      Object.assign({}, state.settings.characterReferences, {\r\n        subset: constants.unquoted[x][y],\r\n        attribute: true\r\n      })\r\n    )\r\n  }\r\n\r\n  // If we don’t want unquoted, or if `value` contains character references when\r\n  // unquoted…\r\n  if (result !== value) {\r\n    // If the alternative is less common than `quote`, switch.\r\n    if (\r\n      state.settings.quoteSmart &&\r\n      ccount(value, quote) > ccount(value, state.alternative)\r\n    ) {\r\n      quote = state.alternative\r\n    }\r\n\r\n    result =\r\n      quote +\r\n      stringifyEntities(\r\n        value,\r\n        Object.assign({}, state.settings.characterReferences, {\r\n          // Always encode without parse errors in non-HTML.\r\n          subset: (quote === \"'\" ? constants.single : constants.double)[x][y],\r\n          attribute: true\r\n        })\r\n      ) +\r\n      quote\r\n  }\r\n\r\n  // Don’t add a `=` for unquoted empties.\r\n  return name + (result ? '=' + result : result)\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').Raw} Raw\r\n * @typedef {import('../types.js').Text} Text\r\n */\r\n\r\nimport {stringifyEntities} from 'stringify-entities'\r\n\r\n/**\r\n * Serialize a text node.\r\n *\r\n * @param {Text | Raw} node\r\n *   Node to handle.\r\n * @param {number | undefined} _\r\n *   Index of `node` in `parent.\r\n * @param {Parent | undefined} parent\r\n *   Parent of `node`.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {string}\r\n *   Serialized node.\r\n */\r\nexport function text(node, _, parent, state) {\r\n  // Check if content of `node` should be escaped.\r\n  return parent &&\r\n    parent.type === 'element' &&\r\n    (parent.tagName === 'script' || parent.tagName === 'style')\r\n    ? node.value\r\n    : stringifyEntities(\r\n        node.value,\r\n        Object.assign({}, state.settings.characterReferences, {\r\n          subset: ['<', '&']\r\n        })\r\n      )\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').Raw} Raw\r\n */\r\n\r\nimport {text} from './text.js'\r\n\r\n/**\r\n * Serialize a raw node.\r\n *\r\n * @param {Raw} node\r\n *   Node to handle.\r\n * @param {number | undefined} index\r\n *   Index of `node` in `parent.\r\n * @param {Parent | undefined} parent\r\n *   Parent of `node`.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {string}\r\n *   Serialized node.\r\n */\r\nexport function raw(node, index, parent, state) {\r\n  return state.settings.allowDangerousHtml\r\n    ? node.value\r\n    : text(node, index, parent, state)\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').Root} Root\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').State} State\r\n */\r\n\r\n/**\r\n * Serialize a root.\r\n *\r\n * @param {Root} node\r\n *   Node to handle.\r\n * @param {number | undefined} _1\r\n *   Index of `node` in `parent.\r\n * @param {Parent | undefined} _2\r\n *   Parent of `node`.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {string}\r\n *   Serialized node.\r\n */\r\nexport function root(node, _1, _2, state) {\r\n  return state.all(node)\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Node} Node\r\n * @typedef {import('../types.js').Parent} Parent\r\n */\r\n\r\nimport {zwitch} from 'zwitch'\r\nimport {comment} from './comment.js'\r\nimport {doctype} from './doctype.js'\r\nimport {element} from './element.js'\r\nimport {raw} from './raw.js'\r\nimport {root} from './root.js'\r\nimport {text} from './text.js'\r\n\r\n/**\r\n * @type {(node: Node, index: number | undefined, parent: Parent | undefined, state: State) => string}\r\n */\r\nexport const handle = zwitch('type', {\r\n  invalid,\r\n  unknown,\r\n  handlers: {comment, doctype, element, raw, root, text}\r\n})\r\n\r\n/**\r\n * Fail when a non-node is found in the tree.\r\n *\r\n * @param {unknown} node\r\n *   Unknown value.\r\n * @returns {never}\r\n *   Never.\r\n */\r\nfunction invalid(node) {\r\n  throw new Error('Expected node, not `' + node + '`')\r\n}\r\n\r\n/**\r\n * Fail when a node with an unknown type is found in the tree.\r\n *\r\n * @param {unknown} node\r\n *  Unknown node.\r\n * @returns {never}\r\n *   Never.\r\n */\r\nfunction unknown(node) {\r\n  // @ts-expect-error: `type` is defined.\r\n  throw new Error('Cannot compile unknown node `' + node.type + '`')\r\n}\r\n", "/**\r\n * @typedef {import('./types.js').Node} Node\r\n * @typedef {import('./types.js').Parent} Parent\r\n * @typedef {import('./types.js').Content} Content\r\n * @typedef {import('./types.js').Options} Options\r\n * @typedef {import('./types.js').State} State\r\n */\r\n\r\nimport {html, svg} from 'property-information'\r\nimport {htmlVoidElements} from 'html-void-elements'\r\nimport {handle} from './handle/index.js'\r\n\r\n/**\r\n * Serialize hast as HTML.\r\n *\r\n * @param {Node | Array<Content>} tree\r\n *   Tree to serialize.\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration.\r\n * @returns {string}\r\n *   Serialized HTML.\r\n */\r\n// eslint-disable-next-line complexity\r\nexport function toHtml(tree, options) {\r\n  const options_ = options || {}\r\n  const quote = options_.quote || '\"'\r\n  const alternative = quote === '\"' ? \"'\" : '\"'\r\n\r\n  if (quote !== '\"' && quote !== \"'\") {\r\n    throw new Error('Invalid quote `' + quote + '`, expected `\\'` or `\"`')\r\n  }\r\n\r\n  /** @type {State} */\r\n  const state = {\r\n    one,\r\n    all,\r\n    settings: {\r\n      omitOptionalTags: options_.omitOptionalTags || false,\r\n      allowParseErrors: options_.allowParseErrors || false,\r\n      allowDangerousCharacters: options_.allowDangerousCharacters || false,\r\n      quoteSmart: options_.quoteSmart || false,\r\n      preferUnquoted: options_.preferUnquoted || false,\r\n      tightAttributes: options_.tightAttributes || false,\r\n      upperDoctype: options_.upperDoctype || false,\r\n      tightDoctype: options_.tightDoctype || false,\r\n      bogusComments: options_.bogusComments || false,\r\n      tightCommaSeparatedLists: options_.tightCommaSeparatedLists || false,\r\n      tightSelfClosing: options_.tightSelfClosing || false,\r\n      collapseEmptyAttributes: options_.collapseEmptyAttributes || false,\r\n      allowDangerousHtml: options_.allowDangerousHtml || false,\r\n      voids: options_.voids || htmlVoidElements,\r\n      characterReferences:\r\n        options_.characterReferences || options_.entities || {},\r\n      closeSelfClosing: options_.closeSelfClosing || false,\r\n      closeEmptyElements: options_.closeEmptyElements || false\r\n    },\r\n    schema: options_.space === 'svg' ? svg : html,\r\n    quote,\r\n    alternative\r\n  }\r\n\r\n  return state.one(\r\n    Array.isArray(tree) ? {type: 'root', children: tree} : tree,\r\n    undefined,\r\n    undefined\r\n  )\r\n}\r\n\r\n/**\r\n * Serialize a node.\r\n *\r\n * @this {State}\r\n *   Info passed around about the current state.\r\n * @param {Node} node\r\n *   Node to handle.\r\n * @param {number | undefined} index\r\n *   Index of `node` in `parent.\r\n * @param {Parent | undefined} parent\r\n *   Parent of `node`.\r\n * @returns {string}\r\n *   Serialized node.\r\n */\r\nfunction one(node, index, parent) {\r\n  return handle(node, index, parent, this)\r\n}\r\n\r\n/**\r\n * Serialize all children of `parent`.\r\n *\r\n * @this {State}\r\n *   Info passed around about the current state.\r\n * @param {Parent | undefined} parent\r\n *   Parent whose children to serialize.\r\n * @returns {string}\r\n */\r\nexport function all(parent) {\r\n  /** @type {Array<string>} */\r\n  const results = []\r\n  const children = (parent && parent.children) || []\r\n  let index = -1\r\n\r\n  while (++index < children.length) {\r\n    results[index] = this.one(children[index], index, parent)\r\n  }\r\n\r\n  return results.join('')\r\n}\r\n", "/**\r\n * @typedef {import('hast').Root} Root\r\n * @typedef {Root|Root['children'][number]} Node\r\n * @typedef {import('hast-util-to-html').Options} Options\r\n */\r\n\r\nimport {toHtml} from 'hast-util-to-html'\r\n\r\n/**\r\n * @this {import('unified').Processor}\r\n * @type {import('unified').Plugin<[Options?]|Array<void>, Node, string>}\r\n */\r\nexport default function rehypeStringify(config) {\r\n  const processorSettings = /** @type {Options} */ (this.data('settings'))\r\n  const settings = Object.assign({}, processorSettings, config)\r\n\r\n  Object.assign(this, {Compiler: compiler})\r\n\r\n  /**\r\n   * @type {import('unified').CompilerFunction<Node, string>}\r\n   */\r\n  function compiler(tree) {\r\n    return toHtml(tree, settings)\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["siblings", "html", "html", "body", "tbody", "head", "stringify"]
}
