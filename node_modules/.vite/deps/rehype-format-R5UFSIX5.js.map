{
  "version": 3,
  "sources": ["../../hast-util-is-element/lib/index.js", "../../hast-util-embedded/lib/index.js", "../../unist-util-is/lib/index.js", "../../hast-util-minify-whitespace/lib/block.js", "../../hast-util-minify-whitespace/lib/content.js", "../../hast-util-minify-whitespace/lib/skippable.js", "../../hast-util-minify-whitespace/lib/index.js", "../../hast-util-has-property/lib/index.js", "../../hast-util-is-body-ok-link/lib/index.js", "../../hast-util-phrasing/lib/index.js", "../../html-whitespace-sensitive-tag-names/lib/index.js", "../../unist-util-visit-parents/lib/color.js", "../../unist-util-visit-parents/lib/index.js", "../../hast-util-format/lib/index.js", "../../rehype-format/lib/index.js"],
  "sourcesContent": ["/**\r\n * @typedef {import('hast').Element} Element\r\n * @typedef {import('hast').Parents} Parents\r\n */\r\n\r\n/**\r\n * @template Fn\r\n * @template Fallback\r\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\r\n */\r\n\r\n/**\r\n * @callback Check\r\n *   Check that an arbitrary value is an element.\r\n * @param {unknown} this\r\n *   Context object (`this`) to call `test` with\r\n * @param {unknown} [element]\r\n *   Anything (typically a node).\r\n * @param {number | null | undefined} [index]\r\n *   Position of `element` in its parent.\r\n * @param {Parents | null | undefined} [parent]\r\n *   Parent of `element`.\r\n * @returns {boolean}\r\n *   Whether this is an element and passes a test.\r\n *\r\n * @typedef {Array<TestFunction | string> | TestFunction | string | null | undefined} Test\r\n *   Check for an arbitrary element.\r\n *\r\n *   * when `string`, checks that the element has that tag name\r\n *   * when `function`, see `TestFunction`\r\n *   * when `Array`, checks if one of the subtests pass\r\n *\r\n * @callback TestFunction\r\n *   Check if an element passes a test.\r\n * @param {unknown} this\r\n *   The given context.\r\n * @param {Element} element\r\n *   An element.\r\n * @param {number | undefined} [index]\r\n *   Position of `element` in its parent.\r\n * @param {Parents | undefined} [parent]\r\n *   Parent of `element`.\r\n * @returns {boolean | undefined | void}\r\n *   Whether this element passes the test.\r\n *\r\n *   Note: `void` is included until TS sees no return as `undefined`.\r\n */\r\n\r\n/**\r\n * Check if `element` is an `Element` and whether it passes the given test.\r\n *\r\n * @param element\r\n *   Thing to check, typically `element`.\r\n * @param test\r\n *   Check for a specific element.\r\n * @param index\r\n *   Position of `element` in its parent.\r\n * @param parent\r\n *   Parent of `element`.\r\n * @param context\r\n *   Context object (`this`) to call `test` with.\r\n * @returns\r\n *   Whether `element` is an `Element` and passes a test.\r\n * @throws\r\n *   When an incorrect `test`, `index`, or `parent` is given; there is no error\r\n *   thrown when `element` is not a node or not an element.\r\n */\r\nexport const isElement =\r\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\r\n  /**\r\n   * @type {(\r\n   *   (<Condition extends TestFunction>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &\r\n   *   (<Condition extends string>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &\r\n   *   ((element?: null | undefined) => false) &\r\n   *   ((element: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &\r\n   *   ((element: unknown, test?: Test, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => boolean)\r\n   * )}\r\n   */\r\n  (\r\n    /**\r\n     * @param {unknown} [element]\r\n     * @param {Test | undefined} [test]\r\n     * @param {number | null | undefined} [index]\r\n     * @param {Parents | null | undefined} [parent]\r\n     * @param {unknown} [context]\r\n     * @returns {boolean}\r\n     */\r\n    // eslint-disable-next-line max-params\r\n    function (element, test, index, parent, context) {\r\n      const check = convertElement(test)\r\n\r\n      if (\r\n        index !== null &&\r\n        index !== undefined &&\r\n        (typeof index !== 'number' ||\r\n          index < 0 ||\r\n          index === Number.POSITIVE_INFINITY)\r\n      ) {\r\n        throw new Error('Expected positive finite `index`')\r\n      }\r\n\r\n      if (\r\n        parent !== null &&\r\n        parent !== undefined &&\r\n        (!parent.type || !parent.children)\r\n      ) {\r\n        throw new Error('Expected valid `parent`')\r\n      }\r\n\r\n      if (\r\n        (index === null || index === undefined) !==\r\n        (parent === null || parent === undefined)\r\n      ) {\r\n        throw new Error('Expected both `index` and `parent`')\r\n      }\r\n\r\n      return looksLikeAnElement(element)\r\n        ? check.call(context, element, index, parent)\r\n        : false\r\n    }\r\n  )\r\n\r\n/**\r\n * Generate a check from a test.\r\n *\r\n * Useful if you’re going to test many nodes, for example when creating a\r\n * utility where something else passes a compatible test.\r\n *\r\n * The created function is a bit faster because it expects valid input only:\r\n * an `element`, `index`, and `parent`.\r\n *\r\n * @param test\r\n *   A test for a specific element.\r\n * @returns\r\n *   A check.\r\n */\r\nexport const convertElement =\r\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\r\n  /**\r\n   * @type {(\r\n   *   (<Condition extends TestFunction>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &\r\n   *   (<Condition extends string>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &\r\n   *   ((test?: null | undefined) => (element?: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &\r\n   *   ((test?: Test) => Check)\r\n   * )}\r\n   */\r\n  (\r\n    /**\r\n     * @param {Test | null | undefined} [test]\r\n     * @returns {Check}\r\n     */\r\n    function (test) {\r\n      if (test === null || test === undefined) {\r\n        return element\r\n      }\r\n\r\n      if (typeof test === 'string') {\r\n        return tagNameFactory(test)\r\n      }\r\n\r\n      // Assume array.\r\n      if (typeof test === 'object') {\r\n        return anyFactory(test)\r\n      }\r\n\r\n      if (typeof test === 'function') {\r\n        return castFactory(test)\r\n      }\r\n\r\n      throw new Error('Expected function, string, or array as `test`')\r\n    }\r\n  )\r\n\r\n/**\r\n * Handle multiple tests.\r\n *\r\n * @param {Array<TestFunction | string>} tests\r\n * @returns {Check}\r\n */\r\nfunction anyFactory(tests) {\r\n  /** @type {Array<Check>} */\r\n  const checks = []\r\n  let index = -1\r\n\r\n  while (++index < tests.length) {\r\n    checks[index] = convertElement(tests[index])\r\n  }\r\n\r\n  return castFactory(any)\r\n\r\n  /**\r\n   * @this {unknown}\r\n   * @type {TestFunction}\r\n   */\r\n  function any(...parameters) {\r\n    let index = -1\r\n\r\n    while (++index < checks.length) {\r\n      if (checks[index].apply(this, parameters)) return true\r\n    }\r\n\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * Turn a string into a test for an element with a certain type.\r\n *\r\n * @param {string} check\r\n * @returns {Check}\r\n */\r\nfunction tagNameFactory(check) {\r\n  return castFactory(tagName)\r\n\r\n  /**\r\n   * @param {Element} element\r\n   * @returns {boolean}\r\n   */\r\n  function tagName(element) {\r\n    return element.tagName === check\r\n  }\r\n}\r\n\r\n/**\r\n * Turn a custom test into a test for an element that passes that test.\r\n *\r\n * @param {TestFunction} testFunction\r\n * @returns {Check}\r\n */\r\nfunction castFactory(testFunction) {\r\n  return check\r\n\r\n  /**\r\n   * @this {unknown}\r\n   * @type {Check}\r\n   */\r\n  function check(value, index, parent) {\r\n    return Boolean(\r\n      looksLikeAnElement(value) &&\r\n        testFunction.call(\r\n          this,\r\n          value,\r\n          typeof index === 'number' ? index : undefined,\r\n          parent || undefined\r\n        )\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * Make sure something is an element.\r\n *\r\n * @param {unknown} element\r\n * @returns {element is Element}\r\n */\r\nfunction element(element) {\r\n  return Boolean(\r\n    element &&\r\n      typeof element === 'object' &&\r\n      'type' in element &&\r\n      element.type === 'element' &&\r\n      'tagName' in element &&\r\n      typeof element.tagName === 'string'\r\n  )\r\n}\r\n\r\n/**\r\n * @param {unknown} value\r\n * @returns {value is Element}\r\n */\r\nfunction looksLikeAnElement(value) {\r\n  return (\r\n    value !== null &&\r\n    typeof value === 'object' &&\r\n    'type' in value &&\r\n    'tagName' in value\r\n  )\r\n}\r\n", "import {convertElement} from 'hast-util-is-element'\r\n\r\n/**\r\n * Check if a node is a *embedded content*.\r\n *\r\n * @param value\r\n *   Thing to check (typically `Node`).\r\n * @returns\r\n *   Whether `value` is an element considered embedded content.\r\n *\r\n *   The elements `audio`, `canvas`, `embed`, `iframe`, `img`, `math`,\r\n *   `object`, `picture`, `svg`, and `video` are embedded content.\r\n */\r\nexport const embedded = convertElement(\r\n  /**\r\n   * @param element\r\n   * @returns {element is {tagName: 'audio' | 'canvas' | 'embed' | 'iframe' | 'img' | 'math' | 'object' | 'picture' | 'svg' | 'video'}}\r\n   */\r\n  function (element) {\r\n    return (\r\n      element.tagName === 'audio' ||\r\n      element.tagName === 'canvas' ||\r\n      element.tagName === 'embed' ||\r\n      element.tagName === 'iframe' ||\r\n      element.tagName === 'img' ||\r\n      element.tagName === 'math' ||\r\n      element.tagName === 'object' ||\r\n      element.tagName === 'picture' ||\r\n      element.tagName === 'svg' ||\r\n      element.tagName === 'video'\r\n    )\r\n  }\r\n)\r\n", "/**\r\n * @typedef {import('unist').Node} Node\r\n * @typedef {import('unist').Parent} Parent\r\n */\r\n\r\n/**\r\n * @template Fn\r\n * @template Fallback\r\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\r\n */\r\n\r\n/**\r\n * @callback Check\r\n *   Check that an arbitrary value is a node.\r\n * @param {unknown} this\r\n *   The given context.\r\n * @param {unknown} [node]\r\n *   Anything (typically a node).\r\n * @param {number | null | undefined} [index]\r\n *   The node’s position in its parent.\r\n * @param {Parent | null | undefined} [parent]\r\n *   The node’s parent.\r\n * @returns {boolean}\r\n *   Whether this is a node and passes a test.\r\n *\r\n * @typedef {Record<string, unknown> | Node} Props\r\n *   Object to check for equivalence.\r\n *\r\n *   Note: `Node` is included as it is common but is not indexable.\r\n *\r\n * @typedef {Array<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test\r\n *   Check for an arbitrary node.\r\n *\r\n * @callback TestFunction\r\n *   Check if a node passes a test.\r\n * @param {unknown} this\r\n *   The given context.\r\n * @param {Node} node\r\n *   A node.\r\n * @param {number | undefined} [index]\r\n *   The node’s position in its parent.\r\n * @param {Parent | undefined} [parent]\r\n *   The node’s parent.\r\n * @returns {boolean | undefined | void}\r\n *   Whether this node passes the test.\r\n *\r\n *   Note: `void` is included until TS sees no return as `undefined`.\r\n */\r\n\r\n/**\r\n * Check if `node` is a `Node` and whether it passes the given test.\r\n *\r\n * @param {unknown} node\r\n *   Thing to check, typically `Node`.\r\n * @param {Test} test\r\n *   A check for a specific node.\r\n * @param {number | null | undefined} index\r\n *   The node’s position in its parent.\r\n * @param {Parent | null | undefined} parent\r\n *   The node’s parent.\r\n * @param {unknown} context\r\n *   Context object (`this`) to pass to `test` functions.\r\n * @returns {boolean}\r\n *   Whether `node` is a node and passes a test.\r\n */\r\nexport const is =\r\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\r\n  /**\r\n   * @type {(\r\n   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\r\n   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\r\n   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\r\n   *   ((node?: null | undefined) => false) &\r\n   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\r\n   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)\r\n   * )}\r\n   */\r\n  (\r\n    /**\r\n     * @param {unknown} [node]\r\n     * @param {Test} [test]\r\n     * @param {number | null | undefined} [index]\r\n     * @param {Parent | null | undefined} [parent]\r\n     * @param {unknown} [context]\r\n     * @returns {boolean}\r\n     */\r\n    // eslint-disable-next-line max-params\r\n    function (node, test, index, parent, context) {\r\n      const check = convert(test)\r\n\r\n      if (\r\n        index !== undefined &&\r\n        index !== null &&\r\n        (typeof index !== 'number' ||\r\n          index < 0 ||\r\n          index === Number.POSITIVE_INFINITY)\r\n      ) {\r\n        throw new Error('Expected positive finite index')\r\n      }\r\n\r\n      if (\r\n        parent !== undefined &&\r\n        parent !== null &&\r\n        (!is(parent) || !parent.children)\r\n      ) {\r\n        throw new Error('Expected parent node')\r\n      }\r\n\r\n      if (\r\n        (parent === undefined || parent === null) !==\r\n        (index === undefined || index === null)\r\n      ) {\r\n        throw new Error('Expected both parent and index')\r\n      }\r\n\r\n      return looksLikeANode(node)\r\n        ? check.call(context, node, index, parent)\r\n        : false\r\n    }\r\n  )\r\n\r\n/**\r\n * Generate an assertion from a test.\r\n *\r\n * Useful if you’re going to test many nodes, for example when creating a\r\n * utility where something else passes a compatible test.\r\n *\r\n * The created function is a bit faster because it expects valid input only:\r\n * a `node`, `index`, and `parent`.\r\n *\r\n * @param {Test} test\r\n *   *   when nullish, checks if `node` is a `Node`.\r\n *   *   when `string`, works like passing `(node) => node.type === test`.\r\n *   *   when `function` checks if function passed the node is true.\r\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\r\n *   *   when `array`, checks if any one of the subtests pass.\r\n * @returns {Check}\r\n *   An assertion.\r\n */\r\nexport const convert =\r\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\r\n  /**\r\n   * @type {(\r\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\r\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\r\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\r\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\r\n   *   ((test?: Test) => Check)\r\n   * )}\r\n   */\r\n  (\r\n    /**\r\n     * @param {Test} [test]\r\n     * @returns {Check}\r\n     */\r\n    function (test) {\r\n      if (test === null || test === undefined) {\r\n        return ok\r\n      }\r\n\r\n      if (typeof test === 'function') {\r\n        return castFactory(test)\r\n      }\r\n\r\n      if (typeof test === 'object') {\r\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\r\n      }\r\n\r\n      if (typeof test === 'string') {\r\n        return typeFactory(test)\r\n      }\r\n\r\n      throw new Error('Expected function, string, or object as test')\r\n    }\r\n  )\r\n\r\n/**\r\n * @param {Array<Props | TestFunction | string>} tests\r\n * @returns {Check}\r\n */\r\nfunction anyFactory(tests) {\r\n  /** @type {Array<Check>} */\r\n  const checks = []\r\n  let index = -1\r\n\r\n  while (++index < tests.length) {\r\n    checks[index] = convert(tests[index])\r\n  }\r\n\r\n  return castFactory(any)\r\n\r\n  /**\r\n   * @this {unknown}\r\n   * @type {TestFunction}\r\n   */\r\n  function any(...parameters) {\r\n    let index = -1\r\n\r\n    while (++index < checks.length) {\r\n      if (checks[index].apply(this, parameters)) return true\r\n    }\r\n\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * Turn an object into a test for a node with a certain fields.\r\n *\r\n * @param {Props} check\r\n * @returns {Check}\r\n */\r\nfunction propsFactory(check) {\r\n  const checkAsRecord = /** @type {Record<string, unknown>} */ (check)\r\n\r\n  return castFactory(all)\r\n\r\n  /**\r\n   * @param {Node} node\r\n   * @returns {boolean}\r\n   */\r\n  function all(node) {\r\n    const nodeAsRecord = /** @type {Record<string, unknown>} */ (\r\n      /** @type {unknown} */ (node)\r\n    )\r\n\r\n    /** @type {string} */\r\n    let key\r\n\r\n    for (key in check) {\r\n      if (nodeAsRecord[key] !== checkAsRecord[key]) return false\r\n    }\r\n\r\n    return true\r\n  }\r\n}\r\n\r\n/**\r\n * Turn a string into a test for a node with a certain type.\r\n *\r\n * @param {string} check\r\n * @returns {Check}\r\n */\r\nfunction typeFactory(check) {\r\n  return castFactory(type)\r\n\r\n  /**\r\n   * @param {Node} node\r\n   */\r\n  function type(node) {\r\n    return node && node.type === check\r\n  }\r\n}\r\n\r\n/**\r\n * Turn a custom test into a test for a node that passes that test.\r\n *\r\n * @param {TestFunction} testFunction\r\n * @returns {Check}\r\n */\r\nfunction castFactory(testFunction) {\r\n  return check\r\n\r\n  /**\r\n   * @this {unknown}\r\n   * @type {Check}\r\n   */\r\n  function check(value, index, parent) {\r\n    return Boolean(\r\n      looksLikeANode(value) &&\r\n        testFunction.call(\r\n          this,\r\n          value,\r\n          typeof index === 'number' ? index : undefined,\r\n          parent || undefined\r\n        )\r\n    )\r\n  }\r\n}\r\n\r\nfunction ok() {\r\n  return true\r\n}\r\n\r\n/**\r\n * @param {unknown} value\r\n * @returns {value is Node}\r\n */\r\nfunction looksLikeANode(value) {\r\n  return value !== null && typeof value === 'object' && 'type' in value\r\n}\r\n", "// See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\r\nexport const blocks = [\r\n  'address', // Flow content.\r\n  'article', // Sections and headings.\r\n  'aside', // Sections and headings.\r\n  'blockquote', // Flow content.\r\n  'body', // Page.\r\n  'br', // Contribute whitespace intrinsically.\r\n  'caption', // Similar to block.\r\n  'center', // Flow content, legacy.\r\n  'col', // Similar to block.\r\n  'colgroup', // Similar to block.\r\n  'dd', // Lists.\r\n  'dialog', // Flow content.\r\n  'dir', // Lists, legacy.\r\n  'div', // Flow content.\r\n  'dl', // Lists.\r\n  'dt', // Lists.\r\n  'figcaption', // Flow content.\r\n  'figure', // Flow content.\r\n  'footer', // Flow content.\r\n  'form', // Flow content.\r\n  'h1', // Sections and headings.\r\n  'h2', // Sections and headings.\r\n  'h3', // Sections and headings.\r\n  'h4', // Sections and headings.\r\n  'h5', // Sections and headings.\r\n  'h6', // Sections and headings.\r\n  'head', // Page.\r\n  'header', // Flow content.\r\n  'hgroup', // Sections and headings.\r\n  'hr', // Flow content.\r\n  'html', // Page.\r\n  'legend', // Flow content.\r\n  'li', // Block-like.\r\n  'li', // Similar to block.\r\n  'listing', // Flow content, legacy\r\n  'main', // Flow content.\r\n  'menu', // Lists.\r\n  'nav', // Sections and headings.\r\n  'ol', // Lists.\r\n  'optgroup', // Similar to block.\r\n  'option', // Similar to block.\r\n  'p', // Flow content.\r\n  'plaintext', // Flow content, legacy\r\n  'pre', // Flow content.\r\n  'section', // Sections and headings.\r\n  'summary', // Similar to block.\r\n  'table', // Similar to block.\r\n  'tbody', // Similar to block.\r\n  'td', // Block-like.\r\n  'td', // Similar to block.\r\n  'tfoot', // Similar to block.\r\n  'th', // Block-like.\r\n  'th', // Similar to block.\r\n  'thead', // Similar to block.\r\n  'tr', // Similar to block.\r\n  'ul', // Lists.\r\n  'wbr', // Contribute whitespace intrinsically.\r\n  'xmp' // Flow content, legacy\r\n]\r\n", "export const content = [\r\n  // Form.\r\n  'button',\r\n  'input',\r\n  'select',\r\n  'textarea'\r\n]\r\n", "export const skippable = [\r\n  'area',\r\n  'base',\r\n  'basefont',\r\n  'dialog',\r\n  'datalist',\r\n  'head',\r\n  'link',\r\n  'meta',\r\n  'noembed',\r\n  'noframes',\r\n  'param',\r\n  'rp',\r\n  'script',\r\n  'source',\r\n  'style',\r\n  'template',\r\n  'track',\r\n  'title'\r\n]\r\n", "/**\r\n * @import {Nodes, Parents, Text} from 'hast'\r\n */\r\n\r\n/**\r\n * @callback Collapse\r\n *   Collapse a string.\r\n * @param {string} value\r\n *   Value to collapse.\r\n * @returns {string}\r\n *   Collapsed value.\r\n *\r\n * @typedef Options\r\n *   Configuration.\r\n * @property {boolean | null | undefined} [newlines=false]\r\n *   Collapse whitespace containing newlines to `'\\n'` instead of `' '`\r\n *   (default: `false`); the default is to collapse to a single space.\r\n *\r\n * @typedef Result\r\n *   Result.\r\n * @property {boolean} remove\r\n *   Whether to remove.\r\n * @property {boolean} ignore\r\n *   Whether to ignore.\r\n * @property {boolean} stripAtStart\r\n *   Whether to strip at the start.\r\n *\r\n * @typedef State\r\n *   Info passed around.\r\n * @property {Collapse} collapse\r\n *   Collapse.\r\n * @property {Whitespace} whitespace\r\n *   Current whitespace.\r\n * @property {boolean | undefined} [before]\r\n *   Whether there is a break before (default: `false`).\r\n * @property {boolean | undefined} [after]\r\n *   Whether there is a break after (default: `false`).\r\n *\r\n * @typedef {'normal' | 'nowrap' | 'pre' | 'pre-wrap'} Whitespace\r\n *   Whitespace setting.\r\n */\r\n\r\nimport {embedded} from 'hast-util-embedded'\r\nimport {isElement} from 'hast-util-is-element'\r\nimport {whitespace} from 'hast-util-whitespace'\r\nimport {convert} from 'unist-util-is'\r\nimport {blocks} from './block.js'\r\nimport {content as contents} from './content.js'\r\nimport {skippable as skippables} from './skippable.js'\r\n\r\n/** @type {Options} */\r\nconst emptyOptions = {}\r\nconst ignorableNode = convert(['comment', 'doctype'])\r\n\r\n/**\r\n * Minify whitespace.\r\n *\r\n * @param {Nodes} tree\r\n *   Tree.\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration (optional).\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nexport function minifyWhitespace(tree, options) {\r\n  const settings = options || emptyOptions\r\n\r\n  minify(tree, {\r\n    collapse: collapseFactory(\r\n      settings.newlines ? replaceNewlines : replaceWhitespace\r\n    ),\r\n    whitespace: 'normal'\r\n  })\r\n}\r\n\r\n/**\r\n * @param {Nodes} node\r\n *   Node.\r\n * @param {State} state\r\n *   Info passed around.\r\n * @returns {Result}\r\n *   Result.\r\n */\r\nfunction minify(node, state) {\r\n  if ('children' in node) {\r\n    const settings = {...state}\r\n\r\n    if (node.type === 'root' || blocklike(node)) {\r\n      settings.before = true\r\n      settings.after = true\r\n    }\r\n\r\n    settings.whitespace = inferWhiteSpace(node, state)\r\n\r\n    return all(node, settings)\r\n  }\r\n\r\n  if (node.type === 'text') {\r\n    if (state.whitespace === 'normal') {\r\n      return minifyText(node, state)\r\n    }\r\n\r\n    // Naïve collapse, but no trimming:\r\n    if (state.whitespace === 'nowrap') {\r\n      node.value = state.collapse(node.value)\r\n    }\r\n\r\n    // The `pre-wrap` or `pre` whitespace settings are neither collapsed nor\r\n    // trimmed.\r\n  }\r\n\r\n  return {ignore: ignorableNode(node), stripAtStart: false, remove: false}\r\n}\r\n\r\n/**\r\n * @param {Text} node\r\n *   Node.\r\n * @param {State} state\r\n *   Info passed around.\r\n * @returns {Result}\r\n *   Result.\r\n */\r\nfunction minifyText(node, state) {\r\n  const value = state.collapse(node.value)\r\n  const result = {ignore: false, stripAtStart: false, remove: false}\r\n  let start = 0\r\n  let end = value.length\r\n\r\n  if (state.before && removable(value.charAt(0))) {\r\n    start++\r\n  }\r\n\r\n  if (start !== end && removable(value.charAt(end - 1))) {\r\n    if (state.after) {\r\n      end--\r\n    } else {\r\n      result.stripAtStart = true\r\n    }\r\n  }\r\n\r\n  if (start === end) {\r\n    result.remove = true\r\n  } else {\r\n    node.value = value.slice(start, end)\r\n  }\r\n\r\n  return result\r\n}\r\n\r\n/**\r\n * @param {Parents} parent\r\n *   Node.\r\n * @param {State} state\r\n *   Info passed around.\r\n * @returns {Result}\r\n *   Result.\r\n */\r\nfunction all(parent, state) {\r\n  let before = state.before\r\n  const after = state.after\r\n  const children = parent.children\r\n  let length = children.length\r\n  let index = -1\r\n\r\n  while (++index < length) {\r\n    const result = minify(children[index], {\r\n      ...state,\r\n      after: collapsableAfter(children, index, after),\r\n      before\r\n    })\r\n\r\n    if (result.remove) {\r\n      children.splice(index, 1)\r\n      index--\r\n      length--\r\n    } else if (!result.ignore) {\r\n      before = result.stripAtStart\r\n    }\r\n\r\n    // If this element, such as a `<select>` or `<img>`, contributes content\r\n    // somehow, allow whitespace again.\r\n    if (content(children[index])) {\r\n      before = false\r\n    }\r\n  }\r\n\r\n  return {ignore: false, stripAtStart: Boolean(before || after), remove: false}\r\n}\r\n\r\n/**\r\n * @param {Array<Nodes>} nodes\r\n *   Nodes.\r\n * @param {number} index\r\n *   Index.\r\n * @param {boolean | undefined} [after]\r\n *   Whether there is a break after `nodes` (default: `false`).\r\n * @returns {boolean | undefined}\r\n *   Whether there is a break after the node at `index`.\r\n */\r\nfunction collapsableAfter(nodes, index, after) {\r\n  while (++index < nodes.length) {\r\n    const node = nodes[index]\r\n    let result = inferBoundary(node)\r\n\r\n    if (result === undefined && 'children' in node && !skippable(node)) {\r\n      result = collapsableAfter(node.children, -1)\r\n    }\r\n\r\n    if (typeof result === 'boolean') {\r\n      return result\r\n    }\r\n  }\r\n\r\n  return after\r\n}\r\n\r\n/**\r\n * Infer two types of boundaries:\r\n *\r\n * 1. `true` — boundary for which whitespace around it does not contribute\r\n *    anything\r\n * 2. `false` — boundary for which whitespace around it *does* contribute\r\n *\r\n * No result (`undefined`) is returned if it is unknown.\r\n *\r\n * @param {Nodes} node\r\n *   Node.\r\n * @returns {boolean | undefined}\r\n *   Boundary.\r\n */\r\nfunction inferBoundary(node) {\r\n  if (node.type === 'element') {\r\n    if (content(node)) {\r\n      return false\r\n    }\r\n\r\n    if (blocklike(node)) {\r\n      return true\r\n    }\r\n\r\n    // Unknown: either depends on siblings if embedded or metadata, or on\r\n    // children.\r\n  } else if (node.type === 'text') {\r\n    if (!whitespace(node)) {\r\n      return false\r\n    }\r\n  } else if (!ignorableNode(node)) {\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * Infer whether a node is skippable.\r\n *\r\n * @param {Nodes} node\r\n *   Node.\r\n * @returns {boolean}\r\n *   Whether `node` is skippable.\r\n */\r\nfunction content(node) {\r\n  return embedded(node) || isElement(node, contents)\r\n}\r\n\r\n/**\r\n * See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\r\n *\r\n * @param {Nodes} node\r\n *   Node.\r\n * @returns {boolean}\r\n *   Whether `node` is block-like.\r\n */\r\nfunction blocklike(node) {\r\n  return isElement(node, blocks)\r\n}\r\n\r\n/**\r\n * @param {Parents} node\r\n *   Node.\r\n * @returns {boolean}\r\n *   Whether `node` is skippable.\r\n */\r\nfunction skippable(node) {\r\n  return (\r\n    Boolean(node.type === 'element' && node.properties.hidden) ||\r\n    ignorableNode(node) ||\r\n    isElement(node, skippables)\r\n  )\r\n}\r\n\r\n/**\r\n * @param {string} character\r\n *   Character.\r\n * @returns {boolean}\r\n *   Whether `character` is removable.\r\n */\r\nfunction removable(character) {\r\n  return character === ' ' || character === '\\n'\r\n}\r\n\r\n/**\r\n * @type {Collapse}\r\n */\r\nfunction replaceNewlines(value) {\r\n  const match = /\\r?\\n|\\r/.exec(value)\r\n  return match ? match[0] : ' '\r\n}\r\n\r\n/**\r\n * @type {Collapse}\r\n */\r\nfunction replaceWhitespace() {\r\n  return ' '\r\n}\r\n\r\n/**\r\n * @param {Collapse} replace\r\n * @returns {Collapse}\r\n *   Collapse.\r\n */\r\nfunction collapseFactory(replace) {\r\n  return collapse\r\n\r\n  /**\r\n   * @type {Collapse}\r\n   */\r\n  function collapse(value) {\r\n    return String(value).replace(/[\\t\\n\\v\\f\\r ]+/g, replace)\r\n  }\r\n}\r\n\r\n/**\r\n * We don’t need to support void elements here (so `nobr wbr` -> `normal` is\r\n * ignored).\r\n *\r\n * @param {Parents} node\r\n *   Node.\r\n * @param {State} state\r\n *   Info passed around.\r\n * @returns {Whitespace}\r\n *   Whitespace.\r\n */\r\nfunction inferWhiteSpace(node, state) {\r\n  if ('tagName' in node && node.properties) {\r\n    switch (node.tagName) {\r\n      // Whitespace in script/style, while not displayed by CSS as significant,\r\n      // could have some meaning in JS/CSS, so we can’t touch them.\r\n      case 'listing':\r\n      case 'plaintext':\r\n      case 'script':\r\n      case 'style':\r\n      case 'xmp': {\r\n        return 'pre'\r\n      }\r\n\r\n      case 'nobr': {\r\n        return 'nowrap'\r\n      }\r\n\r\n      case 'pre': {\r\n        return node.properties.wrap ? 'pre-wrap' : 'pre'\r\n      }\r\n\r\n      case 'td':\r\n      case 'th': {\r\n        return node.properties.noWrap ? 'nowrap' : state.whitespace\r\n      }\r\n\r\n      case 'textarea': {\r\n        return 'pre-wrap'\r\n      }\r\n\r\n      default:\r\n    }\r\n  }\r\n\r\n  return state.whitespace\r\n}\r\n", "/**\r\n * @typedef {import('hast').Element} Element\r\n * @typedef {import('hast').Nodes} Nodes\r\n */\r\n\r\nconst own = {}.hasOwnProperty\r\n\r\n/**\r\n * Check if `node` is an element and has a `name` property.\r\n *\r\n * @template {string} Key\r\n *   Type of key.\r\n * @param {Nodes} node\r\n *   Node to check (typically `Element`).\r\n * @param {Key} name\r\n *   Property name to check.\r\n * @returns {node is Element & {properties: Record<Key, Array<number | string> | number | string | true>}}}\r\n *   Whether `node` is an element that has a `name` property.\r\n *\r\n *   Note: see <https://github.com/DefinitelyTyped/DefinitelyTyped/blob/27c9274/types/hast/index.d.ts#L37C29-L37C98>.\r\n */\r\nexport function hasProperty(node, name) {\r\n  const value =\r\n    node.type === 'element' &&\r\n    own.call(node.properties, name) &&\r\n    node.properties[name]\r\n\r\n  return value !== null && value !== undefined && value !== false\r\n}\r\n", "/**\r\n * @import {Nodes} from 'hast'\r\n */\r\n\r\nconst list = new Set(['pingback', 'prefetch', 'stylesheet'])\r\n\r\n/**\r\n * Checks whether a node is a “body OK” link.\r\n *\r\n * @param {Nodes} node\r\n *   Node to check.\r\n * @returns {boolean}\r\n *   Whether `node` is a “body OK” link.\r\n */\r\nexport function isBodyOkLink(node) {\r\n  if (node.type !== 'element' || node.tagName !== 'link') {\r\n    return false\r\n  }\r\n\r\n  if (node.properties.itemProp) {\r\n    return true\r\n  }\r\n\r\n  const value = node.properties.rel\r\n  let index = -1\r\n\r\n  if (!Array.isArray(value) || value.length === 0) {\r\n    return false\r\n  }\r\n\r\n  while (++index < value.length) {\r\n    if (!list.has(String(value[index]))) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  return true\r\n}\r\n", "/**\r\n * @typedef {import('hast').Nodes} Nodes\r\n */\r\n\r\nimport {embedded} from 'hast-util-embedded'\r\nimport {hasProperty} from 'hast-util-has-property'\r\nimport {isBodyOkLink} from 'hast-util-is-body-ok-link'\r\nimport {convertElement} from 'hast-util-is-element'\r\n\r\nconst basic = convertElement([\r\n  'a',\r\n  'abbr',\r\n  // `area` is in fact only phrasing if it is inside a `map` element.\r\n  // However, since `area`s are required to be inside a `map` element, and it’s\r\n  // a rather involved check, it’s ignored here for now.\r\n  'area',\r\n  'b',\r\n  'bdi',\r\n  'bdo',\r\n  'br',\r\n  'button',\r\n  'cite',\r\n  'code',\r\n  'data',\r\n  'datalist',\r\n  'del',\r\n  'dfn',\r\n  'em',\r\n  'i',\r\n  'input',\r\n  'ins',\r\n  'kbd',\r\n  'keygen',\r\n  'label',\r\n  'map',\r\n  'mark',\r\n  'meter',\r\n  'noscript',\r\n  'output',\r\n  'progress',\r\n  'q',\r\n  'ruby',\r\n  's',\r\n  'samp',\r\n  'script',\r\n  'select',\r\n  'small',\r\n  'span',\r\n  'strong',\r\n  'sub',\r\n  'sup',\r\n  'template',\r\n  'textarea',\r\n  'time',\r\n  'u',\r\n  'var',\r\n  'wbr'\r\n])\r\n\r\nconst meta = convertElement('meta')\r\n\r\n/**\r\n * Check if the given value is *phrasing* content.\r\n *\r\n * @param {Nodes} value\r\n *   Node to check.\r\n * @returns {boolean}\r\n *   Whether `value` is phrasing content.\r\n */\r\nexport function phrasing(value) {\r\n  return Boolean(\r\n    value.type === 'text' ||\r\n      basic(value) ||\r\n      embedded(value) ||\r\n      isBodyOkLink(value) ||\r\n      (meta(value) && hasProperty(value, 'itemProp'))\r\n  )\r\n}\r\n", "/**\r\n * List of HTML tag names that are whitespace sensitive.\r\n */\r\nexport const whitespaceSensitiveTagNames = [\r\n  'pre',\r\n  'script',\r\n  'style',\r\n  'textarea'\r\n]\r\n", "/**\r\n * @param {string} d\r\n * @returns {string}\r\n */\r\nexport function color(d) {\r\n  return d\r\n}\r\n", "/**\r\n * @typedef {import('unist').Node} UnistNode\r\n * @typedef {import('unist').Parent} UnistParent\r\n */\r\n\r\n/**\r\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\r\n *   Test from `unist-util-is`.\r\n *\r\n *   Note: we have remove and add `undefined`, because otherwise when generating\r\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\r\n *   which doesn’t work when publishing on npm.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Fn extends (value: any) => value is infer Thing\r\n *   ? Thing\r\n *   : Fallback\r\n * )} Predicate\r\n *   Get the value of a type guard `Fn`.\r\n * @template Fn\r\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\r\n * @template Fallback\r\n *   Value to yield if `Fn` is not a type guard.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Check extends null | undefined // No test.\r\n *   ? Value\r\n *   : Value extends {type: Check} // String (type) test.\r\n *   ? Value\r\n *   : Value extends Check // Partial test.\r\n *   ? Value\r\n *   : Check extends Function // Function test.\r\n *   ? Predicate<Check, Value> extends Value\r\n *     ? Predicate<Check, Value>\r\n *     : never\r\n *   : never // Some other test?\r\n * )} MatchesOne\r\n *   Check whether a node matches a primitive check in the type system.\r\n * @template Value\r\n *   Value; typically unist `Node`.\r\n * @template Check\r\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Check extends Array<any>\r\n *   ? MatchesOne<Value, Check[keyof Check]>\r\n *   : MatchesOne<Value, Check>\r\n * )} Matches\r\n *   Check whether a node matches a check in the type system.\r\n * @template Value\r\n *   Value; typically unist `Node`.\r\n * @template Check\r\n *   Value; typically `unist-util-is`-compatible test.\r\n */\r\n\r\n/**\r\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\r\n *   Number; capped reasonably.\r\n */\r\n\r\n/**\r\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\r\n *   Increment a number in the type system.\r\n * @template {Uint} [I=0]\r\n *   Index.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Node extends UnistParent\r\n *   ? Node extends {children: Array<infer Children>}\r\n *     ? Child extends Children ? Node : never\r\n *     : never\r\n *   : never\r\n * )} InternalParent\r\n *   Collect nodes that can be parents of `Child`.\r\n * @template {UnistNode} Node\r\n *   All node types in a tree.\r\n * @template {UnistNode} Child\r\n *   Node to search for.\r\n */\r\n\r\n/**\r\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\r\n *   Collect nodes in `Tree` that can be parents of `Child`.\r\n * @template {UnistNode} Tree\r\n *   All node types in a tree.\r\n * @template {UnistNode} Child\r\n *   Node to search for.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Depth extends Max\r\n *   ? never\r\n *   :\r\n *     | InternalParent<Node, Child>\r\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\r\n * )} InternalAncestor\r\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\r\n * @template {UnistNode} Node\r\n *   All node types in a tree.\r\n * @template {UnistNode} Child\r\n *   Node to search for.\r\n * @template {Uint} [Max=10]\r\n *   Max; searches up to this depth.\r\n * @template {Uint} [Depth=0]\r\n *   Current depth.\r\n */\r\n\r\n/**\r\n * @typedef {InternalAncestor<InclusiveDescendant<Tree>, Child>} Ancestor\r\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\r\n * @template {UnistNode} Tree\r\n *   All node types in a tree.\r\n * @template {UnistNode} Child\r\n *   Node to search for.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Tree extends UnistParent\r\n *     ? Depth extends Max\r\n *       ? Tree\r\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\r\n *     : Tree\r\n * )} InclusiveDescendant\r\n *   Collect all (inclusive) descendants of `Tree`.\r\n *\r\n *   > 👉 **Note**: for performance reasons, this seems to be the fastest way to\r\n *   > recurse without actually running into an infinite loop, which the\r\n *   > previous version did.\r\n *   >\r\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\r\n *   > passed, but it doesn’t improve performance.\r\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\r\n *   > Using up to `10` doesn’t hurt or help either.\r\n * @template {UnistNode} Tree\r\n *   Tree type.\r\n * @template {Uint} [Max=10]\r\n *   Max; searches up to this depth.\r\n * @template {Uint} [Depth=0]\r\n *   Current depth.\r\n */\r\n\r\n/**\r\n * @typedef {'skip' | boolean} Action\r\n *   Union of the action types.\r\n *\r\n * @typedef {number} Index\r\n *   Move to the sibling at `index` next (after node itself is completely\r\n *   traversed).\r\n *\r\n *   Useful if mutating the tree, such as removing the node the visitor is\r\n *   currently on, or any of its previous siblings.\r\n *   Results less than 0 or greater than or equal to `children.length` stop\r\n *   traversing the parent.\r\n *\r\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\r\n *   List with one or two values, the first an action, the second an index.\r\n *\r\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\r\n *   Any value that can be returned from a visitor.\r\n */\r\n\r\n/**\r\n * @callback Visitor\r\n *   Handle a node (matching `test`, if given).\r\n *\r\n *   Visitors are free to transform `node`.\r\n *   They can also transform the parent of node (the last of `ancestors`).\r\n *\r\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\r\n *   descendants to be walked (which is a bug).\r\n *\r\n *   When adding or removing previous siblings of `node` (or next siblings, in\r\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\r\n *   sibling to traverse after `node` is traversed.\r\n *   Adding or removing next siblings of `node` (or previous siblings, in case\r\n *   of reverse) is handled as expected without needing to return a new `Index`.\r\n *\r\n *   Removing the children property of an ancestor still results in them being\r\n *   traversed.\r\n * @param {Visited} node\r\n *   Found node.\r\n * @param {Array<VisitedParents>} ancestors\r\n *   Ancestors of `node`.\r\n * @returns {VisitorResult}\r\n *   What to do next.\r\n *\r\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\r\n *   An `Action` is treated as a tuple of `[Action]`.\r\n *\r\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\r\n *   When the `Action` is `EXIT`, that action can be returned.\r\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\r\n * @template {UnistNode} [Visited=UnistNode]\r\n *   Visited node type.\r\n * @template {UnistParent} [VisitedParents=UnistParent]\r\n *   Ancestor type.\r\n */\r\n\r\n/**\r\n * @typedef {Visitor<Matches<InclusiveDescendant<Tree>, Check>, Ancestor<Tree, Matches<InclusiveDescendant<Tree>, Check>>>} BuildVisitor\r\n *   Build a typed `Visitor` function from a tree and a test.\r\n *\r\n *   It will infer which values are passed as `node` and which as `parents`.\r\n * @template {UnistNode} [Tree=UnistNode]\r\n *   Tree type.\r\n * @template {Test} [Check=Test]\r\n *   Test type.\r\n */\r\n\r\nimport {convert} from 'unist-util-is'\r\nimport {color} from 'unist-util-visit-parents/do-not-use-color'\r\n\r\n/** @type {Readonly<ActionTuple>} */\r\nconst empty = []\r\n\r\n/**\r\n * Continue traversing as normal.\r\n */\r\nexport const CONTINUE = true\r\n\r\n/**\r\n * Stop traversing immediately.\r\n */\r\nexport const EXIT = false\r\n\r\n/**\r\n * Do not traverse this node’s children.\r\n */\r\nexport const SKIP = 'skip'\r\n\r\n/**\r\n * Visit nodes, with ancestral information.\r\n *\r\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\r\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\r\n *\r\n * You can choose for which nodes `visitor` is called by passing a `test`.\r\n * For complex tests, you should test yourself in `visitor`, as it will be\r\n * faster and will have improved type information.\r\n *\r\n * Walking the tree is an intensive task.\r\n * Make use of the return values of the visitor when possible.\r\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\r\n * to check if a node matches, and then perform different operations.\r\n *\r\n * You can change the tree.\r\n * See `Visitor` for more info.\r\n *\r\n * @overload\r\n * @param {Tree} tree\r\n * @param {Check} check\r\n * @param {BuildVisitor<Tree, Check>} visitor\r\n * @param {boolean | null | undefined} [reverse]\r\n * @returns {undefined}\r\n *\r\n * @overload\r\n * @param {Tree} tree\r\n * @param {BuildVisitor<Tree>} visitor\r\n * @param {boolean | null | undefined} [reverse]\r\n * @returns {undefined}\r\n *\r\n * @param {UnistNode} tree\r\n *   Tree to traverse.\r\n * @param {Visitor | Test} test\r\n *   `unist-util-is`-compatible test\r\n * @param {Visitor | boolean | null | undefined} [visitor]\r\n *   Handle each node.\r\n * @param {boolean | null | undefined} [reverse]\r\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\r\n * @returns {undefined}\r\n *   Nothing.\r\n *\r\n * @template {UnistNode} Tree\r\n *   Node type.\r\n * @template {Test} Check\r\n *   `unist-util-is`-compatible test.\r\n */\r\nexport function visitParents(tree, test, visitor, reverse) {\r\n  /** @type {Test} */\r\n  let check\r\n\r\n  if (typeof test === 'function' && typeof visitor !== 'function') {\r\n    reverse = visitor\r\n    // @ts-expect-error no visitor given, so `visitor` is test.\r\n    visitor = test\r\n  } else {\r\n    // @ts-expect-error visitor given, so `test` isn’t a visitor.\r\n    check = test\r\n  }\r\n\r\n  const is = convert(check)\r\n  const step = reverse ? -1 : 1\r\n\r\n  factory(tree, undefined, [])()\r\n\r\n  /**\r\n   * @param {UnistNode} node\r\n   * @param {number | undefined} index\r\n   * @param {Array<UnistParent>} parents\r\n   */\r\n  function factory(node, index, parents) {\r\n    const value = /** @type {Record<string, unknown>} */ (\r\n      node && typeof node === 'object' ? node : {}\r\n    )\r\n\r\n    if (typeof value.type === 'string') {\r\n      const name =\r\n        // `hast`\r\n        typeof value.tagName === 'string'\r\n          ? value.tagName\r\n          : // `xast`\r\n          typeof value.name === 'string'\r\n          ? value.name\r\n          : undefined\r\n\r\n      Object.defineProperty(visit, 'name', {\r\n        value:\r\n          'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\r\n      })\r\n    }\r\n\r\n    return visit\r\n\r\n    function visit() {\r\n      /** @type {Readonly<ActionTuple>} */\r\n      let result = empty\r\n      /** @type {Readonly<ActionTuple>} */\r\n      let subresult\r\n      /** @type {number} */\r\n      let offset\r\n      /** @type {Array<UnistParent>} */\r\n      let grandparents\r\n\r\n      if (!test || is(node, index, parents[parents.length - 1] || undefined)) {\r\n        // @ts-expect-error: `visitor` is now a visitor.\r\n        result = toResult(visitor(node, parents))\r\n\r\n        if (result[0] === EXIT) {\r\n          return result\r\n        }\r\n      }\r\n\r\n      if ('children' in node && node.children) {\r\n        const nodeAsParent = /** @type {UnistParent} */ (node)\r\n\r\n        if (nodeAsParent.children && result[0] !== SKIP) {\r\n          offset = (reverse ? nodeAsParent.children.length : -1) + step\r\n          grandparents = parents.concat(nodeAsParent)\r\n\r\n          while (offset > -1 && offset < nodeAsParent.children.length) {\r\n            const child = nodeAsParent.children[offset]\r\n\r\n            subresult = factory(child, offset, grandparents)()\r\n\r\n            if (subresult[0] === EXIT) {\r\n              return subresult\r\n            }\r\n\r\n            offset =\r\n              typeof subresult[1] === 'number' ? subresult[1] : offset + step\r\n          }\r\n        }\r\n      }\r\n\r\n      return result\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Turn a return value into a clean result.\r\n *\r\n * @param {VisitorResult} value\r\n *   Valid return values from visitors.\r\n * @returns {Readonly<ActionTuple>}\r\n *   Clean result.\r\n */\r\nfunction toResult(value) {\r\n  if (Array.isArray(value)) {\r\n    return value\r\n  }\r\n\r\n  if (typeof value === 'number') {\r\n    return [CONTINUE, value]\r\n  }\r\n\r\n  return value === null || value === undefined ? empty : [value]\r\n}\r\n", "/**\r\n * @import {Nodes, RootContent, Root} from 'hast'\r\n * @import {BuildVisitor} from 'unist-util-visit-parents'\r\n * @import {Options, State} from './types.js'\r\n */\r\n\r\nimport {embedded} from 'hast-util-embedded'\r\nimport {minifyWhitespace} from 'hast-util-minify-whitespace'\r\nimport {phrasing} from 'hast-util-phrasing'\r\nimport {whitespace} from 'hast-util-whitespace'\r\nimport {whitespaceSensitiveTagNames} from 'html-whitespace-sensitive-tag-names'\r\nimport {SKIP, visitParents} from 'unist-util-visit-parents'\r\n\r\n/** @type {Options} */\r\nconst emptyOptions = {}\r\n\r\n/**\r\n * Format whitespace in HTML.\r\n *\r\n * @param {Root} tree\r\n *   Tree.\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration (optional).\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nexport function format(tree, options) {\r\n  const settings = options || emptyOptions\r\n\r\n  /** @type {State} */\r\n  const state = {\r\n    blanks: settings.blanks || [],\r\n    head: false,\r\n    indentInitial: settings.indentInitial !== false,\r\n    indent:\r\n      typeof settings.indent === 'number'\r\n        ? ' '.repeat(settings.indent)\r\n        : typeof settings.indent === 'string'\r\n          ? settings.indent\r\n          : '  '\r\n  }\r\n\r\n  minifyWhitespace(tree, {newlines: true})\r\n\r\n  visitParents(tree, visitor)\r\n\r\n  /**\r\n   * @type {BuildVisitor<Root>}\r\n   */\r\n  function visitor(node, parents) {\r\n    if (!('children' in node)) {\r\n      return\r\n    }\r\n\r\n    if (node.type === 'element' && node.tagName === 'head') {\r\n      state.head = true\r\n    }\r\n\r\n    if (state.head && node.type === 'element' && node.tagName === 'body') {\r\n      state.head = false\r\n    }\r\n\r\n    if (\r\n      node.type === 'element' &&\r\n      whitespaceSensitiveTagNames.includes(node.tagName)\r\n    ) {\r\n      return SKIP\r\n    }\r\n\r\n    // Don’t indent content of whitespace-sensitive nodes / inlines.\r\n    if (node.children.length === 0 || !padding(state, node)) {\r\n      return\r\n    }\r\n\r\n    let level = parents.length\r\n\r\n    if (!state.indentInitial) {\r\n      level--\r\n    }\r\n\r\n    let eol = false\r\n\r\n    // Indent newlines in `text`.\r\n    for (const child of node.children) {\r\n      if (child.type === 'comment' || child.type === 'text') {\r\n        if (child.value.includes('\\n')) {\r\n          eol = true\r\n        }\r\n\r\n        child.value = child.value.replace(\r\n          / *\\n/g,\r\n          '$&' + state.indent.repeat(level)\r\n        )\r\n      }\r\n    }\r\n\r\n    /** @type {Array<RootContent>} */\r\n    const result = []\r\n    /** @type {RootContent | undefined} */\r\n    let previous\r\n\r\n    for (const child of node.children) {\r\n      if (padding(state, child) || (eol && !previous)) {\r\n        addBreak(result, level, child)\r\n        eol = true\r\n      }\r\n\r\n      previous = child\r\n      result.push(child)\r\n    }\r\n\r\n    if (previous && (eol || padding(state, previous))) {\r\n      // Ignore trailing whitespace (if that already existed), as we’ll add\r\n      // properly indented whitespace.\r\n      if (whitespace(previous)) {\r\n        result.pop()\r\n        previous = result[result.length - 1]\r\n      }\r\n\r\n      addBreak(result, level - 1)\r\n    }\r\n\r\n    node.children = result\r\n  }\r\n\r\n  /**\r\n   * @param {Array<RootContent>} list\r\n   *   Nodes.\r\n   * @param {number} level\r\n   *   Indentation level.\r\n   * @param {RootContent | undefined} [next]\r\n   *   Next node.\r\n   * @returns {undefined}\r\n   *   Nothing.\r\n   */\r\n  function addBreak(list, level, next) {\r\n    const tail = list[list.length - 1]\r\n    const previous = tail && whitespace(tail) ? list[list.length - 2] : tail\r\n    const replace =\r\n      (blank(state, previous) && blank(state, next) ? '\\n\\n' : '\\n') +\r\n      state.indent.repeat(Math.max(level, 0))\r\n\r\n    if (tail && tail.type === 'text') {\r\n      tail.value = whitespace(tail) ? replace : tail.value + replace\r\n    } else {\r\n      list.push({type: 'text', value: replace})\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {Nodes | undefined} node\r\n *   Node.\r\n * @returns {boolean}\r\n *   Whether `node` is a blank.\r\n */\r\nfunction blank(state, node) {\r\n  return Boolean(\r\n    node &&\r\n      node.type === 'element' &&\r\n      state.blanks.length > 0 &&\r\n      state.blanks.includes(node.tagName)\r\n  )\r\n}\r\n\r\n/**\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {Nodes} node\r\n *   Node.\r\n * @returns {boolean}\r\n *   Whether `node` should be padded.\r\n */\r\nfunction padding(state, node) {\r\n  return (\r\n    node.type === 'root' ||\r\n    (node.type === 'element'\r\n      ? state.head ||\r\n        node.tagName === 'script' ||\r\n        embedded(node) ||\r\n        !phrasing(node)\r\n      : false)\r\n  )\r\n}\r\n", "/**\r\n * @import {Options} from 'hast-util-format'\r\n * @import {Root} from 'hast'\r\n */\r\n\r\nimport {format} from 'hast-util-format'\r\n\r\n/**\r\n * Format whitespace in HTML.\r\n *\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration (optional).\r\n * @returns\r\n *   Transform.\r\n */\r\nexport default function rehypeFormat(options) {\r\n  /**\r\n   * Transform.\r\n   *\r\n   * @param {Root} tree\r\n   *   Tree.\r\n   * @returns {undefined}\r\n   *   Nothing.\r\n   */\r\n  return function (tree) {\r\n    format(tree, options)\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["element", "index", "element", "castFactory", "anyFactory", "index", "all", "content", "skippable", "is", "emptyOptions", "list"]
}
