{
  "version": 3,
  "sources": ["../../hast-util-parse-selector/lib/index.js", "../../hastscript/lib/core.js", "../../hastscript/lib/html.js", "../../hastscript/lib/svg-case-sensitive-tag-names.js", "../../hastscript/lib/svg.js", "../../web-namespaces/index.js"],
  "sourcesContent": ["/**\r\n * @typedef {import('hast').Properties} Properties\r\n * @typedef {import('hast').Element} Element\r\n */\r\n\r\nconst search = /[#.]/g\r\n\r\n/**\r\n * Create a hast element from a simple CSS selector.\r\n *\r\n * @template {string} Selector\r\n *   Type of selector.\r\n * @template {string} [DefaultTagName='div']\r\n *   Type of default tag name.\r\n * @param {Selector | null | undefined} [selector]\r\n *   Simple CSS selector.\r\n *\r\n *   Can contain a tag name (`foo`), classes (`.bar`), and an ID (`#baz`).\r\n *   Multiple classes are allowed.\r\n *   Uses the last ID if multiple IDs are found.\r\n * @param {DefaultTagName | null | undefined} [defaultTagName='div']\r\n *   Tag name to use if `selector` does not specify one (default: `'div'`).\r\n * @returns {Element & {tagName: import('./extract.js').ExtractTagName<Selector, DefaultTagName>}}\r\n *   Built element.\r\n */\r\nexport function parseSelector(selector, defaultTagName) {\r\n  const value = selector || ''\r\n  /** @type {Properties} */\r\n  const props = {}\r\n  let start = 0\r\n  /** @type {string | undefined} */\r\n  let previous\r\n  /** @type {string | undefined} */\r\n  let tagName\r\n\r\n  while (start < value.length) {\r\n    search.lastIndex = start\r\n    const match = search.exec(value)\r\n    const subvalue = value.slice(start, match ? match.index : value.length)\r\n\r\n    if (subvalue) {\r\n      if (!previous) {\r\n        tagName = subvalue\r\n      } else if (previous === '#') {\r\n        props.id = subvalue\r\n      } else if (Array.isArray(props.className)) {\r\n        props.className.push(subvalue)\r\n      } else {\r\n        props.className = [subvalue]\r\n      }\r\n\r\n      start += subvalue.length\r\n    }\r\n\r\n    if (match) {\r\n      previous = match[0]\r\n      start++\r\n    }\r\n  }\r\n\r\n  return {\r\n    type: 'element',\r\n    // @ts-expect-error: fine.\r\n    tagName: tagName || defaultTagName || 'div',\r\n    properties: props,\r\n    children: []\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('hast').Root} Root\r\n * @typedef {import('hast').Content} Content\r\n * @typedef {import('hast').Element} Element\r\n * @typedef {import('hast').Properties} Properties\r\n * @typedef {import('property-information').Info} Info\r\n * @typedef {import('property-information').Schema} Schema\r\n */\r\n\r\n/**\r\n * @typedef {Content | Root} Node\r\n *   Any concrete `hast` node.\r\n * @typedef {Root | Element} HResult\r\n *   Result from a `h` (or `s`) call.\r\n *\r\n * @typedef {string | number} HStyleValue\r\n *   Value for a CSS style field.\r\n * @typedef {Record<string, HStyleValue>} HStyle\r\n *   Supported value of a `style` prop.\r\n * @typedef {string | number | boolean | null | undefined} HPrimitiveValue\r\n *   Primitive property value.\r\n * @typedef {Array<string | number>} HArrayValue\r\n *   List of property values for space- or comma separated values (such as `className`).\r\n * @typedef {HPrimitiveValue | HArrayValue} HPropertyValue\r\n *   Primitive value or list value.\r\n * @typedef {{[property: string]: HPropertyValue | HStyle}} HProperties\r\n *   Acceptable value for element properties.\r\n *\r\n * @typedef {string | number | null | undefined} HPrimitiveChild\r\n *   Primitive children, either ignored (nullish), or turned into text nodes.\r\n * @typedef {Array<Node | HPrimitiveChild>} HArrayChild\r\n *   List of children.\r\n * @typedef {Node | HPrimitiveChild | HArrayChild} HChild\r\n *   Acceptable child value.\r\n */\r\n\r\nimport {find, normalize} from 'property-information'\r\nimport {parseSelector} from 'hast-util-parse-selector'\r\nimport {parse as spaces} from 'space-separated-tokens'\r\nimport {parse as commas} from 'comma-separated-tokens'\r\n\r\nconst buttonTypes = new Set(['menu', 'submit', 'reset', 'button'])\r\n\r\nconst own = {}.hasOwnProperty\r\n\r\n/**\r\n * @param {Schema} schema\r\n * @param {string} defaultTagName\r\n * @param {Array<string>} [caseSensitive]\r\n */\r\nexport function core(schema, defaultTagName, caseSensitive) {\r\n  const adjust = caseSensitive && createAdjustMap(caseSensitive)\r\n\r\n  const h =\r\n    /**\r\n     * @type {{\r\n     *   (): Root\r\n     *   (selector: null | undefined, ...children: Array<HChild>): Root\r\n     *   (selector: string, properties?: HProperties, ...children: Array<HChild>): Element\r\n     *   (selector: string, ...children: Array<HChild>): Element\r\n     * }}\r\n     */\r\n    (\r\n      /**\r\n       * Hyperscript compatible DSL for creating virtual hast trees.\r\n       *\r\n       * @param {string | null} [selector]\r\n       * @param {HProperties | HChild} [properties]\r\n       * @param {Array<HChild>} children\r\n       * @returns {HResult}\r\n       */\r\n      function (selector, properties, ...children) {\r\n        let index = -1\r\n        /** @type {HResult} */\r\n        let node\r\n\r\n        if (selector === undefined || selector === null) {\r\n          node = {type: 'root', children: []}\r\n          // @ts-expect-error Properties are not supported for roots.\r\n          children.unshift(properties)\r\n        } else {\r\n          node = parseSelector(selector, defaultTagName)\r\n          // Normalize the name.\r\n          node.tagName = node.tagName.toLowerCase()\r\n          if (adjust && own.call(adjust, node.tagName)) {\r\n            node.tagName = adjust[node.tagName]\r\n          }\r\n\r\n          // Handle props.\r\n          if (isProperties(properties, node.tagName)) {\r\n            /** @type {string} */\r\n            let key\r\n\r\n            for (key in properties) {\r\n              if (own.call(properties, key)) {\r\n                // @ts-expect-error `node.properties` is set.\r\n                addProperty(schema, node.properties, key, properties[key])\r\n              }\r\n            }\r\n          } else {\r\n            children.unshift(properties)\r\n          }\r\n        }\r\n\r\n        // Handle children.\r\n        while (++index < children.length) {\r\n          addChild(node.children, children[index])\r\n        }\r\n\r\n        if (node.type === 'element' && node.tagName === 'template') {\r\n          node.content = {type: 'root', children: node.children}\r\n          node.children = []\r\n        }\r\n\r\n        return node\r\n      }\r\n    )\r\n\r\n  return h\r\n}\r\n\r\n/**\r\n * @param {HProperties | HChild} value\r\n * @param {string} name\r\n * @returns {value is HProperties}\r\n */\r\nfunction isProperties(value, name) {\r\n  if (\r\n    value === null ||\r\n    value === undefined ||\r\n    typeof value !== 'object' ||\r\n    Array.isArray(value)\r\n  ) {\r\n    return false\r\n  }\r\n\r\n  if (name === 'input' || !value.type || typeof value.type !== 'string') {\r\n    return true\r\n  }\r\n\r\n  if ('children' in value && Array.isArray(value.children)) {\r\n    return false\r\n  }\r\n\r\n  if (name === 'button') {\r\n    return buttonTypes.has(value.type.toLowerCase())\r\n  }\r\n\r\n  return !('value' in value)\r\n}\r\n\r\n/**\r\n * @param {Schema} schema\r\n * @param {Properties} properties\r\n * @param {string} key\r\n * @param {HStyle | HPropertyValue} value\r\n * @returns {void}\r\n */\r\nfunction addProperty(schema, properties, key, value) {\r\n  const info = find(schema, key)\r\n  let index = -1\r\n  /** @type {HPropertyValue} */\r\n  let result\r\n\r\n  // Ignore nullish and NaN values.\r\n  if (value === undefined || value === null) return\r\n\r\n  if (typeof value === 'number') {\r\n    // Ignore NaN.\r\n    if (Number.isNaN(value)) return\r\n\r\n    result = value\r\n  }\r\n  // Booleans.\r\n  else if (typeof value === 'boolean') {\r\n    result = value\r\n  }\r\n  // Handle list values.\r\n  else if (typeof value === 'string') {\r\n    if (info.spaceSeparated) {\r\n      result = spaces(value)\r\n    } else if (info.commaSeparated) {\r\n      result = commas(value)\r\n    } else if (info.commaOrSpaceSeparated) {\r\n      result = spaces(commas(value).join(' '))\r\n    } else {\r\n      result = parsePrimitive(info, info.property, value)\r\n    }\r\n  } else if (Array.isArray(value)) {\r\n    result = value.concat()\r\n  } else {\r\n    result = info.property === 'style' ? style(value) : String(value)\r\n  }\r\n\r\n  if (Array.isArray(result)) {\r\n    /** @type {Array<string | number>} */\r\n    const finalResult = []\r\n\r\n    while (++index < result.length) {\r\n      // @ts-expect-error Assume no booleans in array.\r\n      finalResult[index] = parsePrimitive(info, info.property, result[index])\r\n    }\r\n\r\n    result = finalResult\r\n  }\r\n\r\n  // Class names (which can be added both on the `selector` and here).\r\n  if (info.property === 'className' && Array.isArray(properties.className)) {\r\n    // @ts-expect-error Assume no booleans in `className`.\r\n    result = properties.className.concat(result)\r\n  }\r\n\r\n  properties[info.property] = result\r\n}\r\n\r\n/**\r\n * @param {Array<Content>} nodes\r\n * @param {HChild} value\r\n * @returns {void}\r\n */\r\nfunction addChild(nodes, value) {\r\n  let index = -1\r\n\r\n  if (value === undefined || value === null) {\r\n    // Empty.\r\n  } else if (typeof value === 'string' || typeof value === 'number') {\r\n    nodes.push({type: 'text', value: String(value)})\r\n  } else if (Array.isArray(value)) {\r\n    while (++index < value.length) {\r\n      addChild(nodes, value[index])\r\n    }\r\n  } else if (typeof value === 'object' && 'type' in value) {\r\n    if (value.type === 'root') {\r\n      addChild(nodes, value.children)\r\n    } else {\r\n      nodes.push(value)\r\n    }\r\n  } else {\r\n    throw new Error('Expected node, nodes, or string, got `' + value + '`')\r\n  }\r\n}\r\n\r\n/**\r\n * Parse a single primitives.\r\n *\r\n * @param {Info} info\r\n * @param {string} name\r\n * @param {HPrimitiveValue} value\r\n * @returns {HPrimitiveValue}\r\n */\r\nfunction parsePrimitive(info, name, value) {\r\n  if (typeof value === 'string') {\r\n    if (info.number && value && !Number.isNaN(Number(value))) {\r\n      return Number(value)\r\n    }\r\n\r\n    if (\r\n      (info.boolean || info.overloadedBoolean) &&\r\n      (value === '' || normalize(value) === normalize(name))\r\n    ) {\r\n      return true\r\n    }\r\n  }\r\n\r\n  return value\r\n}\r\n\r\n/**\r\n * Serialize a `style` object as a string.\r\n *\r\n * @param {HStyle} value\r\n *   Style object.\r\n * @returns {string}\r\n *   CSS string.\r\n */\r\nfunction style(value) {\r\n  /** @type {Array<string>} */\r\n  const result = []\r\n  /** @type {string} */\r\n  let key\r\n\r\n  for (key in value) {\r\n    if (own.call(value, key)) {\r\n      result.push([key, value[key]].join(': '))\r\n    }\r\n  }\r\n\r\n  return result.join('; ')\r\n}\r\n\r\n/**\r\n * Create a map to adjust casing.\r\n *\r\n * @param {Array<string>} values\r\n *   List of properly cased keys.\r\n * @returns {Record<string, string>}\r\n *   Map of lowercase keys to uppercase keys.\r\n */\r\nfunction createAdjustMap(values) {\r\n  /** @type {Record<string, string>} */\r\n  const result = {}\r\n  let index = -1\r\n\r\n  while (++index < values.length) {\r\n    result[values[index].toLowerCase()] = values[index]\r\n  }\r\n\r\n  return result\r\n}\r\n", "/**\r\n * @typedef {import('./core.js').HChild} Child\r\n *   Acceptable child value.\r\n * @typedef {import('./core.js').HProperties} Properties\r\n *   Acceptable value for element properties.\r\n * @typedef {import('./core.js').HResult} Result\r\n *   Result from a `h` (or `s`) call.\r\n *\r\n * @typedef {import('./jsx-classic.js').Element} h.JSX.Element\r\n * @typedef {import('./jsx-classic.js').IntrinsicAttributes} h.JSX.IntrinsicAttributes\r\n * @typedef {import('./jsx-classic.js').IntrinsicElements} h.JSX.IntrinsicElements\r\n * @typedef {import('./jsx-classic.js').ElementChildrenAttribute} h.JSX.ElementChildrenAttribute\r\n */\r\n\r\nimport {html} from 'property-information'\r\nimport {core} from './core.js'\r\n\r\nexport const h = core(html, 'div')\r\n", "export const svgCaseSensitiveTagNames = [\r\n  'altGlyph',\r\n  'altGlyphDef',\r\n  'altGlyphItem',\r\n  'animateColor',\r\n  'animateMotion',\r\n  'animateTransform',\r\n  'clipPath',\r\n  'feBlend',\r\n  'feColorMatrix',\r\n  'feComponentTransfer',\r\n  'feComposite',\r\n  'feConvolveMatrix',\r\n  'feDiffuseLighting',\r\n  'feDisplacementMap',\r\n  'feDistantLight',\r\n  'feDropShadow',\r\n  'feFlood',\r\n  'feFuncA',\r\n  'feFuncB',\r\n  'feFuncG',\r\n  'feFuncR',\r\n  'feGaussianBlur',\r\n  'feImage',\r\n  'feMerge',\r\n  'feMergeNode',\r\n  'feMorphology',\r\n  'feOffset',\r\n  'fePointLight',\r\n  'feSpecularLighting',\r\n  'feSpotLight',\r\n  'feTile',\r\n  'feTurbulence',\r\n  'foreignObject',\r\n  'glyphRef',\r\n  'linearGradient',\r\n  'radialGradient',\r\n  'solidColor',\r\n  'textArea',\r\n  'textPath'\r\n]\r\n", "/**\r\n * @typedef {import('./core.js').HChild} Child\r\n *   Acceptable child value.\r\n * @typedef {import('./core.js').HProperties} Properties\r\n *   Acceptable value for element properties.\r\n * @typedef {import('./core.js').HResult} Result\r\n *   Result from a `h` (or `s`) call.\r\n *\r\n * @typedef {import('./jsx-classic.js').Element} s.JSX.Element\r\n * @typedef {import('./jsx-classic.js').IntrinsicAttributes} s.JSX.IntrinsicAttributes\r\n * @typedef {import('./jsx-classic.js').IntrinsicElements} s.JSX.IntrinsicElements\r\n * @typedef {import('./jsx-classic.js').ElementChildrenAttribute} s.JSX.ElementChildrenAttribute\r\n */\r\n\r\nimport {svg} from 'property-information'\r\nimport {core} from './core.js'\r\nimport {svgCaseSensitiveTagNames} from './svg-case-sensitive-tag-names.js'\r\n\r\nexport const s = core(svg, 'g', svgCaseSensitiveTagNames)\r\n", "/**\r\n * Map of web namespaces.\r\n *\r\n * @type {Record<string, string>}\r\n */\r\nexport const webNamespaces = {\r\n  html: 'http://www.w3.org/1999/xhtml',\r\n  mathml: 'http://www.w3.org/1998/Math/MathML',\r\n  svg: 'http://www.w3.org/2000/svg',\r\n  xlink: 'http://www.w3.org/1999/xlink',\r\n  xml: 'http://www.w3.org/XML/1998/namespace',\r\n  xmlns: 'http://www.w3.org/2000/xmlns/'\r\n}\r\n"],
  "mappings": "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",
  "names": ["h", "parse"]
}
