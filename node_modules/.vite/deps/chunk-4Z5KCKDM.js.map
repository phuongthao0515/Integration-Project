{
  "version": 3,
  "sources": ["../../mdast-util-to-markdown/lib/util/association.js", "../../mdast-util-to-markdown/lib/util/container-flow.js", "../../mdast-util-to-markdown/lib/util/indent-lines.js", "../../mdast-util-to-markdown/lib/util/pattern-compile.js", "../../mdast-util-to-markdown/lib/util/pattern-in-scope.js", "../../mdast-util-to-markdown/lib/util/safe.js", "../../mdast-util-to-markdown/lib/util/track.js", "../../mdast-util-to-markdown/lib/util/container-phrasing.js", "../../mdast-util-to-markdown/lib/handle/inline-code.js", "../../mdast-util-to-markdown/lib/util/check-bullet.js", "../../mdast-util-to-markdown/lib/util/check-list-item-indent.js", "../../mdast-util-to-markdown/lib/handle/list-item.js"],
  "sourcesContent": ["/**\r\n * @typedef {import('../types.js').AssociationId} AssociationId\r\n */\r\n\r\nimport {decodeString} from 'micromark-util-decode-string'\r\n\r\n/**\r\n * Get an identifier from an association to match it to others.\r\n *\r\n * Associations are nodes that match to something else through an ID:\r\n * <https://github.com/syntax-tree/mdast#association>.\r\n *\r\n * The `label` of an association is the string value: character escapes and\r\n * references work, and casing is intact.\r\n * The `identifier` is used to match one association to another:\r\n * controversially, character escapes and references don’t work in this\r\n * matching: `&copy;` does not match `©`, and `\\+` does not match `+`.\r\n *\r\n * But casing is ignored (and whitespace) is trimmed and collapsed: ` A\\nb`\r\n * matches `a b`.\r\n * So, we do prefer the label when figuring out how we’re going to serialize:\r\n * it has whitespace, casing, and we can ignore most useless character\r\n * escapes and all character references.\r\n *\r\n * @type {AssociationId}\r\n */\r\nexport function association(node) {\r\n  if (node.label || !node.identifier) {\r\n    return node.label || ''\r\n  }\r\n\r\n  return decodeString(node.identifier)\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').FlowContent} FlowContent\r\n * @typedef {import('../types.js').Node} Node\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').TrackFields} TrackFields\r\n */\r\n\r\n/**\r\n * @param {Parent & {children: Array<FlowContent>}} parent\r\n *   Parent of flow nodes.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @param {TrackFields} info\r\n *   Info on where we are in the document we are generating.\r\n * @returns {string}\r\n *   Serialized children, joined by (blank) lines.\r\n */\r\nexport function containerFlow(parent, state, info) {\r\n  const indexStack = state.indexStack\r\n  const children = parent.children || []\r\n  const tracker = state.createTracker(info)\r\n  /** @type {Array<string>} */\r\n  const results = []\r\n  let index = -1\r\n\r\n  indexStack.push(-1)\r\n\r\n  while (++index < children.length) {\r\n    const child = children[index]\r\n\r\n    indexStack[indexStack.length - 1] = index\r\n\r\n    results.push(\r\n      tracker.move(\r\n        state.handle(child, parent, state, {\r\n          before: '\\n',\r\n          after: '\\n',\r\n          ...tracker.current()\r\n        })\r\n      )\r\n    )\r\n\r\n    if (child.type !== 'list') {\r\n      state.bulletLastUsed = undefined\r\n    }\r\n\r\n    if (index < children.length - 1) {\r\n      results.push(\r\n        tracker.move(between(child, children[index + 1], parent, state))\r\n      )\r\n    }\r\n  }\r\n\r\n  indexStack.pop()\r\n\r\n  return results.join('')\r\n}\r\n\r\n/**\r\n * @param {Node} left\r\n * @param {Node} right\r\n * @param {Parent} parent\r\n * @param {State} state\r\n * @returns {string}\r\n */\r\nfunction between(left, right, parent, state) {\r\n  let index = state.join.length\r\n\r\n  while (index--) {\r\n    const result = state.join[index](left, right, parent, state)\r\n\r\n    if (result === true || result === 1) {\r\n      break\r\n    }\r\n\r\n    if (typeof result === 'number') {\r\n      return '\\n'.repeat(1 + result)\r\n    }\r\n\r\n    if (result === false) {\r\n      return '\\n\\n<!---->\\n\\n'\r\n    }\r\n  }\r\n\r\n  return '\\n\\n'\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').IndentLines} IndentLines\r\n */\r\n\r\nconst eol = /\\r?\\n|\\r/g\r\n\r\n/**\r\n * @type {IndentLines}\r\n */\r\nexport function indentLines(value, map) {\r\n  /** @type {Array<string>} */\r\n  const result = []\r\n  let start = 0\r\n  let line = 0\r\n  /** @type {RegExpExecArray | null} */\r\n  let match\r\n\r\n  while ((match = eol.exec(value))) {\r\n    one(value.slice(start, match.index))\r\n    result.push(match[0])\r\n    start = match.index + match[0].length\r\n    line++\r\n  }\r\n\r\n  one(value.slice(start))\r\n\r\n  return result.join('')\r\n\r\n  /**\r\n   * @param {string} value\r\n   */\r\n  function one(value) {\r\n    result.push(map(value, line, !value))\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').Unsafe} Unsafe\r\n */\r\n\r\n/**\r\n * @param {Unsafe} pattern\r\n * @returns {RegExp}\r\n */\r\nexport function patternCompile(pattern) {\r\n  if (!pattern._compiled) {\r\n    const before =\r\n      (pattern.atBreak ? '[\\\\r\\\\n][\\\\t ]*' : '') +\r\n      (pattern.before ? '(?:' + pattern.before + ')' : '')\r\n\r\n    pattern._compiled = new RegExp(\r\n      (before ? '(' + before + ')' : '') +\r\n        (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') +\r\n        pattern.character +\r\n        (pattern.after ? '(?:' + pattern.after + ')' : ''),\r\n      'g'\r\n    )\r\n  }\r\n\r\n  return pattern._compiled\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').Unsafe} Unsafe\r\n * @typedef {import('../types.js').ConstructName} ConstructName\r\n */\r\n\r\n/**\r\n * @param {Array<ConstructName>} stack\r\n * @param {Unsafe} pattern\r\n * @returns {boolean}\r\n */\r\nexport function patternInScope(stack, pattern) {\r\n  return (\r\n    listInScope(stack, pattern.inConstruct, true) &&\r\n    !listInScope(stack, pattern.notInConstruct, false)\r\n  )\r\n}\r\n\r\n/**\r\n * @param {Array<ConstructName>} stack\r\n * @param {Unsafe['inConstruct']} list\r\n * @param {boolean} none\r\n * @returns {boolean}\r\n */\r\nfunction listInScope(stack, list, none) {\r\n  if (typeof list === 'string') {\r\n    list = [list]\r\n  }\r\n\r\n  if (!list || list.length === 0) {\r\n    return none\r\n  }\r\n\r\n  let index = -1\r\n\r\n  while (++index < list.length) {\r\n    if (stack.includes(list[index])) {\r\n      return true\r\n    }\r\n  }\r\n\r\n  return false\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').SafeConfig} SafeConfig\r\n */\r\n\r\nimport {patternCompile} from './pattern-compile.js'\r\nimport {patternInScope} from './pattern-in-scope.js'\r\n\r\n/**\r\n * Make a string safe for embedding in markdown constructs.\r\n *\r\n * In markdown, almost all punctuation characters can, in certain cases,\r\n * result in something.\r\n * Whether they do is highly subjective to where they happen and in what\r\n * they happen.\r\n *\r\n * To solve this, `mdast-util-to-markdown` tracks:\r\n *\r\n * * Characters before and after something;\r\n * * What “constructs” we are in.\r\n *\r\n * This information is then used by this function to escape or encode\r\n * special characters.\r\n *\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @param {string | null | undefined} input\r\n *   Raw value to make safe.\r\n * @param {SafeConfig} config\r\n *   Configuration.\r\n * @returns {string}\r\n *   Serialized markdown safe for embedding.\r\n */\r\nexport function safe(state, input, config) {\r\n  const value = (config.before || '') + (input || '') + (config.after || '')\r\n  /** @type {Array<number>} */\r\n  const positions = []\r\n  /** @type {Array<string>} */\r\n  const result = []\r\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\r\n  const infos = {}\r\n  let index = -1\r\n\r\n  while (++index < state.unsafe.length) {\r\n    const pattern = state.unsafe[index]\r\n\r\n    if (!patternInScope(state.stack, pattern)) {\r\n      continue\r\n    }\r\n\r\n    const expression = patternCompile(pattern)\r\n    /** @type {RegExpExecArray | null} */\r\n    let match\r\n\r\n    while ((match = expression.exec(value))) {\r\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\r\n      const after = 'after' in pattern\r\n      const position = match.index + (before ? match[1].length : 0)\r\n\r\n      if (positions.includes(position)) {\r\n        if (infos[position].before && !before) {\r\n          infos[position].before = false\r\n        }\r\n\r\n        if (infos[position].after && !after) {\r\n          infos[position].after = false\r\n        }\r\n      } else {\r\n        positions.push(position)\r\n        infos[position] = {before, after}\r\n      }\r\n    }\r\n  }\r\n\r\n  positions.sort(numerical)\r\n\r\n  let start = config.before ? config.before.length : 0\r\n  const end = value.length - (config.after ? config.after.length : 0)\r\n  index = -1\r\n\r\n  while (++index < positions.length) {\r\n    const position = positions[index]\r\n\r\n    // Character before or after matched:\r\n    if (position < start || position >= end) {\r\n      continue\r\n    }\r\n\r\n    // If this character is supposed to be escaped because it has a condition on\r\n    // the next character, and the next character is definitly being escaped,\r\n    // then skip this escape.\r\n    if (\r\n      (position + 1 < end &&\r\n        positions[index + 1] === position + 1 &&\r\n        infos[position].after &&\r\n        !infos[position + 1].before &&\r\n        !infos[position + 1].after) ||\r\n      (positions[index - 1] === position - 1 &&\r\n        infos[position].before &&\r\n        !infos[position - 1].before &&\r\n        !infos[position - 1].after)\r\n    ) {\r\n      continue\r\n    }\r\n\r\n    if (start !== position) {\r\n      // If we have to use a character reference, an ampersand would be more\r\n      // correct, but as backslashes only care about punctuation, either will\r\n      // do the trick\r\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\r\n    }\r\n\r\n    start = position\r\n\r\n    if (\r\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\r\n      (!config.encode || !config.encode.includes(value.charAt(position)))\r\n    ) {\r\n      // Character escape.\r\n      result.push('\\\\')\r\n    } else {\r\n      // Character reference.\r\n      result.push(\r\n        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'\r\n      )\r\n      start++\r\n    }\r\n  }\r\n\r\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\r\n\r\n  return result.join('')\r\n}\r\n\r\n/**\r\n * @param {number} a\r\n * @param {number} b\r\n * @returns {number}\r\n */\r\nfunction numerical(a, b) {\r\n  return a - b\r\n}\r\n\r\n/**\r\n * @param {string} value\r\n * @param {string} after\r\n * @returns {string}\r\n */\r\nfunction escapeBackslashes(value, after) {\r\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\r\n  /** @type {Array<number>} */\r\n  const positions = []\r\n  /** @type {Array<string>} */\r\n  const results = []\r\n  const whole = value + after\r\n  let index = -1\r\n  let start = 0\r\n  /** @type {RegExpExecArray | null} */\r\n  let match\r\n\r\n  while ((match = expression.exec(whole))) {\r\n    positions.push(match.index)\r\n  }\r\n\r\n  while (++index < positions.length) {\r\n    if (start !== positions[index]) {\r\n      results.push(value.slice(start, positions[index]))\r\n    }\r\n\r\n    results.push('\\\\')\r\n    start = positions[index]\r\n  }\r\n\r\n  results.push(value.slice(start))\r\n\r\n  return results.join('')\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').CreateTracker} CreateTracker\r\n * @typedef {import('../types.js').TrackCurrent} TrackCurrent\r\n * @typedef {import('../types.js').TrackMove} TrackMove\r\n * @typedef {import('../types.js').TrackShift} TrackShift\r\n */\r\n\r\n/**\r\n * Track positional info in the output.\r\n *\r\n * @type {CreateTracker}\r\n */\r\nexport function track(config) {\r\n  // Defaults are used to prevent crashes when older utilities somehow activate\r\n  // this code.\r\n  /* c8 ignore next 5 */\r\n  const options = config || {}\r\n  const now = options.now || {}\r\n  let lineShift = options.lineShift || 0\r\n  let line = now.line || 1\r\n  let column = now.column || 1\r\n\r\n  return {move, current, shift}\r\n\r\n  /**\r\n   * Get the current tracked info.\r\n   *\r\n   * @type {TrackCurrent}\r\n   */\r\n  function current() {\r\n    return {now: {line, column}, lineShift}\r\n  }\r\n\r\n  /**\r\n   * Define an increased line shift (the typical indent for lines).\r\n   *\r\n   * @type {TrackShift}\r\n   */\r\n  function shift(value) {\r\n    lineShift += value\r\n  }\r\n\r\n  /**\r\n   * Move past some generated markdown.\r\n   *\r\n   * @type {TrackMove}\r\n   */\r\n  function move(input) {\r\n    // eslint-disable-next-line unicorn/prefer-default-parameters\r\n    const value = input || ''\r\n    const chunks = value.split(/\\r?\\n|\\r/g)\r\n    const tail = chunks[chunks.length - 1]\r\n    line += chunks.length - 1\r\n    column =\r\n      chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift\r\n    return value\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').Handle} Handle\r\n * @typedef {import('../types.js').Info} Info\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').PhrasingContent} PhrasingContent\r\n * @typedef {import('../types.js').State} State\r\n */\r\n\r\n/**\r\n * Serialize the children of a parent that contains phrasing children.\r\n *\r\n * These children will be joined flush together.\r\n *\r\n * @param {Parent & {children: Array<PhrasingContent>}} parent\r\n *   Parent of flow nodes.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @param {Info} info\r\n *   Info on where we are in the document we are generating.\r\n * @returns {string}\r\n *   Serialized children, joined together.\r\n */\r\nexport function containerPhrasing(parent, state, info) {\r\n  const indexStack = state.indexStack\r\n  const children = parent.children || []\r\n  /** @type {Array<string>} */\r\n  const results = []\r\n  let index = -1\r\n  let before = info.before\r\n\r\n  indexStack.push(-1)\r\n  let tracker = state.createTracker(info)\r\n\r\n  while (++index < children.length) {\r\n    const child = children[index]\r\n    /** @type {string} */\r\n    let after\r\n\r\n    indexStack[indexStack.length - 1] = index\r\n\r\n    if (index + 1 < children.length) {\r\n      /** @type {Handle} */\r\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\r\n      let handle = state.handle.handlers[children[index + 1].type]\r\n      /** @type {Handle} */\r\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\r\n      if (handle && handle.peek) handle = handle.peek\r\n      after = handle\r\n        ? handle(children[index + 1], parent, state, {\r\n            before: '',\r\n            after: '',\r\n            ...tracker.current()\r\n          }).charAt(0)\r\n        : ''\r\n    } else {\r\n      after = info.after\r\n    }\r\n\r\n    // In some cases, html (text) can be found in phrasing right after an eol.\r\n    // When we’d serialize that, in most cases that would be seen as html\r\n    // (flow).\r\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\r\n    // reasonable approach: replace that eol with a space.\r\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\r\n    if (\r\n      results.length > 0 &&\r\n      (before === '\\r' || before === '\\n') &&\r\n      child.type === 'html'\r\n    ) {\r\n      results[results.length - 1] = results[results.length - 1].replace(\r\n        /(\\r?\\n|\\r)$/,\r\n        ' '\r\n      )\r\n      before = ' '\r\n\r\n      // To do: does this work to reset tracker?\r\n      tracker = state.createTracker(info)\r\n      tracker.move(results.join(''))\r\n    }\r\n\r\n    results.push(\r\n      tracker.move(\r\n        state.handle(child, parent, state, {\r\n          ...tracker.current(),\r\n          before,\r\n          after\r\n        })\r\n      )\r\n    )\r\n\r\n    before = results[results.length - 1].slice(-1)\r\n  }\r\n\r\n  indexStack.pop()\r\n\r\n  return results.join('')\r\n}\r\n", "/**\r\n * @typedef {import('mdast').InlineCode} InlineCode\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').State} State\r\n */\r\n\r\nimport {patternCompile} from '../util/pattern-compile.js'\r\n\r\ninlineCode.peek = inlineCodePeek\r\n\r\n/**\r\n * @param {InlineCode} node\r\n * @param {Parent | undefined} _\r\n * @param {State} state\r\n * @returns {string}\r\n */\r\nexport function inlineCode(node, _, state) {\r\n  let value = node.value || ''\r\n  let sequence = '`'\r\n  let index = -1\r\n\r\n  // If there is a single grave accent on its own in the code, use a fence of\r\n  // two.\r\n  // If there are two in a row, use one.\r\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\r\n    sequence += '`'\r\n  }\r\n\r\n  // If this is not just spaces or eols (tabs don’t count), and either the\r\n  // first or last character are a space, eol, or tick, then pad with spaces.\r\n  if (\r\n    /[^ \\r\\n]/.test(value) &&\r\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\r\n  ) {\r\n    value = ' ' + value + ' '\r\n  }\r\n\r\n  // We have a potential problem: certain characters after eols could result in\r\n  // blocks being seen.\r\n  // For example, if someone injected the string `'\\n# b'`, then that would\r\n  // result in an ATX heading.\r\n  // We can’t escape characters in `inlineCode`, but because eols are\r\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\r\n  // them out.\r\n  while (++index < state.unsafe.length) {\r\n    const pattern = state.unsafe[index]\r\n    const expression = patternCompile(pattern)\r\n    /** @type {RegExpExecArray | null} */\r\n    let match\r\n\r\n    // Only look for `atBreak`s.\r\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\r\n    // CR.\r\n    if (!pattern.atBreak) continue\r\n\r\n    while ((match = expression.exec(value))) {\r\n      let position = match.index\r\n\r\n      // Support CRLF (patterns only look for one of the characters).\r\n      if (\r\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\r\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\r\n      ) {\r\n        position--\r\n      }\r\n\r\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\r\n    }\r\n  }\r\n\r\n  return sequence + value + sequence\r\n}\r\n\r\n/**\r\n * @returns {string}\r\n */\r\nfunction inlineCodePeek() {\r\n  return '`'\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Options} Options\r\n */\r\n\r\n/**\r\n * @param {State} state\r\n * @returns {Exclude<Options['bullet'], null | undefined>}\r\n */\r\nexport function checkBullet(state) {\r\n  const marker = state.options.bullet || '*'\r\n\r\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\r\n    throw new Error(\r\n      'Cannot serialize items with `' +\r\n        marker +\r\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\r\n    )\r\n  }\r\n\r\n  return marker\r\n}\r\n", "/**\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Options} Options\r\n */\r\n\r\n/**\r\n * @param {State} state\r\n * @returns {Exclude<Options['listItemIndent'], null | undefined>}\r\n */\r\nexport function checkListItemIndent(state) {\r\n  const style = state.options.listItemIndent || 'tab'\r\n\r\n  // To do: remove in a major.\r\n  // @ts-expect-error: deprecated.\r\n  if (style === 1 || style === '1') {\r\n    return 'one'\r\n  }\r\n\r\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\r\n    throw new Error(\r\n      'Cannot serialize items with `' +\r\n        style +\r\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\r\n    )\r\n  }\r\n\r\n  return style\r\n}\r\n", "/**\r\n * @typedef {import('mdast').ListItem} ListItem\r\n * @typedef {import('../types.js').Map} Map\r\n * @typedef {import('../types.js').Parent} Parent\r\n * @typedef {import('../types.js').State} State\r\n * @typedef {import('../types.js').Info} Info\r\n */\r\n\r\nimport {checkBullet} from '../util/check-bullet.js'\r\nimport {checkListItemIndent} from '../util/check-list-item-indent.js'\r\n\r\n/**\r\n * @param {ListItem} node\r\n * @param {Parent | undefined} parent\r\n * @param {State} state\r\n * @param {Info} info\r\n * @returns {string}\r\n */\r\nexport function listItem(node, parent, state, info) {\r\n  const listItemIndent = checkListItemIndent(state)\r\n  let bullet = state.bulletCurrent || checkBullet(state)\r\n\r\n  // Add the marker value for ordered lists.\r\n  if (parent && parent.type === 'list' && parent.ordered) {\r\n    bullet =\r\n      (typeof parent.start === 'number' && parent.start > -1\r\n        ? parent.start\r\n        : 1) +\r\n      (state.options.incrementListMarker === false\r\n        ? 0\r\n        : parent.children.indexOf(node)) +\r\n      bullet\r\n  }\r\n\r\n  let size = bullet.length + 1\r\n\r\n  if (\r\n    listItemIndent === 'tab' ||\r\n    (listItemIndent === 'mixed' &&\r\n      ((parent && parent.type === 'list' && parent.spread) || node.spread))\r\n  ) {\r\n    size = Math.ceil(size / 4) * 4\r\n  }\r\n\r\n  const tracker = state.createTracker(info)\r\n  tracker.move(bullet + ' '.repeat(size - bullet.length))\r\n  tracker.shift(size)\r\n  const exit = state.enter('listItem')\r\n  const value = state.indentLines(\r\n    state.containerFlow(node, tracker.current()),\r\n    map\r\n  )\r\n  exit()\r\n\r\n  return value\r\n\r\n  /** @type {Map} */\r\n  function map(line, index, blank) {\r\n    if (index) {\r\n      return (blank ? '' : ' '.repeat(size)) + line\r\n    }\r\n\r\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["value"]
}
