import {
  phrasing
} from "./chunk-V4D5A2GK.js";
import {
  toString
} from "./chunk-FTBH5HZY.js";
import {
  EXIT,
  SKIP,
  visit
} from "./chunk-LVAE7Q6E.js";
import {
  require_extend
} from "./chunk-XOEV7YGI.js";
import {
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/rehype-minify-whitespace/node_modules/hast-util-is-element/index.js
var isElement = (
  /**
   * @type {(
   *   (() => false) &
   *   (<T extends Element = Element>(node: unknown, test?: PredicateTest<T>, index?: number, parent?: Parent, context?: unknown) => node is T) &
   *   ((node: unknown, test: Test, index?: number, parent?: Parent, context?: unknown) => boolean)
   * )}
   */
  /**
   * @param {unknown} [node]
   * @param {Test | undefined} [test]
   * @param {number | null | undefined} [index]
   * @param {Parent | null | undefined} [parent]
   * @param {unknown} [context]
   * @returns {boolean}
   */
  // eslint-disable-next-line max-params
  function(node2, test, index, parent, context) {
    const check = convertElement(test);
    if (index !== void 0 && index !== null && (typeof index !== "number" || index < 0 || index === Number.POSITIVE_INFINITY)) {
      throw new Error("Expected positive finite index for child node");
    }
    if (parent !== void 0 && parent !== null && (!parent.type || !parent.children)) {
      throw new Error("Expected parent node");
    }
    if (!node2 || !node2.type || typeof node2.type !== "string") {
      return false;
    }
    if ((parent === void 0 || parent === null) !== (index === void 0 || index === null)) {
      throw new Error("Expected both parent and index");
    }
    return check.call(context, node2, index, parent);
  }
);
var convertElement = (
  /**
   * @type {(
   *   (<T extends Element>(test: T['tagName'] | TestFunctionPredicate<T>) => AssertPredicate<T>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test | null | undefined} [test]
   * @returns {AssertAnything}
   */
  function(test) {
    if (test === void 0 || test === null) {
      return element;
    }
    if (typeof test === "string") {
      return tagNameFactory(test);
    }
    if (typeof test === "object") {
      return anyFactory(test);
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    throw new Error("Expected function, string, or array as test");
  }
);
function anyFactory(tests) {
  const checks = [];
  let index = -1;
  while (++index < tests.length) {
    checks[index] = convertElement(tests[index]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index2 = -1;
    while (++index2 < checks.length) {
      if (checks[index2].call(this, ...parameters)) {
        return true;
      }
    }
    return false;
  }
}
function tagNameFactory(check) {
  return tagName;
  function tagName(node2) {
    return element(node2) && node2.tagName === check;
  }
}
function castFactory(check) {
  return assertion;
  function assertion(node2, ...parameters) {
    return element(node2) && Boolean(check.call(this, node2, ...parameters));
  }
}
function element(node2) {
  return Boolean(
    node2 && typeof node2 === "object" && // @ts-expect-error Looks like a node.
    node2.type === "element" && // @ts-expect-error Looks like an element.
    typeof node2.tagName === "string"
  );
}

// node_modules/rehype-minify-whitespace/node_modules/hast-util-embedded/lib/index.js
var embedded = convertElement([
  "audio",
  "canvas",
  "embed",
  "iframe",
  "img",
  "math",
  "object",
  "picture",
  "svg",
  "video"
]);

// node_modules/rehype-minify-whitespace/node_modules/unist-util-is/lib/index.js
var convert = (
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {AssertAnything}
   */
  function(test) {
    if (test === void 0 || test === null) {
      return ok;
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory2(test) : propsFactory(test);
    }
    if (typeof test === "function") {
      return castFactory2(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory2(tests) {
  const checks = [];
  let index = -1;
  while (++index < tests.length) {
    checks[index] = convert(tests[index]);
  }
  return castFactory2(any);
  function any(...parameters) {
    let index2 = -1;
    while (++index2 < checks.length) {
      if (checks[index2].call(this, ...parameters)) return true;
    }
    return false;
  }
}
function propsFactory(check) {
  return castFactory2(all3);
  function all3(node2) {
    let key;
    for (key in check) {
      if (node2[key] !== check[key]) return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory2(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory2(check) {
  return assertion;
  function assertion(node2, ...parameters) {
    return Boolean(
      node2 && typeof node2 === "object" && "type" in node2 && // @ts-expect-error: fine.
      Boolean(check.call(this, node2, ...parameters))
    );
  }
}
function ok() {
  return true;
}

// node_modules/rehype-minify-whitespace/node_modules/hast-util-whitespace/index.js
function whitespace(thing) {
  const value = (
    // @ts-expect-error looks like a node.
    thing && typeof thing === "object" && thing.type === "text" ? (
      // @ts-expect-error looks like a text.
      thing.value || ""
    ) : thing
  );
  return typeof value === "string" && value.replace(/[ \t\n\f\r]/g, "") === "";
}

// node_modules/rehype-minify-whitespace/block.js
var blocks = [
  "address",
  // Flow content.
  "article",
  // Sections and headings.
  "aside",
  // Sections and headings.
  "blockquote",
  // Flow content.
  "body",
  // Page.
  "br",
  // Contribute whitespace intrinsically.
  "caption",
  // Similar to block.
  "center",
  // Flow content, legacy.
  "col",
  // Similar to block.
  "colgroup",
  // Similar to block.
  "dd",
  // Lists.
  "dialog",
  // Flow content.
  "dir",
  // Lists, legacy.
  "div",
  // Flow content.
  "dl",
  // Lists.
  "dt",
  // Lists.
  "figcaption",
  // Flow content.
  "figure",
  // Flow content.
  "footer",
  // Flow content.
  "form",
  // Flow content.
  "h1",
  // Sections and headings.
  "h2",
  // Sections and headings.
  "h3",
  // Sections and headings.
  "h4",
  // Sections and headings.
  "h5",
  // Sections and headings.
  "h6",
  // Sections and headings.
  "head",
  // Page.
  "header",
  // Flow content.
  "hgroup",
  // Sections and headings.
  "hr",
  // Flow content.
  "html",
  // Page.
  "legend",
  // Flow content.
  "li",
  // Block-like.
  "li",
  // Similar to block.
  "listing",
  // Flow content, legacy
  "main",
  // Flow content.
  "menu",
  // Lists.
  "nav",
  // Sections and headings.
  "ol",
  // Lists.
  "optgroup",
  // Similar to block.
  "option",
  // Similar to block.
  "p",
  // Flow content.
  "plaintext",
  // Flow content, legacy
  "pre",
  // Flow content.
  "section",
  // Sections and headings.
  "summary",
  // Similar to block.
  "table",
  // Similar to block.
  "tbody",
  // Similar to block.
  "td",
  // Block-like.
  "td",
  // Similar to block.
  "tfoot",
  // Similar to block.
  "th",
  // Block-like.
  "th",
  // Similar to block.
  "thead",
  // Similar to block.
  "tr",
  // Similar to block.
  "ul",
  // Lists.
  "wbr",
  // Contribute whitespace intrinsically.
  "xmp"
  // Flow content, legacy
];

// node_modules/rehype-minify-whitespace/content.js
var content = [
  // Form.
  "button",
  "input",
  "select",
  "textarea"
];

// node_modules/rehype-minify-whitespace/skippable.js
var skippable = [
  "area",
  "base",
  "basefont",
  "dialog",
  "datalist",
  "head",
  "link",
  "meta",
  "noembed",
  "noframes",
  "param",
  "rp",
  "script",
  "source",
  "style",
  "template",
  "track",
  "title"
];

// node_modules/rehype-minify-whitespace/index.js
var ignorableNode = convert(["doctype", "comment"]);
function rehypeMinifyWhitespace(options = {}) {
  const collapse = collapseFactory(
    options.newlines ? replaceNewlines : replaceWhitespace
  );
  return (tree) => {
    minify(tree, { collapse, whitespace: "normal" });
  };
}
function minify(node2, context) {
  if ("children" in node2) {
    const settings = Object.assign({}, context);
    if (node2.type === "root" || blocklike(node2)) {
      settings.before = true;
      settings.after = true;
    }
    settings.whitespace = inferWhiteSpace(node2, context);
    return all(node2, settings);
  }
  if (node2.type === "text") {
    if (context.whitespace === "normal") {
      return minifyText(node2, context);
    }
    if (context.whitespace === "nowrap") {
      node2.value = context.collapse(node2.value);
    }
  }
  return { remove: false, ignore: ignorableNode(node2), stripAtStart: false };
}
function minifyText(node2, context) {
  const value = context.collapse(node2.value);
  const result = { remove: false, ignore: false, stripAtStart: false };
  let start = 0;
  let end = value.length;
  if (context.before && removable(value.charAt(0))) {
    start++;
  }
  if (start !== end && removable(value.charAt(end - 1))) {
    if (context.after) {
      end--;
    } else {
      result.stripAtStart = true;
    }
  }
  if (start === end) {
    result.remove = true;
  } else {
    node2.value = value.slice(start, end);
  }
  return result;
}
function all(parent, context) {
  let before = context.before;
  const after = context.after;
  const children = parent.children;
  let length = children.length;
  let index = -1;
  while (++index < length) {
    const result = minify(
      children[index],
      Object.assign({}, context, {
        before,
        after: collapsableAfter(children, index, after)
      })
    );
    if (result.remove) {
      children.splice(index, 1);
      index--;
      length--;
    } else if (!result.ignore) {
      before = result.stripAtStart;
    }
    if (content2(children[index])) {
      before = false;
    }
  }
  return { remove: false, ignore: false, stripAtStart: Boolean(before || after) };
}
function collapsableAfter(nodes, index, after) {
  while (++index < nodes.length) {
    const node2 = nodes[index];
    let result = inferBoundary(node2);
    if (result === void 0 && "children" in node2 && !skippable2(node2)) {
      result = collapsableAfter(node2.children, -1);
    }
    if (typeof result === "boolean") {
      return result;
    }
  }
  return after;
}
function inferBoundary(node2) {
  if (node2.type === "element") {
    if (content2(node2)) {
      return false;
    }
    if (blocklike(node2)) {
      return true;
    }
  } else if (node2.type === "text") {
    if (!whitespace(node2)) {
      return false;
    }
  } else if (!ignorableNode(node2)) {
    return false;
  }
}
function content2(node2) {
  return embedded(node2) || isElement(node2, content);
}
function blocklike(node2) {
  return isElement(node2, blocks);
}
function skippable2(node2) {
  return Boolean(
    "properties" in node2 && node2.properties && node2.properties.hidden
  ) || ignorableNode(node2) || isElement(node2, skippable);
}
function removable(character) {
  return character === " " || character === "\n";
}
function replaceNewlines(value) {
  const match = /\r?\n|\r/.exec(value);
  return match ? match[0] : " ";
}
function replaceWhitespace() {
  return " ";
}
function collapseFactory(replace) {
  return collapse;
  function collapse(value) {
    return String(value).replace(/[\t\n\v\f\r ]+/g, replace);
  }
}
function inferWhiteSpace(node2, context) {
  if ("tagName" in node2 && node2.properties) {
    switch (node2.tagName) {
      // Whitespace in script/style, while not displayed by CSS as significant,
      // could have some meaning in JS/CSS, so we can’t touch them.
      case "listing":
      case "plaintext":
      case "script":
      case "style":
      case "xmp":
        return "pre";
      case "nobr":
        return "nowrap";
      case "pre":
        return node2.properties.wrap ? "pre-wrap" : "pre";
      case "td":
      case "th":
        return node2.properties.noWrap ? "nowrap" : context.whitespace;
      case "textarea":
        return "pre-wrap";
      default:
    }
  }
  return context.whitespace;
}

// node_modules/hast-util-to-mdast/node_modules/unist-util-is/lib/index.js
var convert2 = (
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {AssertAnything}
   */
  function(test) {
    if (test === void 0 || test === null) {
      return ok2;
    }
    if (typeof test === "string") {
      return typeFactory2(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory3(test) : propsFactory2(test);
    }
    if (typeof test === "function") {
      return castFactory3(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory3(tests) {
  const checks = [];
  let index = -1;
  while (++index < tests.length) {
    checks[index] = convert2(tests[index]);
  }
  return castFactory3(any);
  function any(...parameters) {
    let index2 = -1;
    while (++index2 < checks.length) {
      if (checks[index2].call(this, ...parameters)) return true;
    }
    return false;
  }
}
function propsFactory2(check) {
  return castFactory3(all3);
  function all3(node2) {
    let key;
    for (key in check) {
      if (node2[key] !== check[key]) return false;
    }
    return true;
  }
}
function typeFactory2(check) {
  return castFactory3(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory3(check) {
  return assertion;
  function assertion(node2, ...parameters) {
    return Boolean(
      node2 && typeof node2 === "object" && "type" in node2 && // @ts-expect-error: fine.
      Boolean(check.call(this, node2, ...parameters))
    );
  }
}
function ok2() {
  return true;
}

// node_modules/hast-util-to-mdast/lib/all.js
function all2(h, parent) {
  const nodes = parent.children || [];
  const values = [];
  let index = -1;
  while (++index < nodes.length) {
    const result = one(h, nodes[index], parent);
    if (Array.isArray(result)) {
      values.push(...result);
    } else if (result) {
      values.push(result);
    }
  }
  let start = 0;
  let end = values.length;
  while (start < end && values[start].type === "break") {
    start++;
  }
  while (end > start && values[end - 1].type === "break") {
    end--;
  }
  return start === 0 && end === values.length ? values : values.slice(start, end);
}

// node_modules/hast-util-to-mdast/lib/util/own.js
var own = {}.hasOwnProperty;

// node_modules/hast-util-to-mdast/lib/util/wrap-text.js
function wrapText(h, value) {
  return h.wrapText ? value : value.replace(/\r?\n|\r/g, " ");
}

// node_modules/hast-util-to-mdast/lib/one.js
function one(h, node2, parent) {
  let fn;
  if (node2.type === "element") {
    if (node2.properties && node2.properties.dataMdast === "ignore") {
      return;
    }
    if (own.call(h.handlers, node2.tagName)) {
      fn = h.handlers[node2.tagName];
    }
  } else if (own.call(h.handlers, node2.type)) {
    fn = h.handlers[node2.type];
  }
  if (typeof fn === "function") {
    return fn(h, node2, parent);
  }
  return unknown(h, node2);
}
function unknown(h, node2) {
  if (typeof node2.value === "string") {
    return h(node2, "text", wrapText(h, node2.value));
  }
  return all2(h, node2);
}

// node_modules/hast-util-to-mdast/lib/util/wrap.js
var import_extend = __toESM(require_extend(), 1);

// node_modules/hast-util-to-mdast/node_modules/hast-util-is-element/index.js
var isElement2 = (
  /**
   * @type {(
   *   (() => false) &
   *   (<T extends Element = Element>(node: unknown, test?: PredicateTest<T>, index?: number, parent?: Parent, context?: unknown) => node is T) &
   *   ((node: unknown, test: Test, index?: number, parent?: Parent, context?: unknown) => boolean)
   * )}
   */
  /**
   * @param {unknown} [node]
   * @param {Test | undefined} [test]
   * @param {number | null | undefined} [index]
   * @param {Parent | null | undefined} [parent]
   * @param {unknown} [context]
   * @returns {boolean}
   */
  // eslint-disable-next-line max-params
  function(node2, test, index, parent, context) {
    const check = convertElement2(test);
    if (index !== void 0 && index !== null && (typeof index !== "number" || index < 0 || index === Number.POSITIVE_INFINITY)) {
      throw new Error("Expected positive finite index for child node");
    }
    if (parent !== void 0 && parent !== null && (!parent.type || !parent.children)) {
      throw new Error("Expected parent node");
    }
    if (!node2 || !node2.type || typeof node2.type !== "string") {
      return false;
    }
    if ((parent === void 0 || parent === null) !== (index === void 0 || index === null)) {
      throw new Error("Expected both parent and index");
    }
    return check.call(context, node2, index, parent);
  }
);
var convertElement2 = (
  /**
   * @type {(
   *   (<T extends Element>(test: T['tagName'] | TestFunctionPredicate<T>) => AssertPredicate<T>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test | null | undefined} [test]
   * @returns {AssertAnything}
   */
  function(test) {
    if (test === void 0 || test === null) {
      return element2;
    }
    if (typeof test === "string") {
      return tagNameFactory2(test);
    }
    if (typeof test === "object") {
      return anyFactory4(test);
    }
    if (typeof test === "function") {
      return castFactory4(test);
    }
    throw new Error("Expected function, string, or array as test");
  }
);
function anyFactory4(tests) {
  const checks = [];
  let index = -1;
  while (++index < tests.length) {
    checks[index] = convertElement2(tests[index]);
  }
  return castFactory4(any);
  function any(...parameters) {
    let index2 = -1;
    while (++index2 < checks.length) {
      if (checks[index2].call(this, ...parameters)) {
        return true;
      }
    }
    return false;
  }
}
function tagNameFactory2(check) {
  return tagName;
  function tagName(node2) {
    return element2(node2) && node2.tagName === check;
  }
}
function castFactory4(check) {
  return assertion;
  function assertion(node2, ...parameters) {
    return element2(node2) && Boolean(check.call(this, node2, ...parameters));
  }
}
function element2(node2) {
  return Boolean(
    node2 && typeof node2 === "object" && // @ts-expect-error Looks like a node.
    node2.type === "element" && // @ts-expect-error Looks like an element.
    typeof node2.tagName === "string"
  );
}

// node_modules/hast-util-to-mdast/node_modules/hast-util-has-property/lib/index.js
var own2 = {}.hasOwnProperty;
function hasProperty(node2, field) {
  const value = typeof field === "string" && isNode(node2) && node2.type === "element" && node2.properties && own2.call(node2.properties, field) && node2.properties[field];
  return value !== null && value !== void 0 && value !== false;
}
function isNode(value) {
  return Boolean(value && typeof value === "object" && "type" in value);
}

// node_modules/hast-util-to-mdast/node_modules/hast-util-embedded/lib/index.js
var embedded2 = convertElement2([
  "audio",
  "canvas",
  "embed",
  "iframe",
  "img",
  "math",
  "object",
  "picture",
  "svg",
  "video"
]);

// node_modules/hast-util-to-mdast/node_modules/hast-util-is-body-ok-link/index.js
var list = /* @__PURE__ */ new Set(["pingback", "prefetch", "stylesheet"]);
function isBodyOkLink(node2) {
  if (!isElement2(node2, "link")) {
    return false;
  }
  if (hasProperty(node2, "itemProp")) {
    return true;
  }
  const props = node2.properties || {};
  const rel = props.rel || [];
  let index = -1;
  if (!Array.isArray(rel) || rel.length === 0) {
    return false;
  }
  while (++index < rel.length) {
    if (!list.has(String(rel[index]))) {
      return false;
    }
  }
  return true;
}

// node_modules/hast-util-to-mdast/node_modules/hast-util-phrasing/lib/index.js
var basic = convertElement2([
  "a",
  "abbr",
  // `area` is in fact only phrasing if it is inside a `map` element.
  // However, since `area`s are required to be inside a `map` element, and it’s
  // a rather involved check, it’s ignored here for now.
  "area",
  "b",
  "bdi",
  "bdo",
  "br",
  "button",
  "cite",
  "code",
  "data",
  "datalist",
  "del",
  "dfn",
  "em",
  "i",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "map",
  "mark",
  "meter",
  "noscript",
  "output",
  "progress",
  "q",
  "ruby",
  "s",
  "samp",
  "script",
  "select",
  "small",
  "span",
  "strong",
  "sub",
  "sup",
  "template",
  "textarea",
  "time",
  "u",
  "var",
  "wbr"
]);
var meta = convertElement2("meta");
function phrasing2(value) {
  return Boolean(
    node(value) && (value.type === "text" || basic(value) || embedded2(value) || isBodyOkLink(value) || meta(value) && hasProperty(value, "itemProp"))
  );
}
function node(value) {
  return value && typeof value === "object" && "type" in value;
}

// node_modules/hast-util-to-mdast/lib/util/wrap.js
function wrap(nodes) {
  return runs(nodes, onphrasing);
  function onphrasing(nodes2) {
    const head = nodes2[0];
    if (nodes2.length === 1 && head.type === "text" && (head.value === " " || head.value === "\n")) {
      return [];
    }
    return { type: "paragraph", children: nodes2 };
  }
}
function wrapNeeded(nodes) {
  let index = -1;
  let node2;
  while (++index < nodes.length) {
    node2 = nodes[index];
    if (!phrasing3(node2) || "children" in node2 && wrapNeeded(node2.children)) {
      return true;
    }
  }
  return false;
}
function runs(nodes, onphrasing, onnonphrasing) {
  const nonphrasing = onnonphrasing || identity;
  const flattened = flatten(nodes);
  let result = [];
  let index = -1;
  let queue;
  let node2;
  while (++index < flattened.length) {
    node2 = flattened[index];
    if (phrasing3(node2)) {
      if (!queue) queue = [];
      queue.push(node2);
    } else {
      if (queue) {
        result = result.concat(onphrasing(queue));
        queue = void 0;
      }
      result = result.concat(nonphrasing(node2));
    }
  }
  if (queue) {
    result = result.concat(onphrasing(queue));
  }
  return result;
}
function flatten(nodes) {
  let flattened = [];
  let index = -1;
  let node2;
  while (++index < nodes.length) {
    node2 = nodes[index];
    if ((node2.type === "delete" || node2.type === "link") && wrapNeeded(node2.children)) {
      flattened = flattened.concat(split(node2));
    } else {
      flattened.push(node2);
    }
  }
  return flattened;
}
function split(node2) {
  return runs(node2.children, onphrasing, onnonphrasing);
  function onnonphrasing(child) {
    if ("children" in child && "children" in node2) {
      const { children, ...rest } = node2;
      return {
        ...child,
        // @ts-expect-error: assume matching parent & child.
        children: [{ ...(0, import_extend.default)(true, {}, rest), children: child.children }]
      };
    }
    return { ...child };
  }
  function onphrasing(nodes) {
    const { children, ...rest } = node2;
    return { ...(0, import_extend.default)(true, {}, rest), children: nodes };
  }
}
function phrasing3(node2) {
  return node2.data && node2.data.hName ? phrasing2({
    type: "element",
    tagName: node2.data.hName,
    properties: {},
    children: []
  }) : phrasing(node2);
}
function identity(n) {
  return n;
}

// node_modules/hast-util-to-mdast/lib/util/wrap-children.js
function wrapChildren(h, node2) {
  return wrap(all2(h, node2));
}

// node_modules/hast-util-to-mdast/lib/util/resolve.js
function resolve(h, url) {
  if (url === null || url === void 0) {
    return "";
  }
  if (h.frozenBaseUrl) {
    return String(new URL(url, h.frozenBaseUrl));
  }
  return url;
}

// node_modules/hast-util-to-mdast/lib/handlers/a.js
function a(h, node2) {
  const props = node2.properties;
  return h(
    node2,
    "link",
    {
      title: props.title || null,
      url: resolve(h, String(props.href || "") || null)
    },
    all2(h, node2)
  );
}

// node_modules/hast-util-to-mdast/lib/handlers/base.js
function base(h, node2) {
  if (!h.baseFound) {
    h.frozenBaseUrl = String(node2.properties && node2.properties.href || "") || null;
    h.baseFound = true;
  }
}

// node_modules/hast-util-to-mdast/lib/handlers/blockquote.js
function blockquote(h, node2) {
  return h(node2, "blockquote", wrapChildren(h, node2));
}

// node_modules/hast-util-to-mdast/lib/handlers/br.js
function br(h, node2) {
  return h.wrapText ? h(node2, "break") : h(node2, "text", " ");
}

// node_modules/hast-util-to-text/node_modules/hast-util-is-element/index.js
var convertElement3 = (
  /**
   * @type {(
   *   (<T extends Element>(test: T['tagName'] | TestFunctionPredicate<T>) => AssertPredicate<T>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test | null | undefined} [test]
   * @returns {AssertAnything}
   */
  function(test) {
    if (test === void 0 || test === null) {
      return element3;
    }
    if (typeof test === "string") {
      return tagNameFactory3(test);
    }
    if (typeof test === "object") {
      return anyFactory5(test);
    }
    if (typeof test === "function") {
      return castFactory5(test);
    }
    throw new Error("Expected function, string, or array as test");
  }
);
function anyFactory5(tests) {
  const checks = [];
  let index = -1;
  while (++index < tests.length) {
    checks[index] = convertElement3(tests[index]);
  }
  return castFactory5(any);
  function any(...parameters) {
    let index2 = -1;
    while (++index2 < checks.length) {
      if (checks[index2].call(this, ...parameters)) {
        return true;
      }
    }
    return false;
  }
}
function tagNameFactory3(check) {
  return tagName;
  function tagName(node2) {
    return element3(node2) && node2.tagName === check;
  }
}
function castFactory5(check) {
  return assertion;
  function assertion(node2, ...parameters) {
    return element3(node2) && Boolean(check.call(this, node2, ...parameters));
  }
}
function element3(node2) {
  return Boolean(
    node2 && typeof node2 === "object" && // @ts-expect-error Looks like a node.
    node2.type === "element" && // @ts-expect-error Looks like an element.
    typeof node2.tagName === "string"
  );
}

// node_modules/unist-util-find-after/node_modules/unist-util-is/lib/index.js
var convert3 = (
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {AssertAnything}
   */
  function(test) {
    if (test === void 0 || test === null) {
      return ok3;
    }
    if (typeof test === "string") {
      return typeFactory3(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory6(test) : propsFactory3(test);
    }
    if (typeof test === "function") {
      return castFactory6(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory6(tests) {
  const checks = [];
  let index = -1;
  while (++index < tests.length) {
    checks[index] = convert3(tests[index]);
  }
  return castFactory6(any);
  function any(...parameters) {
    let index2 = -1;
    while (++index2 < checks.length) {
      if (checks[index2].call(this, ...parameters)) return true;
    }
    return false;
  }
}
function propsFactory3(check) {
  return castFactory6(all3);
  function all3(node2) {
    let key;
    for (key in check) {
      if (node2[key] !== check[key]) return false;
    }
    return true;
  }
}
function typeFactory3(check) {
  return castFactory6(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory6(check) {
  return assertion;
  function assertion(node2, ...parameters) {
    return Boolean(
      node2 && typeof node2 === "object" && "type" in node2 && // @ts-expect-error: fine.
      Boolean(check.call(this, node2, ...parameters))
    );
  }
}
function ok3() {
  return true;
}

// node_modules/unist-util-find-after/lib/index.js
var findAfter = (
  /**
   * @type {(
   *  (<T extends Node>(node: Parent, index: Node | number, test: import('unist-util-is').PredicateTest<T>) => T | null) &
   *  ((node: Parent, index: Node | number, test?: Test) => Node | null)
   * )}
   */
  /**
   * @param {Parent} parent
   * @param {Node | number} index
   * @param {Test} [test]
   * @returns {Node | null}
   */
  function(parent, index, test) {
    const is4 = convert3(test);
    if (!parent || !parent.type || !parent.children) {
      throw new Error("Expected parent node");
    }
    if (typeof index === "number") {
      if (index < 0 || index === Number.POSITIVE_INFINITY) {
        throw new Error("Expected positive finite number as index");
      }
    } else {
      index = parent.children.indexOf(index);
      if (index < 0) {
        throw new Error("Expected child node or index");
      }
    }
    while (++index < parent.children.length) {
      if (is4(parent.children[index], index, parent)) {
        return parent.children[index];
      }
    }
    return null;
  }
);

// node_modules/hast-util-to-text/lib/index.js
var searchLineFeeds = /\n/g;
var searchTabOrSpaces = /[\t ]+/g;
var br2 = convertElement3("br");
var p = convertElement3("p");
var cell = convertElement3(["th", "td"]);
var row = convertElement3("tr");
var notRendered = convertElement3([
  // List from: <https://html.spec.whatwg.org/#hidden-elements>
  "datalist",
  "head",
  "noembed",
  "noframes",
  "noscript",
  // Act as if we support scripting.
  "rp",
  "script",
  "style",
  "template",
  "title",
  // Hidden attribute.
  hidden,
  // From: <https://html.spec.whatwg.org/#flow-content-3>
  closedDialog
]);
var blockOrCaption = convertElement3([
  "address",
  // Flow content
  "article",
  // Sections and headings
  "aside",
  // Sections and headings
  "blockquote",
  // Flow content
  "body",
  // Page
  "caption",
  // `table-caption`
  "center",
  // Flow content (legacy)
  "dd",
  // Lists
  "dialog",
  // Flow content
  "dir",
  // Lists (legacy)
  "dl",
  // Lists
  "dt",
  // Lists
  "div",
  // Flow content
  "figure",
  // Flow content
  "figcaption",
  // Flow content
  "footer",
  // Flow content
  "form,",
  // Flow content
  "h1",
  // Sections and headings
  "h2",
  // Sections and headings
  "h3",
  // Sections and headings
  "h4",
  // Sections and headings
  "h5",
  // Sections and headings
  "h6",
  // Sections and headings
  "header",
  // Flow content
  "hgroup",
  // Sections and headings
  "hr",
  // Flow content
  "html",
  // Page
  "legend",
  // Flow content
  "listing",
  // Flow content (legacy)
  "main",
  // Flow content
  "menu",
  // Lists
  "nav",
  // Sections and headings
  "ol",
  // Lists
  "p",
  // Flow content
  "plaintext",
  // Flow content (legacy)
  "pre",
  // Flow content
  "section",
  // Sections and headings
  "ul",
  // Lists
  "xmp"
  // Flow content (legacy)
]);
function toText(tree, options = {}) {
  const children = "children" in tree ? tree.children : [];
  const block2 = blockOrCaption(tree);
  const whitespace2 = inferWhitespace(tree, {
    whitespace: options.whitespace || "normal",
    breakBefore: false,
    breakAfter: false
  });
  const results = [];
  if (tree.type === "text" || tree.type === "comment") {
    results.push(
      ...collectText(tree, {
        whitespace: whitespace2,
        breakBefore: true,
        breakAfter: true
      })
    );
  }
  let index = -1;
  while (++index < children.length) {
    results.push(
      ...innerTextCollection(children[index], tree, {
        whitespace: whitespace2,
        breakBefore: index ? void 0 : block2,
        breakAfter: index < children.length - 1 ? br2(children[index + 1]) : block2
      })
    );
  }
  const result = [];
  let count;
  index = -1;
  while (++index < results.length) {
    const value = results[index];
    if (typeof value === "number") {
      if (count !== void 0 && value > count) count = value;
    } else if (value) {
      if (count !== void 0 && count > -1) {
        result.push("\n".repeat(count) || " ");
      }
      count = -1;
      result.push(value);
    }
  }
  return result.join("");
}
function innerTextCollection(node2, parent, info) {
  if (node2.type === "element") {
    return collectElement(node2, parent, info);
  }
  if (node2.type === "text") {
    return info.whitespace === "normal" ? collectText(node2, info) : collectPreText(node2);
  }
  return [];
}
function collectElement(node2, parent, info) {
  const whitespace2 = inferWhitespace(node2, info);
  const children = node2.children || [];
  let index = -1;
  let items = [];
  if (notRendered(node2)) {
    return items;
  }
  let prefix2;
  let suffix;
  if (br2(node2)) {
    suffix = "\n";
  } else if (row(node2) && findAfter(parent, node2, row)) {
    suffix = "\n";
  } else if (p(node2)) {
    prefix2 = 2;
    suffix = 2;
  } else if (blockOrCaption(node2)) {
    prefix2 = 1;
    suffix = 1;
  }
  while (++index < children.length) {
    items = items.concat(
      innerTextCollection(children[index], node2, {
        whitespace: whitespace2,
        breakBefore: index ? void 0 : prefix2,
        breakAfter: index < children.length - 1 ? br2(children[index + 1]) : suffix
      })
    );
  }
  if (cell(node2) && findAfter(parent, node2, cell)) {
    items.push("	");
  }
  if (prefix2) items.unshift(prefix2);
  if (suffix) items.push(suffix);
  return items;
}
function collectText(node2, info) {
  const value = String(node2.value);
  const lines = [];
  const result = [];
  let start = 0;
  while (start <= value.length) {
    searchLineFeeds.lastIndex = start;
    const match = searchLineFeeds.exec(value);
    const end = match && "index" in match ? match.index : value.length;
    lines.push(
      // Any sequence of collapsible spaces and tabs immediately preceding or
      // following a segment break is removed.
      trimAndCollapseSpacesAndTabs(
        // […] ignoring bidi formatting characters (characters with the
        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if
        // they were not there.
        value.slice(start, end).replace(/[\u061C\u200E\u200F\u202A-\u202E\u2066-\u2069]/g, ""),
        start === 0 ? info.breakBefore : true,
        end === value.length ? info.breakAfter : true
      )
    );
    start = end + 1;
  }
  let index = -1;
  let join;
  while (++index < lines.length) {
    if (lines[index].charCodeAt(lines[index].length - 1) === 8203 || index < lines.length - 1 && lines[index + 1].charCodeAt(0) === 8203) {
      result.push(lines[index]);
      join = void 0;
    } else if (lines[index]) {
      if (typeof join === "number") result.push(join);
      result.push(lines[index]);
      join = 0;
    } else if (index === 0 || index === lines.length - 1) {
      result.push(0);
    }
  }
  return result;
}
function collectPreText(node2) {
  return [String(node2.value)];
}
function trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {
  const result = [];
  let start = 0;
  let end;
  while (start < value.length) {
    searchTabOrSpaces.lastIndex = start;
    const match = searchTabOrSpaces.exec(value);
    end = match ? match.index : value.length;
    if (!start && !end && match && !breakBefore) {
      result.push("");
    }
    if (start !== end) {
      result.push(value.slice(start, end));
    }
    start = match ? end + match[0].length : end;
  }
  if (start !== end && !breakAfter) {
    result.push("");
  }
  return result.join(" ");
}
function inferWhitespace(node2, info) {
  if (node2.type === "element") {
    const props = node2.properties || {};
    switch (node2.tagName) {
      case "listing":
      case "plaintext":
      case "xmp": {
        return "pre";
      }
      case "nobr": {
        return "nowrap";
      }
      case "pre": {
        return props.wrap ? "pre-wrap" : "pre";
      }
      case "td":
      case "th": {
        return props.noWrap ? "nowrap" : info.whitespace;
      }
      case "textarea": {
        return "pre-wrap";
      }
      default:
    }
  }
  return info.whitespace;
}
function hidden(node2) {
  return Boolean((node2.properties || {}).hidden);
}
function closedDialog(node2) {
  return node2.tagName === "dialog" && !(node2.properties || {}).open;
}

// node_modules/trim-trailing-lines/index.js
function trimTrailingLines(value) {
  const input3 = String(value);
  let end = input3.length;
  while (end > 0) {
    const code2 = input3.codePointAt(end - 1);
    if (code2 !== void 0 && (code2 === 10 || code2 === 13)) {
      end--;
    } else {
      break;
    }
  }
  return input3.slice(0, end);
}

// node_modules/hast-util-to-mdast/lib/handlers/code.js
var prefix = "language-";
var pre = convertElement2("pre");
var isCode = convertElement2("code");
function code(h, node2) {
  const children = node2.children;
  let index = -1;
  let classList;
  let lang;
  if (pre(node2)) {
    while (++index < children.length) {
      const child = children[index];
      if (isCode(child) && child.properties && child.properties.className && Array.isArray(child.properties.className)) {
        classList = child.properties.className;
        break;
      }
    }
  }
  if (classList) {
    index = -1;
    while (++index < classList.length) {
      if (String(classList[index]).slice(0, prefix.length) === prefix) {
        lang = String(classList[index]).slice(prefix.length);
        break;
      }
    }
  }
  return h(
    node2,
    "code",
    { lang: lang || null, meta: null },
    trimTrailingLines(wrapText(h, toText(node2)))
  );
}

// node_modules/hast-util-to-mdast/lib/handlers/comment.js
function comment(h, node2) {
  return h(node2, "html", "<!--" + wrapText(h, node2.value) + "-->");
}

// node_modules/hast-util-to-mdast/lib/handlers/del.js
function del(h, node2) {
  return h(node2, "delete", all2(h, node2));
}

// node_modules/hast-util-to-mdast/lib/util/list-items-spread.js
function listItemsSpread(children) {
  let index = -1;
  if (children.length > 1) {
    while (++index < children.length) {
      if (children[index].spread) {
        return true;
      }
    }
  }
  return false;
}

// node_modules/hast-util-to-mdast/lib/util/wrap-list-items.js
function wrapListItems(h, node2) {
  const children = all2(h, node2);
  let index = -1;
  while (++index < children.length) {
    const child = children[index];
    if (child.type !== "listItem") {
      children[index] = {
        type: "listItem",
        spread: false,
        checked: null,
        // @ts-expect-error Assume `children[index]` is block content.
        children: [child]
      };
    }
  }
  return children;
}

// node_modules/hast-util-to-mdast/lib/handlers/dl.js
var div = convertElement2("div");
var dt = convertElement2("dt");
var dd = convertElement2("dd");
function dl(h, node2) {
  const children = node2.children;
  let index = -1;
  let clean = [];
  const groups = [];
  let group = { titles: [], definitions: [] };
  let child;
  let result;
  while (++index < children.length) {
    child = children[index];
    clean = clean.concat(div(child) ? child.children : child);
  }
  index = -1;
  while (++index < clean.length) {
    child = clean[index];
    if (dt(child)) {
      if (dd(clean[index - 1])) {
        groups.push(group);
        group = { titles: [], definitions: [] };
      }
      group.titles.push(child);
    } else {
      group.definitions.push(child);
    }
  }
  groups.push(group);
  index = -1;
  const content3 = [];
  while (++index < groups.length) {
    result = [
      ...handle(h, groups[index].titles),
      ...handle(h, groups[index].definitions)
    ];
    if (result.length > 0) {
      content3.push({
        type: "listItem",
        spread: result.length > 1,
        checked: null,
        children: result
      });
    }
  }
  if (content3.length > 0) {
    return h(
      node2,
      "list",
      { ordered: false, start: null, spread: listItemsSpread(content3) },
      content3
    );
  }
}
function handle(h, children) {
  const nodes = wrapListItems(h, { type: "element", tagName: "x", children });
  if (nodes.length === 0) {
    return [];
  }
  if (nodes.length === 1) {
    return nodes[0].children;
  }
  return [
    {
      type: "list",
      ordered: false,
      start: null,
      spread: listItemsSpread(nodes),
      children: nodes
    }
  ];
}

// node_modules/hast-util-to-mdast/lib/handlers/em.js
function em(h, node2) {
  return h(node2, "emphasis", all2(h, node2));
}

// node_modules/hast-util-to-mdast/lib/handlers/heading.js
function heading(h, node2) {
  const depth = Number(node2.tagName.charAt(1)) || 1;
  const wrap2 = h.wrapText;
  h.wrapText = false;
  const result = h(node2, "heading", { depth }, all2(h, node2));
  h.wrapText = wrap2;
  return result;
}

// node_modules/hast-util-to-mdast/lib/handlers/hr.js
function hr(h, node2) {
  return h(node2, "thematicBreak");
}

// node_modules/hast-util-to-mdast/lib/handlers/iframe.js
function iframe(h, node2) {
  const props = node2.properties;
  const src = String(props.src || "");
  const title = String(props.title || "");
  if (src && title) {
    return {
      type: "link",
      title: null,
      url: resolve(h, src),
      children: [{ type: "text", value: wrapText(h, title) }]
    };
  }
}

// node_modules/hast-util-to-mdast/lib/handlers/img.js
function img(h, node2) {
  const props = node2.properties;
  return h(node2, "image", {
    url: resolve(h, String(props.src || "") || null),
    title: props.title || null,
    alt: props.alt || ""
  });
}

// node_modules/hast-util-to-mdast/lib/handlers/inline-code.js
function inlineCode(h, node2) {
  return h(node2, "inlineCode", wrapText(h, toText(node2)));
}

// node_modules/hast-util-to-mdast/lib/util/find-selected-options.js
var option = convertElement2("option");
function findSelectedOptions(h, node2, properties) {
  const props = properties || node2.properties;
  let options = findOptions(node2);
  const size = Math.min(Number.parseInt(String(props.size), 10), 0) || (props.multiple ? 4 : 1);
  let index = -1;
  const selectedOptions = [];
  const values = [];
  while (++index < options.length) {
    if (hasProperty(options[index], "selected")) {
      selectedOptions.push(options[index]);
    }
  }
  const list3 = selectedOptions.length > 0 ? selectedOptions : options;
  options = list3.slice(0, size);
  index = -1;
  while (++index < options.length) {
    const option2 = options[index];
    const content3 = wrapText(h, toText(option2));
    const props2 = option2.properties;
    const label = content3 || String(props2.label || "");
    const value = String(props2.value || "") || content3;
    values.push([value, label === value ? null : label]);
  }
  return values;
}
function findOptions(node2) {
  const children = node2.children;
  let index = -1;
  let results = [];
  let child;
  while (++index < children.length) {
    child = children[index];
    if (Array.isArray(child.children)) {
      results = results.concat(findOptions(child));
    }
    if (option(child) && !hasProperty(child, "disabled")) {
      results.push(child);
    }
  }
  return results;
}

// node_modules/hast-util-to-mdast/lib/handlers/input.js
var datalist = convertElement2("datalist");
function input(h, node2) {
  const props = node2.properties;
  let value = String(props.value || props.placeholder || "");
  const results = [];
  const texts = [];
  let values = [];
  let index = -1;
  let list3;
  if (props.disabled || props.type === "hidden" || props.type === "file") {
    return;
  }
  if (props.type === "checkbox" || props.type === "radio") {
    return h(
      node2,
      "text",
      wrapText(h, h[props.checked ? "checked" : "unchecked"])
    );
  }
  if (props.type === "image") {
    return props.alt || value ? h(node2, "image", {
      url: resolve(h, String(props.src || "") || null),
      title: wrapText(h, String(props.title || "")) || null,
      alt: wrapText(h, String(props.alt || value))
    }) : [];
  }
  if (value) {
    values = [[value, null]];
  } else if (
    // `list` is not supported on these types:
    props.type !== "password" && props.type !== "file" && props.type !== "submit" && props.type !== "reset" && props.type !== "button" && props.list
  ) {
    list3 = String(props.list).toUpperCase();
    if (own.call(h.nodeById, list3) && datalist(h.nodeById[list3])) {
      values = findSelectedOptions(h, h.nodeById[list3], props);
    }
  }
  if (values.length === 0) {
    return;
  }
  if (props.type === "password") {
    values[0] = ["•".repeat(values[0][0].length), null];
  }
  if (props.type === "url" || props.type === "email") {
    while (++index < values.length) {
      value = resolve(h, values[index][0]);
      results.push(
        h(
          node2,
          "link",
          {
            title: null,
            url: wrapText(h, props.type === "email" ? "mailto:" + value : value)
          },
          [{ type: "text", value: wrapText(h, values[index][1] || value) }]
        )
      );
      if (index !== values.length - 1) {
        results.push({ type: "text", value: ", " });
      }
    }
    return results;
  }
  while (++index < values.length) {
    texts.push(
      values[index][1] ? values[index][1] + " (" + values[index][0] + ")" : values[index][0]
    );
  }
  return h(node2, "text", wrapText(h, texts.join(", ")));
}

// node_modules/hast-util-to-mdast/lib/handlers/li.js
var p2 = convertElement2("p");
var input2 = convertElement2("input");
function li(h, node2) {
  const head = node2.children[0];
  let checked = null;
  let checkbox;
  let clone;
  if (p2(head)) {
    checkbox = head.children[0];
    if (input2(checkbox) && checkbox.properties && (checkbox.properties.type === "checkbox" || checkbox.properties.type === "radio")) {
      checked = Boolean(checkbox.properties.checked);
      clone = {
        ...node2,
        children: [
          { ...head, children: head.children.slice(1) },
          ...node2.children.slice(1)
        ]
      };
    }
  }
  const content3 = wrapChildren(h, clone || node2);
  return h(node2, "listItem", { spread: content3.length > 1, checked }, content3);
}

// node_modules/hast-util-to-mdast/lib/handlers/list.js
var ol = convertElement2("ol");
function list2(h, node2) {
  const ordered = ol(node2);
  const children = wrapListItems(h, node2);
  let start = null;
  if (ordered) {
    start = hasProperty(node2, "start") ? (
      // @ts-expect-error: `props` exist.
      Number.parseInt(String(node2.properties.start), 10)
    ) : 1;
  }
  return h(
    node2,
    "list",
    { ordered, start, spread: listItemsSpread(children) },
    children
  );
}

// node_modules/hast-util-to-mdast/lib/handlers/media.js
var source = convertElement2("source");
var video = convertElement2("video");
function media(h, node2) {
  let nodes = all2(h, node2);
  const properties = node2.properties;
  const poster = video(node2) && String(properties.poster || "");
  let src = String(properties.src || "");
  let index = -1;
  let linkInFallbackContent = false;
  let child;
  visit({ type: "root", children: nodes }, "link", findLink);
  if (linkInFallbackContent || wrapNeeded(nodes)) {
    return nodes;
  }
  while (!src && ++index < node2.children.length) {
    child = node2.children[index];
    if (source(child)) {
      src = String(child.properties.src || "");
    }
  }
  if (poster) {
    nodes = [
      {
        type: "image",
        title: null,
        url: resolve(h, poster),
        alt: toString({ children: nodes })
      }
    ];
  }
  return {
    type: "link",
    // @ts-expect-error Types are broken.
    title: node2.properties.title || null,
    url: resolve(h, src),
    // @ts-expect-error Assume phrasing content.
    children: nodes
  };
  function findLink() {
    linkInFallbackContent = true;
    return EXIT;
  }
}

// node_modules/hast-util-to-mdast/lib/handlers/p.js
function p3(h, node2) {
  const nodes = all2(h, node2);
  if (nodes.length > 0) {
    return h(node2, "paragraph", nodes);
  }
}

// node_modules/hast-util-to-mdast/lib/handlers/q.js
function q(h, node2) {
  const expected = h.quotes[h.qNesting % h.quotes.length];
  h.qNesting++;
  const contents = all2(h, node2);
  h.qNesting--;
  contents.unshift({ type: "text", value: expected.charAt(0) });
  contents.push({
    type: "text",
    value: expected.length > 1 ? expected.charAt(1) : expected
  });
  return contents;
}

// node_modules/hast-util-to-mdast/lib/handlers/root.js
function root(h, node2) {
  let children = all2(h, node2);
  if (h.document || wrapNeeded(children)) {
    children = wrap(children);
  }
  return h(node2, "root", children);
}

// node_modules/hast-util-to-mdast/lib/handlers/select.js
function select(h, node2) {
  const values = findSelectedOptions(h, node2);
  let index = -1;
  const results = [];
  let value;
  while (++index < values.length) {
    value = values[index];
    results.push(value[1] ? value[1] + " (" + value[0] + ")" : value[0]);
  }
  if (results.length > 0) {
    return h(node2, "text", wrapText(h, results.join(", ")));
  }
}

// node_modules/hast-util-to-mdast/lib/handlers/strong.js
function strong(h, node2) {
  return h(node2, "strong", all2(h, node2));
}

// node_modules/hast-util-to-mdast/lib/handlers/table-cell.js
function tableCell(h, node2) {
  const wrap2 = h.wrapText;
  h.wrapText = false;
  const result = h(node2, "tableCell", all2(h, node2));
  if (node2.properties && (node2.properties.rowSpan || node2.properties.colSpan)) {
    const data = result.data || (result.data = {});
    if (node2.properties.rowSpan) data.rowSpan = node2.properties.rowSpan;
    if (node2.properties.colSpan) data.colSpan = node2.properties.colSpan;
  }
  h.wrapText = wrap2;
  return result;
}

// node_modules/hast-util-to-mdast/lib/handlers/table-row.js
function tableRow(h, node2) {
  return h(node2, "tableRow", all2(h, node2));
}

// node_modules/hast-util-to-mdast/lib/handlers/table.js
var thead = convertElement2("thead");
var tr = convertElement2("tr");
var cell2 = convertElement2(["th", "td"]);
function table(h, node2) {
  if (h.inTable) {
    return h(node2, "text", wrapText(h, toText(node2)));
  }
  h.inTable = true;
  const { headless, align } = inspect(node2);
  const rows = toRows(all2(h, node2), headless);
  let columns = 1;
  let rowIndex = -1;
  while (++rowIndex < rows.length) {
    const cells = rows[rowIndex].children;
    let cellIndex = -1;
    while (++cellIndex < cells.length) {
      const cell3 = cells[cellIndex];
      if (cell3.data) {
        const colSpan = Number.parseInt(String(cell3.data.colSpan), 10) || 1;
        const rowSpan = Number.parseInt(String(cell3.data.rowSpan), 10) || 1;
        if (colSpan > 1 || rowSpan > 1) {
          let otherRowIndex = rowIndex - 1;
          while (++otherRowIndex < rowIndex + rowSpan) {
            let colIndex = cellIndex - 1;
            while (++colIndex < cellIndex + colSpan) {
              if (!rows[otherRowIndex]) {
                break;
              }
              const newCells = [];
              if (otherRowIndex !== rowIndex || colIndex !== cellIndex) {
                newCells.push({ type: "tableCell", children: [] });
              }
              rows[otherRowIndex].children.splice(colIndex, 0, ...newCells);
            }
          }
        }
        if ("colSpan" in cell3.data) delete cell3.data.colSpan;
        if ("rowSpan" in cell3.data) delete cell3.data.rowSpan;
        if (Object.keys(cell3.data).length === 0) delete cell3.data;
      }
    }
    if (cells.length > columns) columns = cells.length;
  }
  rowIndex = -1;
  while (++rowIndex < rows.length) {
    const cells = rows[rowIndex].children;
    let cellIndex = cells.length - 1;
    while (++cellIndex < columns) {
      cells.push({ type: "tableCell", children: [] });
    }
  }
  let alignIndex = align.length - 1;
  while (++alignIndex < columns) {
    align.push(null);
  }
  h.inTable = false;
  return h(node2, "table", { align }, rows);
}
function inspect(node2) {
  let headless = true;
  let rowIndex = 0;
  let cellIndex = 0;
  const align = [null];
  visit(node2, "element", (child) => {
    if (child.tagName === "table" && node2 !== child) {
      return SKIP;
    }
    if (cell2(child) && child.properties) {
      if (!align[cellIndex]) {
        align[cellIndex] = String(child.properties.align || "") || null;
      }
      if (headless && rowIndex < 2 && child.tagName === "th") {
        headless = false;
      }
      cellIndex++;
    } else if (thead(child)) {
      headless = false;
    } else if (tr(child)) {
      rowIndex++;
      cellIndex = 0;
    }
  });
  return { align, headless };
}
function toRows(children, headless) {
  let index = -1;
  const nodes = [];
  let queue;
  if (headless) {
    nodes.push({ type: "tableRow", children: [] });
  }
  while (++index < children.length) {
    const node2 = children[index];
    if (node2.type === "tableRow") {
      if (queue) {
        node2.children.unshift(...queue);
        queue = void 0;
      }
      nodes.push(node2);
    } else {
      if (!queue) queue = [];
      queue.push(node2);
    }
  }
  if (queue) {
    nodes[nodes.length - 1].children.push(...queue);
  }
  index = -1;
  while (++index < nodes.length) {
    nodes[index].children = toCells(nodes[index].children);
  }
  return nodes;
}
function toCells(children) {
  const nodes = [];
  let index = -1;
  let node2;
  let queue;
  while (++index < children.length) {
    node2 = children[index];
    if (node2.type === "tableCell") {
      if (queue) {
        node2.children.unshift(...queue);
        queue = void 0;
      }
      nodes.push(node2);
    } else {
      if (!queue) queue = [];
      queue.push(node2);
    }
  }
  if (queue) {
    node2 = nodes[nodes.length - 1];
    if (!node2) {
      node2 = { type: "tableCell", children: [] };
      nodes.push(node2);
    }
    node2.children.push(...queue);
  }
  return nodes;
}

// node_modules/hast-util-to-mdast/lib/handlers/text.js
function text(h, node2) {
  return h(node2, "text", wrapText(h, node2.value));
}

// node_modules/hast-util-to-mdast/lib/handlers/textarea.js
function textarea(h, node2) {
  return h(node2, "text", wrapText(h, toText(node2)));
}

// node_modules/hast-util-to-mdast/lib/handlers/wbr.js
function wbr(h, node2) {
  return h(node2, "text", "​");
}

// node_modules/hast-util-to-mdast/lib/handlers/index.js
var handlers = {
  root,
  text,
  comment,
  doctype: ignore,
  applet: ignore,
  area: ignore,
  basefont: ignore,
  bgsound: ignore,
  caption: ignore,
  col: ignore,
  colgroup: ignore,
  command: ignore,
  content: ignore,
  datalist: ignore,
  dialog: ignore,
  element: ignore,
  embed: ignore,
  frame: ignore,
  frameset: ignore,
  isindex: ignore,
  keygen: ignore,
  link: ignore,
  math: ignore,
  menu: ignore,
  menuitem: ignore,
  meta: ignore,
  nextid: ignore,
  noembed: ignore,
  noframes: ignore,
  optgroup: ignore,
  option: ignore,
  param: ignore,
  script: ignore,
  shadow: ignore,
  source: ignore,
  spacer: ignore,
  style: ignore,
  svg: ignore,
  template: ignore,
  title: ignore,
  track: ignore,
  abbr: all2,
  acronym: all2,
  bdi: all2,
  bdo: all2,
  big: all2,
  blink: all2,
  button: all2,
  canvas: all2,
  cite: all2,
  data: all2,
  details: all2,
  dfn: all2,
  font: all2,
  ins: all2,
  label: all2,
  map: all2,
  marquee: all2,
  meter: all2,
  nobr: all2,
  noscript: all2,
  object: all2,
  output: all2,
  progress: all2,
  rb: all2,
  rbc: all2,
  rp: all2,
  rt: all2,
  rtc: all2,
  ruby: all2,
  slot: all2,
  small: all2,
  span: all2,
  sup: all2,
  sub: all2,
  tbody: all2,
  tfoot: all2,
  thead: all2,
  time: all2,
  address: wrapChildren,
  article: wrapChildren,
  aside: wrapChildren,
  body: wrapChildren,
  center: wrapChildren,
  div: wrapChildren,
  fieldset: wrapChildren,
  figcaption: wrapChildren,
  figure: wrapChildren,
  form: wrapChildren,
  footer: wrapChildren,
  header: wrapChildren,
  hgroup: wrapChildren,
  html: wrapChildren,
  legend: wrapChildren,
  main: wrapChildren,
  multicol: wrapChildren,
  nav: wrapChildren,
  picture: wrapChildren,
  section: wrapChildren,
  a,
  audio: media,
  b: strong,
  base,
  blockquote,
  br,
  code: inlineCode,
  dir: list2,
  dl,
  dt: li,
  dd: li,
  del,
  em,
  h1: heading,
  h2: heading,
  h3: heading,
  h4: heading,
  h5: heading,
  h6: heading,
  hr,
  i: em,
  iframe,
  img,
  image: img,
  input,
  kbd: inlineCode,
  li,
  listing: code,
  mark: em,
  ol: list2,
  p: p3,
  plaintext: code,
  pre: code,
  q,
  s: del,
  samp: inlineCode,
  select,
  strike: del,
  strong,
  summary: p3,
  table,
  td: tableCell,
  textarea,
  th: tableCell,
  tr: tableRow,
  tt: inlineCode,
  u: em,
  ul: list2,
  var: inlineCode,
  video: media,
  wbr,
  xmp: code
};
function ignore() {
}

// node_modules/hast-util-to-mdast/lib/index.js
var block = convert2(["heading", "paragraph", "root"]);
function toMdast(tree, options = {}) {
  const byId = {};
  let mdast;
  const h = Object.assign(
    /**
     * @type {HWithProps & HWithoutProps}
     */
    /**
     * @param {Node} node
     * @param {string} type
     * @param {Properties|string|Array<Node>} [props]
     * @param {string|Array<Node>} [children]
     */
    (node2, type, props, children) => {
      let properties;
      if (typeof props === "string" || Array.isArray(props)) {
        children = props;
        properties = {};
      } else {
        properties = props;
      }
      const result2 = { type, ...properties };
      if (typeof children === "string") {
        result2.value = children;
      } else if (children) {
        result2.children = children;
      }
      if (node2.position) {
        result2.position = node2.position;
      }
      return result2;
    },
    {
      nodeById: byId,
      baseFound: false,
      inTable: false,
      wrapText: true,
      /** @type {string|null} */
      frozenBaseUrl: null,
      qNesting: 0,
      handlers: options.handlers ? { ...handlers, ...options.handlers } : handlers,
      document: options.document,
      checked: options.checked || "[x]",
      unchecked: options.unchecked || "[ ]",
      quotes: options.quotes || ['"']
    }
  );
  visit(tree, "element", (node2) => {
    const id = node2.properties && "id" in node2.properties && String(node2.properties.id).toUpperCase();
    if (id && !own.call(byId, id)) {
      byId[id] = node2;
    }
  });
  rehypeMinifyWhitespace({ newlines: options.newlines === true })(tree);
  const result = one(h, tree, void 0);
  if (!result) {
    mdast = { type: "root", children: [] };
  } else if (Array.isArray(result)) {
    mdast = { type: "root", children: result };
  } else {
    mdast = result;
  }
  visit(mdast, "text", ontext);
  return mdast;
  function ontext(node2, index, parent) {
    if (index === null || !parent) {
      return;
    }
    const previous = parent.children[index - 1];
    if (previous && previous.type === node2.type) {
      previous.value += node2.value;
      parent.children.splice(index, 1);
      if (previous.position && node2.position) {
        previous.position.end = node2.position.end;
      }
      return index - 1;
    }
    node2.value = node2.value.replace(/[\t ]*(\r?\n|\r)[\t ]*/, "$1");
    if (parent && block(parent)) {
      if (!index) {
        node2.value = node2.value.replace(/^[\t ]+/, "");
      }
      if (index === parent.children.length - 1) {
        node2.value = node2.value.replace(/[\t ]+$/, "");
      }
    }
    if (!node2.value) {
      parent.children.splice(index, 1);
      return index;
    }
  }
}

// node_modules/rehype-remark/lib/index.js
var rehypeRemark = (
  /**
   * @type {(import('unified').Plugin<[Processor, Options?], HastRoot> & import('unified').Plugin<[Options?]|void[], HastRoot, MdastRoot>)}
   */
  /**
   * @param {Processor|Options} [destination]
   * @param {Options} [options]
   */
  function(destination, options) {
    let settings;
    let processor;
    if (typeof destination === "function") {
      processor = destination;
      settings = options || {};
    } else {
      settings = destination || {};
    }
    if (settings.document === void 0 || settings.document === null) {
      settings = Object.assign({}, settings, { document: true });
    }
    return processor ? bridge(processor, settings) : mutate(settings);
  }
);
var lib_default = rehypeRemark;
function bridge(destination, options) {
  return (node2, file, next) => {
    destination.run(toMdast(node2, options), file, (error) => {
      next(error);
    });
  };
}
function mutate(options = {}) {
  return (node2) => {
    const result = (
      /** @type {MdastRoot} */
      toMdast(node2, options)
    );
    return result;
  };
}
export {
  all2 as all,
  lib_default as default,
  handlers as defaultHandlers,
  one
};
//# sourceMappingURL=rehype-remark-PWBG3LRU.js.map
